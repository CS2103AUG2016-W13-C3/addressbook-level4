# A0139080J
###### \java\seedu\commando\commons\core\DateTimePrettifier.java
``` java
/**
 * Collection of methods to prettify date-times for the GUI.
 */
public class DateTimePrettifier {

    // Formatter for displaying the dates for dueLabel in TaskCard, startLabel
    // and endLabel for EventCard
    private static DateTimeFormatter formatTime = DateTimeFormatter.ofPattern("HH:mm");
    private static DateTimeFormatter formatDay = DateTimeFormatter.ofPattern("EEE d");
    private static DateTimeFormatter formatMonth = DateTimeFormatter.ofPattern("MMM");

    // In case I want to change them for some reason
    private static String keywordTo = "to";
    private static String keywordToday = "Today";
    private static String keywordTomorrow = "Tomorrow";
    private static String keywordYesterday = "Yesterday";
    private static String keywordUntil = "Until";
    private static String keywordFrom = "From";
    private static String keywordOnwards = "onwards";
    private static String keywordForever = "Timeless";

    // Date references
    private static LocalDate todayDate = LocalDate.now();
    private static LocalDate tomorrowDate = todayDate.plusDays(1);
    private static LocalDate yesterdayDate = todayDate.minusDays(1);

    /**
     * @param startDateTime
     *            start date time
     * @param endDateTime
     *            end date time
     * @return format in a way that is intuitive to the user
     *
     *         I.e. Dates that in the current year will not show the years I.e.
     *         Dates that are in the same year will only show the year once I.e.
     *         Dates that are tomorrow show up as "tomorrow" (Similarly,
     *         yesterday and today) I.e. Dates that are in the same month will
     *         only show the month once, provided that the year is the same I.e.
     *         Times will be displayed for both no matter what, even if
     *         datetimes are exactly the same
     */
    public static String prettifyDateTimeRange(LocalDateTime startDateTime, LocalDateTime endDateTime) {
        String start = "";
        String end = "";

        boolean sameYear = startDateTime.getYear() == endDateTime.getYear();
        boolean sameMonth = startDateTime.getMonthValue() == endDateTime.getMonthValue();
        boolean sameDay = startDateTime.getDayOfMonth() == endDateTime.getDayOfMonth();
        
        boolean startIsYtdOrTdyOrTmr = isYtdOrTdyOrTmr(startDateTime);
        boolean endIsYtdOrTdyOrTmr = isYtdOrTdyOrTmr(endDateTime);
        
        boolean startDateTimeExists = !startDateTime.equals(LocalDateTime.MIN.withSecond(0).withNano(0));
        boolean endDateTimeExists = !endDateTime.equals(LocalDateTime.MAX);

        // If start date is Yesterday or Today or Tomorrow, shouldn't show month
        // and year
        if (!startDateTimeExists) {
            return keywordUntil + " " + prettifyDateTime(endDateTime);
        } else if (!endDateTimeExists) {
            return keywordFrom + " " + prettifyDateTime(startDateTime) + " " + keywordOnwards;
        } else if (!startDateTimeExists && !endDateTimeExists) {
            return keywordForever;
        }
        
        if (startIsYtdOrTdyOrTmr) {
            // If same day, don't display month and year
            if (sameDay && sameMonth && sameYear) {
                return getTime(startDateTime) + " " + keywordTo + " " + getTime(endDateTime) + "\n"
                        + getDay(startDateTime);
            } else if (endIsYtdOrTdyOrTmr) {
                return getTime(startDateTime) + " " + getDay(startDateTime) + " " + keywordTo + "\n"
                        + getTime(endDateTime) + " " + getDay(endDateTime);
            } else if (endDateTime.getYear() == todayDate.getYear()) {
                return getTime(startDateTime) + " " + getDay(startDateTime) + " " + keywordTo + "\n"
                        + getTime(endDateTime) + " " + getDay(endDateTime) + " " + getMonth(endDateTime);
            } else {
                return getTime(startDateTime) + " " + getDay(startDateTime) + " " + keywordTo + "\n"
                        + getTime(endDateTime) + " " + getDay(endDateTime) + " " + getMonth(endDateTime) + " "
                        + endDateTime.getYear();
            }
        }

        if (sameYear) {
            // If start year is equals to end year
            if (endDateTime.getYear() != todayDate.getYear()) {
                // If both start year and end year is not this year
                end += " " + endDateTime.getYear();
                // Else, don't display any year
            }
        } else {
            // Start and end year are not equal
            // Hence display both
            end += " " + endDateTime.getYear();
            start += " " + startDateTime.getYear();
        }

        if (sameYear && sameMonth) {
            // If same year and same month and same day
            // Display one month
            end = " " + getMonth(endDateTime) + end;
        } else {
            // Display both months
            start = " " + getMonth(startDateTime) + start;
            end = " " + getMonth(endDateTime) + end;
        }
        
        if (sameYear && sameMonth && sameDay) {
            // If same year and same month and same day
            // Display one month
            end = "\n" + getDay(endDateTime) + end;
        } else {
            // Display both months
            start = " " + getDay(startDateTime) + start;
            end = " " + getDay(endDateTime) + end;
        }

        // If exactly the same date, start will be "", hence there is a need to
        // get rid
        // of the extra space
        start = getTime(startDateTime) + start;
        end = getTime(endDateTime) + end;

        // If its the same day, there is no need to display the date on two
        // lines
        // because its comparatively short to other intervals that span over
        // days
        if (!sameYear || !sameMonth || !sameDay) {
            return start + " " + keywordTo + "\n" + end;
        } else {
            return start + " " + keywordTo + " " + end;
        }
    }

    private static boolean isYtdOrTdyOrTmr(LocalDateTime localDateTime) {
        return localDateTime.toLocalDate().isEqual(todayDate) || localDateTime.toLocalDate().isEqual(tomorrowDate)
                || localDateTime.toLocalDate().isEqual(yesterdayDate);
    }

    /**
     * @param ldt
     * @return a date or 'today' or 'yesterday' or 'tomorrow'
     */
    private static String getDay(LocalDateTime ldt) {
        final LocalDate ld = ldt.toLocalDate();
        if (ld.isEqual(yesterdayDate)) {
            return keywordYesterday;
        } else if (ld.isEqual(todayDate)) {
            return keywordToday;
        } else if (ld.isEqual(tomorrowDate)) {
            return keywordTomorrow;
        } else {
            return formatDay.format(ldt);
        }
    }

    /**
     * @param ldt
     * @return the month of the date
     */
    private static String getMonth(LocalDateTime ldt) {
        return formatMonth.format(ldt);
    }

    /**
     * @param ldt
     * @return the time of the date
     */
    private static String getTime(LocalDateTime ldt) {
        return formatTime.format(ldt);
    }

    /**
     * @param the
     *            date and time (LocalDateTime)
     * @return format in a way that is intuitive to the user
     *
     *         I.e. Dates that in the current year will not show the years I.e.
     *         Dates that are today show up as "Today" I.e. Dates that are
     *         tomrorow show up as "Tmr"
     */
    public static String prettifyDateTime(LocalDateTime dateTime) {
        boolean isYtdOrTdyOrTmr = isYtdOrTdyOrTmr(dateTime);

        if (isYtdOrTdyOrTmr) {
            return getTime(dateTime) + " " + getDay(dateTime);
        } else if (dateTime.getYear() == todayDate.getYear()) {
            return getTime(dateTime) + " " + getDay(dateTime) + " " + getMonth(dateTime);
        } else {
            return getTime(dateTime) + " " + getDay(dateTime) + " " + getMonth(dateTime) + " " + dateTime.getYear();
        }
    }
}
```
###### \java\seedu\commando\commons\core\Messages.java
``` java
    public static final String STORE_COMMAND_FORMAT = ">> store <file path> [override]";
    public static final String IMPORT_COMMAND_FORMAT = ">> import <file path>";
    public static final String EXPORT_COMMAND_FORMAT = ">> export <file path>";
    public static final String ADD_COMMAND_FORMAT = ">> add <description of task> #<tag1> #<tag2>...\n" +
        ">> add <description of task> by <due datetime> <recurrence> #<tag1> #<tag2>...\n" +
        ">> add <description of event> on <datetime> <recurrence> #<tag1> #<tag2>...\n" +
        ">> add <description of event> from <start datetime> to <end datetime> <recurrence> #<tag1> #<tag2>...";
    public static final String DELETE_COMMAND_FORMAT = ">> delete <index1> <index2>...\n" +
        ">> delete <index1> <index2>... time\n" +
        ">> delete <index1> <index2>... tag";
    public static final String EDIT_COMMAND_FORMAT = ">> edit <index> <new description of event>  #<new tag 1> #<new tag 2>...\n" +
        ">> edit <index> from <new start datetime> to <new end datetime> <new recurrence>\n" +
        ">> edit <index> by <new due datetime> <new recurrence>\n";
    public static final String FINISH_COMMAND_FORMAT = ">> finish <index1> <index2>...";
    public static final String UNFINISH_COMMAND_FORMAT = ">> unfinish <index1> <index2>...";
    public static final String LIST_COMMAND_FORMAT = ">> list \n" +
        ">> list on <datetime> \n" +
        ">> list from <start datetime> to <end datetime>";

    public static final String UNKNOWN_COMMAND = "Unknown command: '%1$s'. \n"
        + HELP_COMMAND_FORMAT;

    public static final String MISSING_COMMAND_WORD = "Missing command word.";
    public static final String INVALID_COMMAND_FORMAT = "Invalid format for '%1$s' command!";
    public static final String MISSING_TODO_TITLE = "Missing title for to-do.";
    public static final String MISSING_TODO_DATERANGE_START = "Missing start date for date range of to-do.";
    public static final String MISSING_TODO_DATERANGE_END = "Missing end date for date range of to-do.";
    public static final String INVALID_TODO_DATERANGE_START = "Invalid start date for date range of to-do.";
    public static final String INVALID_TODO_DATERANGE_END = "Invalid end date for date range of to-do.";
    public static final String MISSING_TODO_ITEM_INDEX = "Missing to-do item index.";
    public static final String INDEXRANGE_CONSTRAINTS = "The end index must be equal or larger than the start index.";

    public static final String TODO_DATERANGE_END_MUST_AFTER_START = "The end date of the date range must be after start date.";
    public static final String TODO_DATERANGE_RECURRENCE_INVALID = "The recurrence for the given date range is not valid.";
    public static final String TODO_ALREADY_EXISTS = "To-do already exists!";
    public static final String TODO_NOT_FOUND = "To-do not found: %1$s";
    public static final String TODO_ITEM_INDEX_INVALID = "Invalid to-do index: %1$d.";
    public static final String TODO_CANNOT_HAVE_DUEDATE_AND_DATERANGE = "To-do cannot have both due date and date range!";

    public static final String MISSING_STORE_PATH = "Missing the path to store.";
    public static final String MISSING_IMPORT_PATH = "Missing the path to import.";
    public static final String MISSING_EXPORT_PATH = "Missing the path to export.";
    public static final String MISSING_STORE_FILE = "Missing the file name to store.";
    public static final String MISSING_EXPORT_FILE = "Missing the file name to export.";
    public static final String MISSING_IMPORT_FILE = "Missing the file name to import.";

    public static final String FINISH_COMMAND = "Task marked as done: %1$s.";
    public static final String FINISH_COMMAND_ALREADY_FINISHED = "Task already marked done: %1$s";
    public static final String FINISH_COMMAND_CANNOT_FINISH_EVENT = "To-do must be a task to be marked done: %1$s.";
    public static final String UNFINISHED_COMMAND = "Task marked as undone: %1$s.";
    public static final String UNFINISH_COMMAND_ALREADY_ONGOING = "Task already marked undone: %1$s.";
    public static final String UNFINISH_COMMAND_CANNOT_UNFINISH_EVENT = "To-do must be a task to be marked undone: %1$s.";
    public static final String UNDO_COMMAND = "Undid the last command.";
    public static final String UNDO_COMMAND_FAIL = "Nothing more to undo!";
    public static final String REDO_COMMAND = "Redid the last undo command.";
    public static final String REDO_COMMAND_FAIL = "Nothing more to redo!";
    public static final String STORE_COMMAND = "Changed the storage path to: %1$s.";
    public static final String STORE_COMMAND_FILE_EXIST = "Failed to store the storage file to %1$s: destination file exists. Add `override` behind command to force a file override.";
    public static final String EXPORT_COMMAND = "Export the storage file to: %1$s.";
    public static final String EXPORT_COMMAND_FILE_EXIST = "Failed to export the storage file to %1$s: destination file exists. Add `override` behind command to force a file override.";
    public static final String IMPORT_COMMAND = "Import the storage file from: %1$s.";
    public static final String IMPORT_COMMAND_FILE_NOT_EXIST = "Failed to import file from %1$s: the file does not exist.";
    public static final String IMPORT_COMMAND_INVALID_DATA = "Failed to import file from %1$s: the file is of an invalid format.";
    public static final String ADD_COMMAND = "Added: %1$s.";
    public static final String ADD_COMMAND_EVENT_OVER_WARNING = "Warning: event added is already over!\n" +
        "Use `recall` to find the to-do.";
    public static final String EDIT_COMMAND = "Edited: %1$s.";
    public static final String EDIT_COMMAND_NO_EDITS = "But nothing happened.";
    public static final String EDIT_COMMAND_EVENT_OVER_WARNING = "Warning: event edited is already over!\n" +
        "Use `recall` to find the to-do.";
    public static final String DELETE_COMMAND = "Deleted: %1$s.";
    public static final String DELETE_COMMAND_NO_TAGS = "To-do with index '%1$s' has no tags to delete!";
    public static final String DELETE_COMMAND_NO_TIME_CONSTRAINTS = "To-do with index '%1$s' has no time constraints to delete!";
    public static final String DELETE_COMMAND_NO_RECURRENCE = "To-do with index '%1$s' has no recurrence to delete!";
    public static final String FIND_COMMAND = "Found unfinished to-dos matching keywords and tags of %1$s.";
    public static final String FIND_COMMAND_CLEAR = "Listing all unfinished to-dos.";
    public static final String FIND_COMMAND_NO_TODOS = "No unfinished to-dos found matching keywords and tags of %1$s.";
    public static final String LIST_COMMAND_CLEAR = "Listing all to-dos.";
    public static final String LIST_COMMAND = "Listing all to-dos in date range: %1$s";
    public static final String LIST_COMMAND_NO_TODOS = "No to-dos found in date range: %1$s";
    public static final String RECALL_COMMAND = "Listing all finished to-dos matching keywords and tags of %1$s.";
    public static final String RECALL_COMMAND_NO_TODOS = "No finished to-dos found matching keywords and tags of %1$s.";
    public static final String RECALL_COMMAND_CLEAR = "Listing all finished to-dos.";
    public static final String EXIT_COMMAND = "Exiting application...";
    public static final String CLEAR_COMMAND = "Boom. Cleared to-do list!";
    public static final String HELP_COMMAND = "Opened help window.";
    public static final String HELP_COMMAND_TOPIC = "Opened help window for topic '%1$s'.";
    public static final String HELP_COMMAND_INVALID_TOPIC = "Invalid topic for `help`.\n"
                                                        + HELP_COMMAND_FORMAT;

    /**
     * Returns an additional invalid command format message to be appended
     * for a {@param commandWord}.
     */
    public static Optional<String> getCommandFormatMessage(String commandWord) {
        switch (commandWord) {
            case StoreCommand.COMMAND_WORD:
                return Optional.of(STORE_COMMAND_FORMAT);
            case ImportCommand.COMMAND_WORD:
                return Optional.of(IMPORT_COMMAND_FORMAT);
            case ExportCommand.COMMAND_WORD:
                return Optional.of(EXPORT_COMMAND_FORMAT);
            case AddCommand.COMMAND_WORD:
                return Optional.of(ADD_COMMAND_FORMAT);
            case DeleteCommand.COMMAND_WORD:
                return Optional.of(DELETE_COMMAND_FORMAT);
            case EditCommand.COMMAND_WORD:
                return Optional.of(EDIT_COMMAND_FORMAT);
            case FinishCommand.COMMAND_WORD:
                return Optional.of(FINISH_COMMAND_FORMAT);
            case UnfinishCommand.COMMAND_WORD:
                return Optional.of(UNFINISH_COMMAND_FORMAT);
            case ListCommand.COMMAND_WORD:
            	return Optional.of(LIST_COMMAND_FORMAT);
            default: break; 
        }
        return Optional.empty();
    }
```
###### \java\seedu\commando\ui\CardStyleManager.java
``` java
/**
 * Contains the common functions and variables that EventCard and TaskCard
 * shares
 */
public class CardStyleManager {
    /**
     * Adds given style to all nodes providede
     */
    public static void addStyleAll(String style, Node... nodes) {
        for (Node node : nodes) {
            node.getStyleClass().add(style);
        }
    }

    /**
     * Removes given style to all nodes providede
     */
    public static void removeStyleAll(String style, Node... nodes) {
        for (Node node : nodes) {
            node.getStyleClass().remove(style);
        }
    }

    /**
     * @param dayDifference
     * @return colour code for a date label. The closer it is to today, the more
     *         red it will become, otherwise, tends towards green. If it is
     *         already over (neg), it is fully red.
     */
    protected static String getDateProximityGreen(int dayDifference) {
        if (dayDifference < 0) {
            return "#FF0000";
        } else if (dayDifference <= 1) {
            return "#882200";
        } else if (dayDifference <= 3) {
            return "#775500";
        } else if (dayDifference <= 7) {
            return "#778800";
        } else if (dayDifference <= 14) {
            return "#686033";
        } else {
            return "#386D33";
        }
    }

    /**
     * @param dayDifference
     * @return colour code for a date label. The closer it is to today, the more
     *         red it will become, otherwise, tends towards blue. If it is
     *         already over (neg), it is fully red.
     */
    protected static String getDateProximityBlue(int dayDifference) {
        if (dayDifference < 0) {
            return "#FF0000";
        } else if (dayDifference <= 1) {
            return "#DD0A00";
        } else if (dayDifference <= 3) {
            return "#AA2100";
        } else if (dayDifference <= 7) {
            return "#69326B";
        } else if (dayDifference <= 14) {
            return "#3C26A8";
        } else {
            return "#0011FF";
        }
    }

}
```
###### \java\seedu\commando\ui\CommandBox.java
``` java
    /**
     * This and the next method: Switches through a list of commands, invalid or
     * valid. If the boundary of the list is reached, display nothing.
     */
    protected void goUpCommandHistory() {
        if (!commandHistory.isEmpty()) {
            if (commandHistoryPointer > 0) {
                setTextAndPositionCaret(--commandHistoryPointer);
            } else if (commandHistoryPointer == 0) {
                setTextAndPositionCaret(commandHistoryPointer);
            }
        }
    }

    protected void goDownCommandHistory() {
        if (!commandHistory.isEmpty()) {
            if (commandHistoryPointer < commandHistory.size() - 1) {
                setTextAndPositionCaret(++commandHistoryPointer);
            } else if (commandHistoryPointer == commandHistory.size() - 1) {
                commandTextField.setText("");
                commandHistoryPointer++;
            }
        }
    }

    private void setTextAndPositionCaret(int pointer) {
        commandTextField.setText(commandHistory.get(pointer));
        setCaretAtEndOfText();
    }

    private void setCaretAtEndOfText() {
        Platform.runLater(new Runnable() {
            @Override
            public void run() {
                commandTextField.positionCaret(commandTextField.getLength());
            }
        });
    }
```
###### \java\seedu\commando\ui\EventCard.java
``` java
    /**
     * Creates a variable number of labels and put them in a flowpane
     */
    private void createTagLabels() {
        if (!toDo.getTags().isEmpty()) {
            for (Tag tag : toDo.getTags()) {
                Label label = new Label();
                label.setText("#" + tag.value);
                label.setId("tagsLabel");
                label.setMaxWidth(200);
                label.getStyleClass().add("cell_big_label");
                label.setAlignment(Pos.CENTER);
                label.setPadding(new Insets(0, 3, 0, 3));

                tagsPane.getChildren().add(label);
            }
        } else {
            containsTags = false;
        }
    }

    private void setRecurrenceLabel() {
        if (toDo.getDateRange().isPresent() && toDo.getDateRange().get().recurrence != Recurrence.None) {
            recurrenceLabel.setText(toDo.getDateRange().get().recurrence.toString());
        } else {
            containsRecurrence = false;
            // Hides the recurrence label
            recurrenceLabel.setManaged(false);
        }
    }

    /**
     * The colour of the dates will become "more red" as the days pass. Also,
     * when the date is over, the colour will be red.
     */
    private void setDateTimesLabels() {
        if (toDo.getDateRange().isPresent()) {
            final DateRange dateRange = toDo.getDateRange().get();
            final long startDayDifference = ChronoUnit.DAYS.between(LocalDateTime.now(), dateRange.startDate);

            dateLabel.setText(DateTimePrettifier.prettifyDateTimeRange(dateRange.startDate, dateRange.endDate));
            dateLabel.setStyle("-fx-text-fill: " + CardStyleManager.getDateProximityBlue((int) startDayDifference));
            dateLabel.setMinHeight(labelHeight);
        } else {
            containsDates = false;
            // hides the date label
            dateLabel.setManaged(false);
        }
    }

    /**
     * Hides the pane containing tags and recurrence if both are not present
     */
    private void checkContainsTagsAndDates() {
        if (!containsTags && !containsRecurrence) {
            if (!containsDates) {
                dateTagsPane.setManaged(false);
            }
        }
    }

    /*
     * Different CSS styles for different states
     */
    protected HBox getLayoutState(boolean isNew, boolean isFinished) {
        this.isFinished = isFinished;
        if (isNew) {
            setRecentlyModifiedState();
        }
        if (isFinished) {
            setFinishedState();
        }
        return cardPane;
    }

    private void setRecentlyModifiedState() {
        CardStyleManager.addStyleAll("recently-modified", cardPane);
    }

    private void setFinishedState() {
        CardStyleManager.addStyleAll("finished", cardPane, dateTagsPane, indexLabel);
    }

    @FXML
    private void activateHoverState() {
        if (!isFinished) {
            CardStyleManager.addStyleAll("hover", cardPane, indexLabel);
        }
    }

    @FXML
    private void deactivateHoverState() {
        if (!isFinished) {
            CardStyleManager.removeStyleAll("hover", cardPane, indexLabel);
        }
    }
```
###### \java\seedu\commando\ui\EventListPanel.java
``` java
    protected ListView<UiToDo> getEventListView() {
        return eventListView;
    }

    private boolean isScrollBarPresent() {
        return scrollbar != null;
    }

    protected void scrollDown() {
        if (isScrollBarPresent()) {
            Platform.runLater(() -> scrollbar.setValue(Math.min(scrollbar.getValue() + 0.2, 1)));
        }
    }

    protected void scrollUp() {
        if (isScrollBarPresent()) {
            Platform.runLater(() -> scrollbar.setValue(Math.max(scrollbar.getValue() - 0.2, 0)));
        }
    }
```
###### \java\seedu\commando\ui\MainWindow.java
``` java
/**
 * The Main Window. Provides the basic application layout containing a menu bar
 * and space where other JavaFX elements can be placed.
 */
public class MainWindow extends UiPart {
    private static final Logger logger = LogsCenter.getLogger(MainWindow.class);

    // Fixed variables
    private final String FXML = "MainWindow.fxml";
    private final String maximizeButtonSymbol = "‚¨?";
    private final String unMaximizeButtonSymbol = "‚ù?";

    // Variables that changes while the app is active
    private double currScreenXPos = 0;
    private double currScreenYPos = 0;
    private static boolean isMaximized;

    private Logic logic;
    private String appName;

    // Independent Ui parts residing in this Ui container
    private EventListPanel eventPanel;
    private TaskListPanel taskPanel;
    private ResultDisplay resultDisplay;
    private StatusBarFooter statusBarFooter;
    private CommandBox commandBox;
    private UserPrefs userPrefs;
    private HelpWindow helpWindow;

    // Handles to elements of this Ui container
    private VBox rootLayout;
    private Scene scene;

    // The three panes that will take turns to be in focus
    // when the user presses 'Tab' repeatedly
    private TextField commandField;
    private ListView<UiToDo> eventListView;
    private ListView<UiToDo> taskListView;

    private enum FocusPanes {
        COMMANDFIELD, EVENTPANEL, TASKPANEL
    }

    private FocusPanes currentlyFocusedPane = FocusPanes.COMMANDFIELD;

    // Key combinations
    private KeyCombination altH = KeyCodeCombination.keyCombination("Alt+H");
    private KeyCombination altC = KeyCodeCombination.keyCombination("Alt+C");
    private KeyCombination altM = KeyCodeCombination.keyCombination("Alt+M");

    @FXML
    private HBox titleBar;
    @FXML
    private SplitPane splitPane;
    @FXML
    private AnchorPane browserPlaceholder;
    @FXML
    private AnchorPane commandBoxPlaceholder;
    @FXML
    private Menu exitMenu;
    @FXML
    private Menu helpMenu;
    @FXML
    private Menu creditMenu;
    @FXML
    private Menu appNameMenu;
    @FXML
    private Button toggleSizeButton;
    @FXML
    private Button minimizeButton;
    @FXML
    private Button exitButton;
    @FXML
    private AnchorPane eventListPanelPlaceholder;
    @FXML
    private AnchorPane taskListPanelPlaceholder;
    @FXML
    private AnchorPane resultDisplayPlaceholder;
    @FXML
    private AnchorPane statusbarPlaceholder;

    public MainWindow() {
        super();
    }

    @Override
    public void setNode(Node node) {
        rootLayout = (VBox) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    public static MainWindow load(Stage primaryStage, UserPrefs prefs, Logic logic) {
        try {
            // Try to remove title bar of window
            primaryStage.initStyle(StageStyle.UNDECORATED);
        } catch (IllegalStateException exception) {
            logger.info("Warning: " + exception.getMessage());
        }

        MainWindow mainWindow = UiPartLoader.loadUiPart(primaryStage, new MainWindow());
        mainWindow.configure(Config.ApplicationTitle, Config.ApplicationName, prefs, logic);
        return mainWindow;
    }

    private void configure(String appTitle, String appName, UserPrefs prefs, Logic logic) {
        // Set dependencies
        this.logic = logic;
        this.userPrefs = prefs;
        this.appName = appName;

        // Configure the UI
        setTitle(appTitle);

        // Icon and App size settings
        setIcon(Config.ApplicationIcon);
        setWindowDefaultSize(prefs);

        scene = new Scene(rootLayout);

        // Program is draggable through its titlebar
        setDraggable(titleBar);
        // Set keyboard shortcuts for certain functions
        setKeyboardShortcuts();
        // Programmatically focus certain panes through tab
        // Arrow keys to navigate a listview when either event or task pane is
        // focused
        setTabAndArrowKeysNavigations();

        primaryStage.setScene(scene);
        helpWindow = HelpWindow.load(primaryStage, Config.UserGuideUrl, Config.AboutUsUrl);
    }

    protected void fillInnerParts() {
        eventPanel = EventListPanel.load(primaryStage, getEventListPlaceholder(), logic.getUiEvents());
        taskPanel = TaskListPanel.load(primaryStage, getTaskListPlaceholder(), logic.getUiTasks());
        resultDisplay = ResultDisplay.load(primaryStage, getResultDisplayPlaceholder());
        statusBarFooter = StatusBarFooter.load(primaryStage, getStatusbarPlaceholder(),
                userPrefs.getToDoListFilePath());
        commandBox = CommandBox.load(primaryStage, getCommandBoxPlaceholder(), resultDisplay, logic);
    }

    protected void moreConfigurations() {
        extractMainNodes();

        // Set focus to commandField when the application starts
        setFocusTo(commandField);

        disableSplitPaneResize();
        setAppName(appName);
    }

    private void extractMainNodes() {
        commandField = commandBox.getCommandField();
        eventListView = eventPanel.getEventListView();
        taskListView = taskPanel.getTaskListView();
    }

    private void setFocusTo(Node node) {
        node.requestFocus();
    }

    private void disableSplitPaneResize() {
        splitPane.lookup(".split-pane-divider").setMouseTransparent(true);
    }

    private AnchorPane getCommandBoxPlaceholder() {
        return commandBoxPlaceholder;
    }

    private AnchorPane getStatusbarPlaceholder() {
        return statusbarPlaceholder;
    }

    private AnchorPane getResultDisplayPlaceholder() {
        return resultDisplayPlaceholder;
    }

    private AnchorPane getEventListPlaceholder() {
        return eventListPanelPlaceholder;
    }

    private AnchorPane getTaskListPlaceholder() {
        return taskListPanelPlaceholder;
    }

    protected void hide() {
        primaryStage.hide();
    }

    private void setAppName(String appName) {
        appNameMenu.setText(appName);
    }

    private void setTitle(String appTitle) {
        primaryStage.setTitle(appTitle);

    }

    /**
     * Sets the default size and coordinates based on user preferences. Also
     * includes whether the app is previously maximized
     */
    protected void setWindowDefaultSize(UserPrefs prefs) {
        primaryStage.setHeight(prefs.getGuiSettings().getWindowHeight());
        primaryStage.setWidth(prefs.getGuiSettings().getWindowWidth());

        if (prefs.getGuiSettings().getWindowCoordinates() != null) {
            primaryStage.setX(prefs.getGuiSettings().getWindowCoordinates().getX());
            primaryStage.setY(prefs.getGuiSettings().getWindowCoordinates().getY());
        }

        primaryStage.setMaximized(isMaximized = prefs.getGuiSettings().getIsMaximized());
        toggleSizeButtonSymbol();
    }

    /**
     * Returns the current position of the main Window.
     */
    protected GuiSettings getCurrentGuiSetting() {
        return new GuiSettings(primaryStage.getWidth(), primaryStage.getHeight(), (int) primaryStage.getX(),
                (int) primaryStage.getY(), isMaximized);
    }

    /**
     * Sets the 3 keyboard shortcuts that trigger their respective functions:
     * Alt + E = Exit the app Alt + H = Open help in window Alt + C = Open
     * credits in window
     */
    private void setKeyboardShortcuts() {
        scene.getAccelerators().put(altH, new Runnable() {
            @Override
            public void run() {
                handleHelp();
            }
        });
        scene.getAccelerators().put(altC, new Runnable() {
            @Override
            public void run() {
                handleCredits();
            }
        });
        scene.getAccelerators().put(altM, new Runnable() {
            @Override
            public void run() {
                toggleWindowSize();
            }
        });
    }

    /**
     * Pressing Tab will cycle between Event Panel, Task Panel and Command Box
     * Typing text will set focus automatically to the Command Box
     */
    private void setTabAndArrowKeysNavigations() {
        scene.addEventFilter(KeyEvent.KEY_PRESSED, new EventHandler<KeyEvent>() {
            @Override
            public void handle(KeyEvent key) {
                switch (key.getCode()) {
                case UP:
                    // If currently focused on Event Panel or Task Panel, scroll
                    // respectively
                    if (currentlyFocusedPane == FocusPanes.EVENTPANEL) {
                        eventPanel.scrollUp();
                    } else if (currentlyFocusedPane == FocusPanes.TASKPANEL) {
                        taskPanel.scrollUp();
                    } else {
                        commandBox.goUpCommandHistory();
                    }
                    break;
                case DOWN:
                    if (currentlyFocusedPane == FocusPanes.EVENTPANEL) {
                        eventPanel.scrollDown();
                    } else if (currentlyFocusedPane == FocusPanes.TASKPANEL) {
                        taskPanel.scrollDown();
                    } else {
                        commandBox.goDownCommandHistory();
                    }
                    break;
                case TAB:
                    // If tab is pressed, cycle through Event Panel, Task Panel
                    // and Command Box
                    cycleThroughFocusPanes();
                    key.consume();
                    break;
                case CONTROL:
                case ALT:
                case SHIFT:
                    // Nome of these keys should trigger the focus of
                    // commandfield
                    // because sometimes you need to copy and paste or do other
                    // stuff
                    key.consume();
                    break;
                default:
                    consumeKeyIfLeftOrRightAndFocusOnPanel(key);

                    // Else, any other sutiable character is considered input to
                    // command box
                    // and it will be in focus
                    currentlyFocusedPane = FocusPanes.COMMANDFIELD;
                    commandField.requestFocus();
                }
            }
        });
    }

    private void consumeKeyIfLeftOrRightAndFocusOnPanel(KeyEvent key) {
        if ((key.getCode() == KeyCode.LEFT || key.getCode() == KeyCode.RIGHT)
                && currentlyFocusedPane != FocusPanes.COMMANDFIELD) {
            key.consume();
        }
    }

    /**
     * Refer to setTabAndArrowKeysNavigations()
     */
    private void cycleThroughFocusPanes() {
        switch (currentlyFocusedPane) {
        case COMMANDFIELD:
            currentlyFocusedPane = FocusPanes.EVENTPANEL;
            setFocusTo(eventListView);
            break;
        case EVENTPANEL:
            currentlyFocusedPane = FocusPanes.TASKPANEL;
            setFocusTo(taskListView);
            break;
        case TASKPANEL:
            currentlyFocusedPane = FocusPanes.COMMANDFIELD;
            setFocusTo(commandField);
            break;
        }
    }

    /**
     * Sets the title bar to be draggable
     */
    private void setDraggable(Node node) {
        node.addEventFilter(MouseEvent.MOUSE_PRESSED, new EventHandler<MouseEvent>() {
            @Override
            public void handle(MouseEvent mouseEvent) {
                currScreenXPos = mouseEvent.getSceneX();
                currScreenYPos = mouseEvent.getSceneY();
            }
        });
        node.addEventFilter(MouseEvent.MOUSE_DRAGGED, new EventHandler<MouseEvent>() {
            @Override
            public void handle(MouseEvent mouseEvent) {
                primaryStage.setX(mouseEvent.getScreenX() - currScreenXPos);
                primaryStage.setY(mouseEvent.getScreenY() - currScreenYPos);
            }
        });
    }

    /**
     * Toggles the app between two sizes. One being the default size, and the
     * full screen size
     */
    @FXML
    protected void toggleWindowSize() {
        if (isMaximized) {
            primaryStage.setMaximized(false);

            primaryStage.setWidth(Config.DefaultWindowWidth);
            primaryStage.setHeight(Config.DefaultWindowHeight);

        } else {
            primaryStage.setMaximized(true);
        }
        isMaximized = !isMaximized;
        toggleSizeButtonSymbol();
    }

    /**
     * Toggles the minimize / maximize button between two symbols.
     */
    private void toggleSizeButtonSymbol() {
        if (isMaximized) {
            toggleSizeButton.setText(unMaximizeButtonSymbol);
        } else {
            toggleSizeButton.setText(maximizeButtonSymbol);
        }
    }

    /**
     * Opens the About Us page
     */
    @FXML
    private void handleCredits() {
        helpWindow.visitAboutUs();
    }

    /**
     * Minimizes the window
     */
    @FXML
    private void setMinimized() {
        primaryStage.setIconified(true);
    }

    @FXML
    private void handleHelp() {
        showHelpAtAnchor("");
    }

    protected void showHelpAtAnchor(String anchor) {
        helpWindow.getHelp(anchor);
    }

    protected void show() {
        primaryStage.show();
        initEventsCenter();
    }

    private void initEventsCenter() {
        EventsCenter.getInstance().registerHandler(this);
    }

    /**
     * Closes the application.
     */
    @FXML
    private void handleExit() {
        raise(new ExitAppRequestEvent());
    }

    @Subscribe
    public void handleToDoListSavedEvent(ToDoListSavedEvent event) {
        logger.info(
                LogsCenter.getEventHandlingLogMessage(event, "Setting last updated status to " + LocalDateTime.now()));
        statusBarFooter.setSyncStatus(LocalDateTime.now());
    }
}
```
###### \java\seedu\commando\ui\ResultDisplay.java
``` java
        SimpleIntegerProperty initHeight = new SimpleIntegerProperty(RESULT_MINIMUM_HEIGHT);
        resultDisplayArea.prefHeightProperty().bindBidirectional(initHeight);
        resultDisplayArea.minHeightProperty().bindBidirectional(initHeight);

        // Changes the height of the resultDisplayArea according to the number
        // of newlines present
        resultDisplayArea.textProperty().addListener(new ChangeListener<String>() {
            @Override
            public void changed(final ObservableValue<? extends String> observable, final String oldValue,
                    final String newValue) {
                final int count = StringUtils.countMatches(newValue, "\n");
                initHeight.setValue(RESULT_MINIMUM_HEIGHT + count * RESULT_INCREMENT_HEIGHT);
            }
        });
```
###### \java\seedu\commando\ui\TaskCard.java
``` java
    /**
     * Creates a variable number of labels and put them in the FlowPane tagsPane
     */
    private void createTagLabels() {
        if (!toDo.getTags().isEmpty()) {
            for (Tag tag : toDo.getTags()) {
                Label label = new Label();
                label.setText("#" + tag.value);
                label.setId("tagsLabel");
                label.setMaxWidth(200);
                label.getStyleClass().add("cell_big_label");
                label.setAlignment(Pos.CENTER);
                label.setPadding(new Insets(0, 3, 0, 3));

                tagsPane.getChildren().add(label);
            }
        } else {
            containsTags = false;
        }
    }

    private void setRecurrenceLabel() {
        if (toDo.getDueDate().isPresent() && toDo.getDueDate().get().recurrence != Recurrence.None) {
            recurrenceLabel.setText(toDo.getDueDate().get().recurrence.toString());
        } else {
            containsRecurrence = false;
            // Hides the recurrence label
            recurrenceLabel.setManaged(false);
        }
    }

    /**
     * Sets value for the date time label and colours it according to the
     * proximity of the date to today with red being the closest, and green
     * being the furthest
     */
    private void setDateTimeLabel() {
        if (toDo.getDueDate().isPresent()) {
            final LocalDateTime due = toDo.getDueDate().get().value;
            final long dayDifference = ChronoUnit.DAYS.between(LocalDateTime.now(), due);

            dateLabel.setText("by " + DateTimePrettifier.prettifyDateTime(due));
            dateLabel.setStyle("-fx-text-fill: " + CardStyleManager.getDateProximityGreen((int) dayDifference));
        } else {
            containsDates = false;
            // hides the date label
            dateLabel.setManaged(false);
        }
    }

    /**
     * Hides the pane containing tags and recurrence if both are not present
     */
    private void checkContainsTagsAndDates() {
        if (!containsTags && !containsRecurrence) {
            tagsPane.setManaged(false);
            if (!containsDates) {
                dateTagsPane.setManaged(false);
            }
        }
    }

    /*
     * Different CSS styles for different states
     */
    protected HBox getLayoutState(boolean isNew, boolean isFinished) {
        this.isFinished = isFinished;
        if (isNew) {
            setRecentlyModifiedState();
        }
        if (isFinished) {
            setFinishedState();
        }
        return cardPane;
    }

    private void setRecentlyModifiedState() {
        CardStyleManager.addStyleAll("recently-modified", cardPane);
    }

    private void setFinishedState() {
        CardStyleManager.addStyleAll("finished", cardPane, dateTagsPane, indexLabel);
    }

    @FXML
    private void activateHoverState() {
        if (!isFinished) {
            CardStyleManager.addStyleAll("hover", cardPane, indexLabel);
        }
    }

    @FXML
    private void deactivateHoverState() {
        if (!isFinished) {
            CardStyleManager.removeStyleAll("hover", cardPane, indexLabel);
        }
    }
```
###### \java\seedu\commando\ui\TaskListPanel.java
``` java
    protected ListView<UiToDo> getTaskListView() {
        return taskListView;
    }

    private boolean isScrollBarPresent() {
        return scrollbar != null;
    }

    protected void scrollDown() {
        if (isScrollBarPresent()) {
            Platform.runLater(() -> scrollbar.setValue(Math.min(scrollbar.getValue() + 0.2, 1)));
        }
    }

    protected void scrollUp() {
        if (isScrollBarPresent()) {
            Platform.runLater(() -> scrollbar.setValue(Math.max(scrollbar.getValue() - 0.2, 0)));
        }
    }
```
###### \java\seedu\commando\ui\ToDoListViewCell.java
``` java
class ToDoListViewCell extends ListCell<UiToDo> {

    protected enum Card {
        Event, Task
    }

    private Card chosenCard;

    public ToDoListViewCell(ListView<UiToDo> list, Card card) {
        assert card != null;
        chosenCard = card;

        // Sets the maximum width of EventCard or TaskCard to be always equals
        // to the ListView containing it.
        prefWidthProperty().bind(list.widthProperty().subtract(10));
    }

    @Override
    protected void updateItem(UiToDo toDo, boolean empty) {
        super.updateItem(toDo, empty);
        if (empty || toDo == null) {
            setGraphic(null);
            setText(null);
        } else {
            HBox layout;
            if (chosenCard == Card.Event) {
                layout = EventCard.load(toDo, toDo.getIndex()).getLayoutState(toDo.isNew(), toDo.isFinished());
            } else {
                layout = TaskCard.load(toDo, toDo.getIndex()).getLayoutState(toDo.isNew(), toDo.isFinished());
            }
            setGraphic(layout);
        }
    }
}
```
###### \resources\userguide\stylesheets\custom.css
``` css

body {
    margin: 0;
}

a {
    color: #d5000d;
}

    a:hover {
        color: #c5000c;
    }

blockquote {
    padding: 10px;
    color: #444444;
    background-color: rgba(190, 190, 190, 0.2);
    overflow: auto;
    text-shadow: none;
    border-radius: 0 12px 12px 0;
    border-left: 5px solid #CC4444;
    margin-left: 20px;
    padding-left: 20px;
}

    blockquote > b {
        font-weight: bold;
        padding-right: 10px;
    }


code, pre {
    padding-left: 3px;
    padding-right: 3px;
    font-family: Consolas;
    color: #303030;
}

pre {
    color: #DCDCCC;
    text-shadow: none;
    background: #4F4F4F;
    border: solid 2px #928097;
    border-radius: 6px;
    white-space: normal;
    font-size: 0.9em;
}

    pre span {
        color: #c3e069;
    }

        pre span.inputstart {
            color: #99dfcd;
        }

    pre i {
        padding-left: 0.4em;
        padding-right: 0.4em;
        color: #CEDF99;
    }

    pre em {
        color: #FFFFFF;
    }

code {
    background: #eeeeee; /* Old browsers */
    background: -moz-linear-gradient(top, #eeeeee 0%, #ffffff 100%); /* FF3.6-15 */
    background: -webkit-linear-gradient(top, #eeeeee 0%,#ffffff 100%); /* Chrome10-25,Safari5.1-6 */
    background: linear-gradient(to bottom, #eeeeee 0%,#ffffff 100%); /* W3C, IE10+, FF16+, Chrome26+, Opera12+, Safari7+ */
    filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#eeeeee', endColorstr='#ffffff',GradientType=0 ); /* IE6-9 */
    border-radius: 6px;
    color: #303030;
}

a code {
    color: #d5000d;
}

h3 code {
    font-size: inherit;
}

table.black tbody {
    background: #303030;
    color: #FFFFFF;
}

    table.black tbody td {
        border-bottom: 0;
    }

table pre {
    white-space: normal;
    border-radius: 0;
    border: solid 3px #303030;
    margin: -3px 0;
}

ul#first-layer,
ul#search-logic {
    list-style: none;
    margin-left: -25px;
}

    ul#first-layer li {
        margin-bottom: 0;
    }

        ul#first-layer li:before,
        ul#search-logic li:before {
            /*
    The desired width gets defined in two places: The element width, and background size.
    The height only gets defined once, in background size.
    */
            display: inline-block;
            content: '\2022'; /* bullet point, for screen readers */
            text-indent: -999999px; /* move the bullet point out of sight */
            width: 20px; /* desired width of the image */
            background-repeat: no-repeat;
            background-image: url('../images/Magnifying_glass_icon.svg.png');
            background-size: 20px 20px;
            background-position: 0 .2em;
            padding-right: 5px;
        }


    ul#first-layer ul#second-layer {
        list-style: none;
    }

        ul#first-layer ul#second-layer li:before {
            margin-left: 0;
            background-size: 12px 12px;
            background-position: 0.3em .3em;
        }

h2 {
    -webkit-margin-before: 0px;
}

img {
    border-color: transparent;
    border: #000000 2px solid;
    border-radius: 10px;
}

figure {
    text-align: center;
}

figcaption {
    font-size: 14px;
    margin-bottom: 30px;
}

figure img {
    margin-top: 20px;
}


```
###### \resources\view\Card.fxml
``` fxml

<?import javafx.geometry.Insets?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.layout.FlowPane?>
<?import javafx.scene.layout.HBox?>
<?import javafx.scene.layout.VBox?>

<HBox fx:id="cardPane" maxHeight="1.7976931348623157E308" minHeight="-Infinity" onMouseEntered="#activateHoverState" onMouseExited="#deactivateHoverState" styleClass="card-pane" stylesheets="@DarkTheme.css" xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1">
   <children>
      <HBox alignment="CENTER_LEFT" maxHeight="1.7976931348623157E308" minHeight="-Infinity" spacing="5" HBox.hgrow="ALWAYS">
         <children>
            <HBox maxHeight="1.7976931348623157E308" minHeight="-Infinity" HBox.hgrow="ALWAYS">
               <children>
                  <Label fx:id="indexLabel" alignment="CENTER" maxHeight="1.7976931348623157E308" maxWidth="1.7976931348623157E308" minWidth="40.0" prefHeight="40.0" text="\$i" textOverrun="CLIP">
                     <padding>
                        <Insets bottom="3.0" left="3.0" right="3.0" top="3.0" />
                     </padding>
                  </Label>
                  <Label fx:id="titleLabel" maxHeight="1.7976931348623157E308" prefHeight="30" text="\$value" wrapText="true">
                     <padding>
                        <Insets left="15.0" right="7.0" />
                     </padding>
                     <HBox.margin>
                        <Insets />
                     </HBox.margin>
                  </Label>
               </children>
            </HBox>
         </children>
         <HBox.margin>
            <Insets right="3.0" />
         </HBox.margin>
      </HBox>
      <VBox fx:id="dateTagsPane" alignment="TOP_RIGHT" maxHeight="1.7976931348623157E308" VBox.vgrow="ALWAYS" minWidth="180">
         <children>
            <Label fx:id="dateLabel" alignment="CENTER_RIGHT" text="\$date">
               <padding>
                  <Insets right="5.0" />
               </padding>
               <VBox.margin>
                  <Insets bottom="3.0" />
               </VBox.margin>
            </Label>
            <FlowPane fx:id="tagsPane" alignment="TOP_RIGHT" columnHalignment="RIGHT" hgap="6.0" maxHeight="-Infinity" maxWidth="-Infinity" minHeight="-Infinity" minWidth="-Infinity" prefWrapLength="200.0" vgap="3.0">
               <children>
                  <Label fx:id="recurrenceLabel" alignment="CENTER" maxHeight="-Infinity" minWidth="-Infinity" text="\$recurr" wrapText="true">
                     <padding>
                        <Insets left="3.0" right="3.0" />
                     </padding>
                  </Label>
               </children>
               <opaqueInsets>
                  <Insets />
               </opaqueInsets>
               <VBox.margin>
                  <Insets bottom="3.0" right="5.0" />
               </VBox.margin>
            </FlowPane>
         </children>
         <HBox.margin>
            <Insets bottom="3.0" left="3.0" right="3.0" top="3.0" />
         </HBox.margin>
      </VBox>
      <HBox maxWidth="-Infinity" minWidth="-Infinity" prefWidth="5.0" />
   </children>
   <padding>
      <Insets bottom="3.0" left="3.0" right="3.0" top="3.0" />
   </padding>
</HBox>
```
###### \resources\view\EventListPanel.fxml
``` fxml

<?import java.net.URL?>
<?import javafx.scene.control.ListView?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.layout.VBox?>

<VBox AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0" xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1" fx:controller="seedu.commando.ui.EventListPanel">
    <stylesheets>
        <URL value="@DarkTheme.css" />
    </stylesheets>
    <children>
        <ListView fx:id="eventListView" VBox.vgrow="ALWAYS" />
    </children>
</VBox>

```
###### \resources\view\MainWindow.fxml
``` fxml

<?import java.net.URL?>
<?import javafx.geometry.Insets?>
<?import javafx.scene.control.Button?>
<?import javafx.scene.control.Menu?>
<?import javafx.scene.control.MenuBar?>
<?import javafx.scene.control.SplitPane?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.layout.FlowPane?>
<?import javafx.scene.layout.HBox?>
<?import javafx.scene.layout.VBox?>
<?import javafx.scene.text.Text?>

<VBox maxHeight="Infinity" maxWidth="Infinity" minHeight="-Infinity" minWidth="-Infinity" xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1" fx:controller="seedu.commando.ui.MainWindow">
	<stylesheets>
		<URL value="@DarkTheme.css" />
	</stylesheets>
	<children>
		<HBox fx:id="titleBar" styleClass="title-bar">
			<children>
				<FlowPane HBox.hgrow="ALWAYS">
					<children>
						<MenuBar styleClass="title-button">
							<menus>
								<Menu disable="true" mnemonicParsing="false" text="Help (Alt + H)" />
								<Menu disable="true" mnemonicParsing="false" text="Credits (Alt + C)" />
							</menus>
						</MenuBar>
      				<MenuBar opacity="0.5" styleClass="title-button">
      					<menus>
      						<Menu fx:id="appNameMenu" disable="true" mnemonicParsing="false" text="\$appNameMenu" />
      					</menus>
      				</MenuBar>
					</children>
				</FlowPane>
            <Button fx:id="minimizeButton" mnemonicParsing="false" onMouseClicked="#setMinimized" prefHeight="40.0" prefWidth="40.0" styleClass="size-button" text="Ôº?" textOverrun="CLIP" />
            <Button fx:id="toggleSizeButton" mnemonicParsing="false" onMouseClicked="#toggleWindowSize" prefHeight="40.0" prefWidth="40.0" styleClass="size-button" text="‚¨?" textOverrun="CLIP" />
            <Button fx:id="exitButton" mnemonicParsing="false" onMouseClicked="#handleExit" prefHeight="40.0" prefWidth="40.0" style="-fx-border-color: transparent;" styleClass="size-button" text="‚ú?" textOverrun="CLIP" />
			</children>
		</HBox>
		<SplitPane id="splitPane" fx:id="splitPane" dividerPositions="0.4" VBox.vgrow="ALWAYS">
			<items>
				<VBox fx:id="eventList" minWidth="340" prefHeight="800" prefWidth="340">
					<padding>
						<Insets bottom="10.0" left="10.0" right="10.0" />
					</padding>
					<children>
                  <VBox alignment="CENTER" prefWidth="320.0" styleClass="event-pane-title-background">
                     <children>
                        <Text fill="WHITE" strokeType="OUTSIDE" strokeWidth="0.0" styleClass="event-pane-title" text="Events" />
                     </children>
                     <padding>
                        <Insets bottom="5.0" />
                     </padding>
                  </VBox>
						<AnchorPane fx:id="eventListPanelPlaceholder" VBox.vgrow="ALWAYS" />
					</children>
				</VBox>
				<VBox fx:id="taskList" minWidth="340" prefHeight="800" prefWidth="340">
					<padding>
						<Insets bottom="10.0" left="10.0" right="10.0" />
					</padding>
					<children>
                  <VBox alignment="CENTER" styleClass="event-pane-title-background">
                     <children>
                        <Text fill="WHITE" strokeType="OUTSIDE" strokeWidth="0.0" styleClass="task-pane-title" text="Tasks" />
                     </children>
                     <padding>
                        <Insets bottom="5.0" />
                     </padding>
                  </VBox>
						<AnchorPane fx:id="taskListPanelPlaceholder" VBox.vgrow="ALWAYS" />
					</children>
				</VBox>
			</items>
		</SplitPane>
		<AnchorPane fx:id="resultDisplayPlaceholder" styleClass="anchor-pane-with-border" VBox.vgrow="NEVER">
			<padding>
				<Insets bottom="5.0" left="10.0" right="10.0" top="5.0" />
			</padding>
		</AnchorPane>
		<AnchorPane fx:id="commandBoxPlaceholder" styleClass="anchor-pane-with-border" VBox.vgrow="NEVER">
			<padding>
				<Insets bottom="5.0" left="10.0" right="10.0" top="5.0" />
			</padding>
		</AnchorPane>
		<AnchorPane fx:id="statusbarPlaceholder" VBox.vgrow="NEVER" />
	</children>
</VBox>
```
###### \resources\view\TaskListPanel.fxml
``` fxml

<?import java.net.URL?>
<?import javafx.scene.control.ListView?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.layout.VBox?>

<VBox AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0" xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1" fx:controller="seedu.commando.ui.TaskListPanel">
	<stylesheets>
		<URL value="@DarkTheme.css" />
	</stylesheets>
	<children>
		<ListView fx:id="taskListView" VBox.vgrow="ALWAYS" />
	</children>
</VBox>
```
