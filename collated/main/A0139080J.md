# A0139080J
###### \java\seedu\commando\commons\core\Messages.java
``` java
    public static final String STORE_COMMAND_FORMAT = ">> store ../../Dropbox/work/todolist.xml.";
    public static final String IMPORT_COMMAND_FORMAT = ">> import ../../Dropbox/work/todolist.xml.";
    public static final String EXPORT_COMMAND_FORMAT = ">> export ../../Dropbox/work/todolist.xml.";
    public static final String ADD_COMMAND_FORMAT = ">> add <task description> #tag1 #tag2...\n" + 
                                                    ">> add <task description> by <deadline>\n" + 
                                                    ">> add <event description> from <start time> to <end time>";
    public static final String DELETE_COMMAND_FORMAT = ">> delete <index>";
    public static final String FIND_COMMAND_FORMAT = ">> find\n" + ">> find <keyword(s)> #tag1 #tag2...";
    public static final String RECALL_COMMAND_FORMAT = ">> recall\n" + ">> recall <keyword(s)> #tag1 #tag2...";
    public static final String EDIT_COMMAND_FORMAT = ">> edit <index> <change in description>\n" + 
                                                     ">> edit <index> `<change in description`\n" + 
                                                     "(If you want to start your description by keywords such as `by`, `from` and `to`";
    public static final String FINISH_COMMAND_FORMAT = ">> finish <index>";
    public static final String UNFINISH_COMMAND_FORMAT = ">> unfinish <index>";
    
    public static final String DATE_FORMAT = "Date Time Formats: 9 jan 2018 23:59 | Jan 9 2019 1900h | coming friday morning | today 23:59";

    /**
     * Returns an additional invalid command format message to be appended
     * for a {@param commandWord}.
     */
    public static Optional<String> getInvalidCommandFormatMessage(String commandWord) {
        switch (commandWord) {
            case StoreCommand.COMMAND_WORD:
                return Optional.of(STORE_COMMAND_FORMAT);
            case ImportCommand.COMMAND_WORD:
                return Optional.of(IMPORT_COMMAND_FORMAT);
            case ExportCommand.COMMAND_WORD:
                return Optional.of(EXPORT_COMMAND_FORMAT);
            case AddCommand.COMMAND_WORD:
                return Optional.of(ADD_COMMAND_FORMAT);
            case DeleteCommand.COMMAND_WORD:
                return Optional.of(DELETE_COMMAND_FORMAT);
            case EditCommand.COMMAND_WORD:
                return Optional.of(EDIT_COMMAND_FORMAT);
            case FinishCommand.COMMAND_WORD:
                return Optional.of(FINISH_COMMAND_FORMAT);
            case UnfinishCommand.COMMAND_WORD:
                return Optional.of(UNFINISH_COMMAND_FORMAT);
            default: break; 
        }
        return Optional.empty();
    }
```
###### \java\seedu\commando\ui\EventCard.java
``` java
    private void setRecurrenceLabel() {
        if (toDo.getDateRange().isPresent() && toDo.getDateRange().get().recurrence != Recurrence.None) {
            recurrenceLabel.setText(toDo.getDateRange().get().recurrence.toString());
        } else {
            recurrenceLabel.setManaged(false);
        }
    }
    
    private void setDateTimesLabels() {
        if (toDo.getDateRange().isPresent()) {
            final DateRange dateRange = toDo.getDateRange().get();
            final long startDayDifference = ChronoUnit.DAYS.between(LocalDateTime.now(), dateRange.startDate);
            
            dateIntervalLabel.setText(
                    ToDoCardStyleManager.prettifyDateTimeRange(dateRange.startDate, dateRange.endDate));
            dateIntervalLabel.setStyle("-fx-text-fill: " + 
                    ToDoCardStyleManager.getDateProximityBlue((int) startDayDifference));
        } else {
            dateIntervalLabel.setText("");
            endLabel.setText("");
        }
    }
    
    
    /*
     * Different CSS styles for different states
     */
    protected HBox getLayoutState(boolean isNew, boolean isFinished) {
        this.isFinished = isFinished;
        if (isNew) {
            setRecentlyModifiedState();
        }
        if (isFinished) {
            setFinishedState();
        }
        return eventPane;
    }

    /**
     * Every recently modified event will have a red border
     * This includes modification via undo, edit, add
     */
    private void setRecentlyModifiedState() {
        eventPaneInner.setStyle(ToDoCardStyleManager.recentlyModifiedStateCSS);
    }
    
    /**
     * Tints a finished event gray
     */
    private void setFinishedState() {
        eventPaneInner.setStyle(ToDoCardStyleManager.finishedStateContentCSS);
        indexLabel.setStyle(ToDoCardStyleManager.finishedStateIndexCSS);
    }

    /**
     * Tints a hovered event a slight gray
     */
    @FXML
    private void activateHoverState() {
        if (!isFinished) {
            eventPaneInner.setStyle(ToDoCardStyleManager.activateHoverStateContentCSS);
            indexLabel.setStyle(ToDoCardStyleManager.activateHoverStateIndexCSS);
        }
    }
    
    @FXML
    private void deactivateHoverState() {
        if (!isFinished) {
            eventPaneInner.setStyle(ToDoCardStyleManager.deactivateHoverStateContentCSS);
            indexLabel.setStyle(ToDoCardStyleManager.deactivateHoverStateIndexCSS);
        }
    }
```
###### \java\seedu\commando\ui\EventListPanel.java
``` java
    protected ListView<UiToDo> getEventListView() {
        return eventListView;
    }
    
    private boolean isScrollBarPresent() {
        return scrollbar != null;
    }
    
    protected void scrollDown() {
        if (isScrollBarPresent()) {
            scrollbar.setValue(Math.min(scrollbar.getValue() + 0.1, 1));
        }
    }
    
    protected void scrollUp() {
        if (isScrollBarPresent()) {
            scrollbar.setValue(Math.max(scrollbar.getValue() - 0.1, 0));
        }
    }
```
###### \java\seedu\commando\ui\MainWindow.java
``` java
/**
 * The Main Window. Provides the basic application layout containing
 * a menu bar and space where other JavaFX elements can be placed.
 */
public class MainWindow extends UiPart {
    private static final Logger logger = LogsCenter.getLogger(MainWindow.class);
    
    // Fixed variables
    private final String FXML = "MainWindow.fxml";
    private final String maximizeButtonSymbol = "‚¨?";
    private final String unMaximizeButtonSymbol = "‚ù?";
    
    // Variables that changes while the app is active
    private double currScreenXPos = 0;
    private double currScreenYPos = 0;
    private static boolean isMaximized;
    
    private Logic logic;

    // Independent Ui parts residing in this Ui container
    private EventListPanel eventPanel;
    private TaskListPanel taskPanel;
    private ResultDisplay resultDisplay;
    private StatusBarFooter statusBarFooter;
    private CommandBox commandBox;
    private UserPrefs userPrefs;
    private HelpWindow helpWindow;
    
    // Handles to elements of this Ui container
    private VBox rootLayout;
    private Scene scene;

    private String appName;
    
    // The three panes that will take turns to be in focus 
    // when the user presses 'Tab' repeatedly
    private TextField commandField;
    private ListView<UiToDo> eventListView;
    private ListView<UiToDo> taskListView;
    private enum FocusPanes {
        COMMANDFIELD, EVENTPANEL, TASKPANEL
    }
    FocusPanes currentlyFocusedPane = FocusPanes.COMMANDFIELD;
    
    // Key combinations
    KeyCombination altH = KeyCodeCombination.keyCombination("Alt+H");
    KeyCombination altC = KeyCodeCombination.keyCombination("Alt+C");
    KeyCombination altM = KeyCodeCombination.keyCombination("Alt+M");
    
    @FXML
    private HBox titleBar;
    @FXML
    private SplitPane splitPane;
    @FXML
    private AnchorPane browserPlaceholder;
    @FXML
    private AnchorPane commandBoxPlaceholder;
    @FXML
    private Menu exitMenu;
    @FXML
    private Menu helpMenu;
    @FXML
    private Menu creditMenu;
    @FXML
    private Button toggleSizeButton;
    @FXML
    private Button minimizeButton;
    @FXML
    private Button exitButton;
    @FXML
    private AnchorPane eventListPanelPlaceholder;
    @FXML
    private AnchorPane taskListPanelPlaceholder;
    @FXML
    private AnchorPane resultDisplayPlaceholder;
    @FXML
    private AnchorPane statusbarPlaceholder;

    public MainWindow() {
        super();
    }

    @Override
    public void setNode(Node node) {
        rootLayout = (VBox) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    public static MainWindow load(Stage primaryStage, UserPrefs prefs, Logic logic) {
        // Try to remove title bar of window
        try {
            primaryStage.initStyle(StageStyle.UNDECORATED);
        } catch (IllegalStateException exception) {
            // Ignore, window has been made visible already
        }

        MainWindow mainWindow = UiPartLoader.loadUiPart(primaryStage, new MainWindow());
        mainWindow.configure(Config.ApplicationTitle, Config.ApplicationName, prefs, logic);
        return mainWindow;
    }

    private void configure(String appTitle, String appName, UserPrefs prefs, Logic logic) {
        // Set dependencies
        this.logic = logic;
        this.appName = appName;
        this.userPrefs = prefs;

        // Configure the UI
        setTitle(appTitle);
        
        // Icon and App size settings
        setIcon(Config.ApplicationIcon);
        setWindowDefaultSize(prefs);
        
        scene = new Scene(rootLayout);
        
        // Program is draggable through its titlebar
        setDraggable(titleBar);
        // Set keyboard shortcuts for certain functions
        setKeyboardShortcuts();
        // Programmatically focus certain panes through tab
        // Arrow keys to navigate a listview when either event or task pane is focused
        setTabAndArrowKeysNavigations();
        
        primaryStage.setScene(scene);
        helpWindow = HelpWindow.load(primaryStage, Config.UserGuideUrl);
    }

    void fillInnerParts() {
        eventPanel = EventListPanel.load(primaryStage, getEventListPlaceholder(), logic.getUiEvents());
        taskPanel = TaskListPanel.load(primaryStage, getTaskListPlaceholder(), logic.getUiTasks());
        resultDisplay = ResultDisplay.load(primaryStage, getResultDisplayPlaceholder());
        statusBarFooter = StatusBarFooter.load(primaryStage, getStatusbarPlaceholder(), userPrefs.getToDoListFilePath());
        commandBox = CommandBox.load(primaryStage, getCommandBoxPlaceholder(), resultDisplay, logic);
    }
    
    protected void moreConfigurations() {
        commandField = commandBox.getCommandField();
        eventListView = eventPanel.getEventListView();
        taskListView = taskPanel.getTaskListView();
        setFocusTo(commandField);
        disableSplitPaneResize();
    }
    
    private void setFocusTo(Node node) {
        node.requestFocus();
    }
    
    private void disableSplitPaneResize() {
        splitPane.lookup(".split-pane-divider").setMouseTransparent(true);
    }
    
    private AnchorPane getCommandBoxPlaceholder() {
        return commandBoxPlaceholder;
    }

    private AnchorPane getStatusbarPlaceholder() {
        return statusbarPlaceholder;
    }

    private AnchorPane getResultDisplayPlaceholder() {
        return resultDisplayPlaceholder;
    }

    private AnchorPane getEventListPlaceholder() {
        return eventListPanelPlaceholder;
    }

    private AnchorPane getTaskListPlaceholder() {
        return taskListPanelPlaceholder;
    }

    protected void hide() {
        primaryStage.hide();
    }

    private void setTitle(String appTitle) {
        primaryStage.setTitle(appTitle);
    }

    /**
     * Sets the default size and coordinates based on user preferences.
     * Also includes whether the app is previously maximized
     */
    protected void setWindowDefaultSize(UserPrefs prefs) {
        primaryStage.setHeight(prefs.getGuiSettings().getWindowHeight());
        primaryStage.setWidth(prefs.getGuiSettings().getWindowWidth());

        if (prefs.getGuiSettings().getWindowCoordinates() != null) {
            primaryStage.setX(prefs.getGuiSettings().getWindowCoordinates().getX());
            primaryStage.setY(prefs.getGuiSettings().getWindowCoordinates().getY());
        }

        primaryStage.setMaximized(isMaximized = prefs.getGuiSettings().getIsMaximized());
        toggleSizeButtonSymbol();
    }

    /**
     * Returns the current position of the main Window.
     */
    protected GuiSettings getCurrentGuiSetting() {
        return new GuiSettings(primaryStage.getWidth(), primaryStage.getHeight(), 
                (int) primaryStage.getX(), (int) primaryStage.getY(), isMaximized);
    }

    /**
     * Sets the 3 keyboard shortcuts that trigger their respective functions:
     * Alt + E = Exit the app
     * Alt + H = Open help in window
     * Alt + C = Open credits in window
     */
    private void setKeyboardShortcuts() {
        scene.getAccelerators().put(altH, new Runnable() {
            @Override
            public void run() {
                handleHelp();
            }
        });
        scene.getAccelerators().put(altC, new Runnable() {
            @Override
            public void run() {
                handleCredits();
            }
        });
        scene.getAccelerators().put(altM, new Runnable() {
            @Override
            public void run() {
                toggleWindowSize();
            }
        });
    }
    
    /**
     * Pressing Tab will cycle between Event Panel, Task Panel and Command Box
     * Typing text will set focus automatically to the Command Box
     */
    private void setTabAndArrowKeysNavigations() {
        scene.addEventFilter(KeyEvent.KEY_PRESSED, new EventHandler<KeyEvent>() {
            @Override
            public void handle(KeyEvent key) {
                switch (key.getCode()) {
                case UP:
                    // If currently focused on Event Panel or Task Panel, scroll respectively
                    if (currentlyFocusedPane == FocusPanes.EVENTPANEL) {
                        eventPanel.scrollUp();
                    } else if (currentlyFocusedPane == FocusPanes.TASKPANEL) {
                        taskPanel.scrollUp();
                    }
                    break;
                case DOWN:
                    if (currentlyFocusedPane == FocusPanes.EVENTPANEL) {
                        eventPanel.scrollDown();
                    } else if (currentlyFocusedPane == FocusPanes.TASKPANEL) {
                        taskPanel.scrollDown();
                    }
                    break;
                case TAB:
                    // If tab is pressed, cycle through Event Panel, Task Panel and Command Box
                    cycleThroughFocusPanes();
                    key.consume();
                    break;
                case CONTROL:
                case ALT:
                case SHIFT:
                    // Nome of these keys should trigger the focus of commandfield
                    // because sometimes you need to copy and paste or do other stuff
                    key.consume();
                    break;
                default:
                    // Else, any other sutiable character is considered input to command box
                    // and it will be in focus
                    currentlyFocusedPane = FocusPanes.COMMANDFIELD;
                    commandField.requestFocus();
                }
            }
        });
    }

    private void cycleThroughFocusPanes() {
        switch (currentlyFocusedPane) {
        case COMMANDFIELD:
            currentlyFocusedPane = FocusPanes.EVENTPANEL;
            setFocusTo(eventListView);
            break;
        case EVENTPANEL:
            currentlyFocusedPane = FocusPanes.TASKPANEL;
            setFocusTo(taskListView);
            break;
        case TASKPANEL:
            currentlyFocusedPane = FocusPanes.COMMANDFIELD;
            setFocusTo(commandField);
            break;
        }
    }
    
    /**
     * Sets the whole app to be draggable
     */
    private void setDraggable(Node node) {
        node.addEventFilter(MouseEvent.MOUSE_PRESSED, new EventHandler<MouseEvent>() {
            @Override
            public void handle(MouseEvent mouseEvent) {
                currScreenXPos = mouseEvent.getSceneX();
                currScreenYPos = mouseEvent.getSceneY();
            }
        });
        node.addEventFilter(MouseEvent.MOUSE_DRAGGED, new EventHandler<MouseEvent>() {
            @Override
            public void handle(MouseEvent mouseEvent) {
                primaryStage.setX(mouseEvent.getScreenX() - currScreenXPos);
                primaryStage.setY(mouseEvent.getScreenY() - currScreenYPos);
            }
        });
    }
    
    /**
     * Toggles the app between two sizes. One being the default size, and the full screen size
     */
    @FXML
    protected void toggleWindowSize() {
        if (isMaximized) {
            primaryStage.setMaximized(false);

            primaryStage.setWidth(Config.DefaultWindowWidth);
            primaryStage.setHeight(Config.DefaultWindowHeight);

        } else {
            primaryStage.setMaximized(true);
        }
        isMaximized = !isMaximized;
        toggleSizeButtonSymbol();
    }
    
    private void toggleSizeButtonSymbol() {
        if (isMaximized) {
            toggleSizeButton.setText(unMaximizeButtonSymbol);
        } else {
            toggleSizeButton.setText(maximizeButtonSymbol);
        }
    }
    
    /**
     * Opens the About Us page
     */
    @FXML
    private void handleCredits() {
        helpWindow.visit(Config.AboutUsUrl);
    }
    
    /**
     * Minimizes the window
     */
    @FXML
    private void setMinimized() {
        primaryStage.setIconified(true);
    }
    
    @FXML
    private void handleHelp() {
        showHelpAtAnchor("");
    }

    protected void showHelpAtAnchor(String anchor) {
        helpWindow.getHelp(anchor);
    }

    protected void show() {
        primaryStage.show();
        initEventsCenter();
    }
    
    private void initEventsCenter() {
        EventsCenter.getInstance().registerHandler(this);
    }
    
    /**
     * Closes the application.
     */
    @FXML
    private void handleExit() {
        raise(new ExitAppRequestEvent());
    }

    @Subscribe
    public void handleToDoListSavedEvent(ToDoListSavedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event, "Setting last updated status to " + LocalDateTime.now()));
        statusBarFooter.setSyncStatus(LocalDateTime.now());
    }
}
```
###### \java\seedu\commando\ui\TaskCard.java
``` java
    private void setTagLabel() {
        if (!toDo.getTags().isEmpty()) {
            String tags = "";
            for (Tag tag : toDo.getTags()) {
                tags += "#" + tag.value + " ";
            }
            tagsLabel.setText(tags);
        } else {
            tagsLabel.setManaged(false);
        }
    }
    
    private void setDateTimeLabel() {
        if (toDo.getDueDate().isPresent()) {
            final LocalDateTime due = toDo.getDueDate().get().value;
            final long dayDifference = ChronoUnit.DAYS.between(LocalDateTime.now(), due);
            dueLabel.setText("by " + ToDoCardStyleManager.prettifyDateTime(due));
            dueLabel.setStyle("-fx-text-fill: " + 
                  ToDoCardStyleManager.getDateProximityGreen((int) dayDifference));
        } else {
            dueLabel.setText("");
        }
    }
```
###### \java\seedu\commando\ui\TaskCard.java
``` java
    /**
     * Every recently modified event will have a red border
     * This includes modification via undo, edit, add
     */
    private void setRecentlyModifiedState() {
        taskPaneInner.setStyle(ToDoCardStyleManager.recentlyModifiedStateCSS);
    }
    
    /**
     * Tints a finished event gray
     */
    private void setFinishedState() {
        taskPaneInner.setStyle(ToDoCardStyleManager.finishedStateContentCSS);
        indexLabel.setStyle(ToDoCardStyleManager.finishedStateIndexCSS);
    }
    
    /**
     * Tints a hovered event a slight gray
     */
    @FXML
    private void activateHoverState() {
        if (!isFinished) {
            taskPaneInner.setStyle(ToDoCardStyleManager.activateHoverStateContentCSS);
            indexLabel.setStyle(ToDoCardStyleManager.activateHoverStateIndexCSS);
        }
    }
    
    @FXML
    private void deactivateHoverState() {
        if (!isFinished) {
            taskPaneInner.setStyle(ToDoCardStyleManager.deactivateHoverStateContentCSS);
            indexLabel.setStyle(ToDoCardStyleManager.deactivateHoverStateIndexCSS);
        }
    }
```
###### \java\seedu\commando\ui\TaskListPanel.java
``` java
        Platform.runLater(() -> {
            scrollbar = (ScrollBar) taskListView.lookup(".scroll-bar:vertical");
        });
```
###### \java\seedu\commando\ui\TaskListPanel.java
``` java
    protected ListView<UiToDo> getTaskListView() {
        return taskListView;
    }
    
    private boolean isScrollBarPresent() {
        return scrollbar != null;
    }
    
    protected void scrollDown() {
        if (isScrollBarPresent()) {
            scrollbar.setValue(Math.min(scrollbar.getValue() + 0.1, 1));
        }
    }
    
    protected void scrollUp() {
        if (isScrollBarPresent()) {
            scrollbar.setValue(Math.max(scrollbar.getValue() - 0.1, 0));
        }
    }
```
###### \java\seedu\commando\ui\ToDoCardStyleManager.java
``` java
/**
 * Contains the common functions and variables that EventCard and TaskCard shares
 * and additional styling choices of elements that are doen programmatically
 */
public class ToDoCardStyleManager {
    
    // Styles for EventCard and TaskCard for their respective states: 
    //      Recently modified
    //      Finished
    //      Hover and non hover
    public static String recentlyModifiedStateCSS = "-fx-border-color: red";
    
    public static String finishedStateContentCSS = "-fx-background-color: derive(#1d1d1d, 95%);";
    public static String finishedStateIndexCSS = "-fx-background-color: derive(#1d1d1d, 30%);";
    
    public static String activateHoverStateContentCSS = "-fx-background-color: derive(#DCDCDC, 50%);";
    public static String activateHoverStateIndexCSS = "-fx-background-color: derive(#1d1d1d, 40%);";
    
    public static String deactivateHoverStateContentCSS = "-fx-background-color: #DCDCDC;";
    public static String deactivateHoverStateIndexCSS = "-fx-background-color: derive(#1d1d1d, 60%);";
    
    // Formatter for displaying the dates for dueLabel in TaskCard, startLabel and endLabel for EventCard
    private static DateTimeFormatter formatTime = DateTimeFormatter.ofPattern("HH:mm");
    private static DateTimeFormatter formatDay = DateTimeFormatter.ofPattern("EEE d");
    private static DateTimeFormatter formatMonth = DateTimeFormatter.ofPattern("MMM");
    
    // In case I want to change them for some reason
    private static String keywordTo = "to";
    private static String keywordToday = "Today";
    private static String keywordTomorrow = "Tomorrow";
    private static String keywordYesterday = "Yesterday";
    
    private static LocalDate todayDate = LocalDate.now();
    private static LocalDate tomorrowDate = todayDate.plusDays(1);
    private static LocalDate yesterdayDate = todayDate.minusDays(1);
    
    
    /**
     * @param startDateTime start date time
     * @param endDateTime end date time
     * @return format in a way that is intuitive to the user
     * I.e. Dates that in the current year will not show the years
     * I.e. Dates that are in the same year will only show the year once
     * I.e. Dates that are tomorrow show up as "tomorrow" (Similarly, yesterday and today)
     * I.e. Dates that are in the same month will only show the month once, provided that 
     *      the year is the same
     * I.e. Times will be displayed for both no matter what, even if datetimes are exactly the same
     */
    protected static String prettifyDateTimeRange(LocalDateTime startDateTime, LocalDateTime endDateTime) {
        
        String start = "";
        String end = "";
        
        boolean sameYear = startDateTime.getYear() == endDateTime.getYear();
        boolean sameMonth = startDateTime.getMonthValue() == endDateTime.getMonthValue();
        boolean sameDay = startDateTime.getDayOfMonth() == endDateTime.getDayOfMonth();
        boolean sameDayAndIsYtdOrTdyOrTmr = sameYear && sameMonth && 
                (startDateTime.toLocalDate().isEqual(todayDate) ||
                 startDateTime.toLocalDate().isEqual(tomorrowDate) ||
                 startDateTime.toLocalDate().isEqual(yesterdayDate));
        
        // Damn corner cases. If its Yesterday or Today or Tomorrow, shouldn't show month and year
        if (sameDayAndIsYtdOrTdyOrTmr) {
            return getTime(startDateTime) + " " + keywordTo + " " + getTime(endDateTime) + " " + getDay(startDateTime);
        }
        
        if (sameYear) {
            // If start year is equals to end year
            if (endDateTime.getYear() != todayDate.getYear()) {
                // If both start year and end year is not this year
                end += " " + endDateTime.getYear();
                // Else, don't display any year
            }
        } else {
            // Start and end year are not equal
            // Hence display both
            end += " " + endDateTime.getYear();
            start += " " + startDateTime.getYear();
        }
        
        if (sameYear && sameMonth) {
            // If same year and same month
            // Display one month
            end = " " + getMonth(endDateTime) + end;
        } else {
            // Display both months
            start = " " + getMonth(startDateTime) + start;
            end = " " + getMonth(endDateTime) + end;
        }
        
        if (sameYear && sameMonth && sameDay) {
            // If same year and same month and same day
            // Display one month
            end = " " + getDay(endDateTime) + end;
        } else {
            // Display both months
            start = " " + getDay(startDateTime) + start;
            end = " " + getDay(endDateTime) + end;
        }

        // If exactly the same date, start will be "", hence there is a need to get rid 
        // of the extra space
        start = getTime(startDateTime) + start;
        end = getTime(endDateTime) + end;
        
        if (!sameYear || !sameMonth || !sameDay) {
            return start + " " + keywordTo + "\n" + end;
        } else {
            return start + " " + keywordTo + " " + end;
        }
    }
    
    private static String getDay(LocalDateTime ldt) {
        final LocalDate ld = ldt.toLocalDate();
        if (ld.isEqual(yesterdayDate)) {
            return keywordYesterday;
        } else if (ld.isEqual(todayDate)) {
            return keywordToday;
        } else if (ld.isEqual(tomorrowDate)) {
            return keywordTomorrow;
        } else {
            return formatDay.format(ldt);
        }
    }
    
    private static String getMonth(LocalDateTime ldt) {
        return formatMonth.format(ldt);
    }
    
    private static String getTime(LocalDateTime ldt) {
        return formatTime.format(ldt);
    }
    
    /**
     * @param the date and time (LocalDateTime)
     * @return format in a way that is intuitive to the user
     * I.e. Dates that in the current year will not show the years
     * I.e. Dates that are today show up as "Today"
     * I.e. Dates that are tomrorow show up as "Tmr"
     */
    protected static String prettifyDateTime(LocalDateTime dateTime) {
        boolean isYtdOrTdyOrTmr = 
                 dateTime.toLocalDate().isEqual(todayDate) ||
                 dateTime.toLocalDate().isEqual(tomorrowDate) ||
                 dateTime.toLocalDate().isEqual(yesterdayDate);
        
        if (isYtdOrTdyOrTmr) {
            return getTime(dateTime) + " " + getDay(dateTime);
        } else if (dateTime.getYear() == todayDate.getYear()) {
            return getTime(dateTime) + " " + getDay(dateTime) + " " + getMonth(dateTime);
        } else {
            return getTime(dateTime) + " " + getDay(dateTime) + " " + getMonth(dateTime) + " " + dateTime.getYear();
        }
    }
    
    /**
     * @param dayDifference
     * @return colour code for a date label. The closer it is to today, the more red 
     * it will become, otherwise, tends towards green. If it is already over (neg), it is 
     * fully red
     */
    protected static String getDateProximityGreen(int dayDifference) {
        if (dayDifference < 0) {
            return "#FF0000";
        } else if (dayDifference <= 1) {
            return "#DD0000";
        } else if (dayDifference <= 3) {
            return "#AA0000";
        } else if (dayDifference <= 7) {
            return "#882200";
        } else if (dayDifference <= 14) {
            return "#686033";
        } else {
            return "#386D33";
        }
    }
    
    /**
     * @param dayDifference
     * @return colour code for a date label. The closer it is to today, the more red 
     * it will become, otherwise, tends towards blue. If it is already over (neg), it is 
     * fully red
     */
    protected static String getDateProximityBlue(int dayDifference) {
        if (dayDifference < 0) {
            return "#FF0000";
        } else if (dayDifference <= 1) {
            return "#DD0A00";
        } else if (dayDifference <= 3) {
            return "#AA2100";
        } else if (dayDifference <= 7) {
            return "#69326B";
        } else if (dayDifference <= 14) {
            return "#3C26A8";
        } else {
            return "#0011FF";
        }
    }
    
}
```
###### \java\seedu\commando\ui\ToDoListViewCell.java
``` java
class ToDoListViewCell extends ListCell<UiToDo> {

    protected enum Card {
        Event,
        Task
    }
    
    private Card chosenCard;
    
    public ToDoListViewCell(Card card) {
        chosenCard = card;
    }

    @Override
    protected void updateItem(UiToDo toDo, boolean empty) {
        super.updateItem(toDo, empty);
        if (empty || toDo == null) {
            setGraphic(null);
            setText(null);
        } else {
            HBox layout;
            if (chosenCard == Card.Event) {
                layout = EventCard.load(toDo, toDo.getIndex()).getLayoutState(toDo.isNew(), toDo.isFinished());
            } else {
                layout = TaskCard.load(toDo, toDo.getIndex()).getLayoutState(toDo.isNew(), toDo.isFinished());
            }
            setGraphic(layout);
        }
    }
}
```
###### \resources\view\EventCard.fxml
``` fxml
<?import javafx.geometry.Insets?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.layout.HBox?>
<?import javafx.scene.layout.VBox?>

<HBox id="eventPane" fx:id="eventPane" maxHeight="1.7976931348623157E308" styleClass="event-pane" stylesheets="@DarkTheme.css" xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1">
	<children>
		<HBox fx:id="eventPaneInner" maxHeight="1.7976931348623157E308" onMouseEntered="#activateHoverState" onMouseExited="#deactivateHoverState" styleClass="event-pane-inner" HBox.hgrow="ALWAYS">
			<children>
				<HBox alignment="CENTER_LEFT" maxHeight="1.7976931348623157E308" prefWidth="216.0" spacing="5" HBox.hgrow="ALWAYS">
					<children>
						<HBox maxHeight="1.7976931348623157E308" HBox.hgrow="ALWAYS">
							<children>
								<Label fx:id="indexLabel" alignment="TOP_CENTER" maxHeight="1.7976931348623157E308" maxWidth="1.7976931348623157E308" minWidth="50.0" prefHeight="50.0" text="\$i" textOverrun="CLIP">
									<padding>
										<Insets top="13.0" />
									</padding>
								</Label>
								<Label fx:id="titleLabel" maxHeight="1.7976931348623157E308" styleClass="cell_big_label" text="\$value" wrapText="true">
                           <padding>
                              <Insets left="15.0" right="7.0" />
                           </padding></Label>
							</children>
						</HBox>
						<HBox fillHeight="false" maxHeight="1.7976931348623157E308">
							<children>
                        <VBox>
                           <children>
                              <Label fx:id="recurrenceLabel" alignment="TOP_RIGHT" maxHeight="1.7976931348623157E308" minWidth="-Infinity" styleClass="cell_big_label" text="\$recurr" wrapText="true">
                                 <padding>
                                    <Insets left="3.0" right="3.0" />
                                 </padding>
                              </Label>
      								<Label fx:id="tagsLabel" alignment="TOP_RIGHT" maxHeight="1.7976931348623157E308" minWidth="-Infinity" styleClass="cell_big_label" text="\$tags" wrapText="true">
      									<padding>
      										<Insets left="3.0" right="3.0" />
      									</padding>
                                 <VBox.margin>
                                    <Insets top="5.0" />
                                 </VBox.margin>
      								</Label>
                           </children>
                           <padding>
                              <Insets bottom="5.0" left="4.0" right="4.0" top="5.0" />
                           </padding>
                        </VBox>
							</children>
						</HBox>
					</children>
				</HBox>
						<HBox alignment="TOP_CENTER" maxHeight="1.7976931348623157E308">
							<children>
								<Label fx:id="dateIntervalLabel" alignment="CENTER" maxWidth="1.7976931348623157E308" text="\$interval" />
							</children>
               <padding>
                  <Insets left="7.0" right="7.0" />
               </padding>
						</HBox>
			</children>
		</HBox>
	</children>
	<padding>
		<Insets bottom="5.0" left="7.0" right="7.0" top="5.0" />
	</padding>
</HBox>
```
###### \resources\view\EventListPanel.fxml
``` fxml
<?import java.net.URL?>
<?import javafx.scene.control.ListView?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.layout.VBox?>

<VBox AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0"
	AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0"
	xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1"
	fx:controller="seedu.commando.ui.EventListPanel">
	<stylesheets>
		<URL value="@DarkTheme.css" />
		<URL value="@Extensions.css" />
	</stylesheets>
	<children>
		<ListView fx:id="eventListView" VBox.vgrow="ALWAYS" />
	</children>
</VBox>
```
###### \resources\view\MainWindow.fxml
``` fxml
<?import java.net.URL?>
<?import javafx.geometry.Insets?>
<?import javafx.scene.control.Button?>
<?import javafx.scene.control.Menu?>
<?import javafx.scene.control.MenuBar?>
<?import javafx.scene.control.SplitPane?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.layout.FlowPane?>
<?import javafx.scene.layout.HBox?>
<?import javafx.scene.layout.VBox?>
<?import javafx.scene.text.Text?>

<VBox maxHeight="Infinity" maxWidth="Infinity" minHeight="-Infinity" minWidth="-Infinity" xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1" fx:controller="seedu.commando.ui.MainWindow">
	<stylesheets>
		<URL value="@DarkTheme.css" />
		<URL value="@Extensions.css" />
	</stylesheets>
	<children>
		<HBox fx:id="titleBar" styleClass="title-bar">
			<children>
				<FlowPane HBox.hgrow="ALWAYS">
					<children>
						<MenuBar prefWidth="297.0" styleClass="title-button">
							<menus>
								<Menu disable="true" mnemonicParsing="false" text="Help (Alt + H)" />
								<Menu disable="true" mnemonicParsing="false" text="Credits (Alt + C)" />
							</menus>
						</MenuBar>
      				<MenuBar opacity="0.5" styleClass="title-button">
      					<menus>
      						<Menu disable="true" mnemonicParsing="false" text="CommanDo" />
      					</menus>
      				</MenuBar>
					</children>
				</FlowPane>
            <Button fx:id="minimizeButton" mnemonicParsing="false" onMouseClicked="#setMinimized" prefHeight="40.0" prefWidth="40.0" styleClass="size-button" text="Ôº?" textOverrun="CLIP" />
            <Button fx:id="toggleSizeButton" mnemonicParsing="false" onMouseClicked="#toggleWindowSize" prefHeight="40.0" prefWidth="40.0" styleClass="size-button" text="‚¨?" textOverrun="CLIP" />
            <Button fx:id="exitButton" mnemonicParsing="false" onMouseClicked="#handleExit" prefHeight="40.0" prefWidth="40.0" style="-fx-border-color: transparent;" styleClass="size-button" text="‚ú?" textOverrun="CLIP" />
			</children>
		</HBox>
		<SplitPane id="splitPane" fx:id="splitPane" dividerPositions="0.4" VBox.vgrow="ALWAYS">
			<items>
				<VBox fx:id="eventList" minWidth="340" prefHeight="800" prefWidth="340">
					<padding>
						<Insets bottom="10.0" left="10.0" right="10.0" />
					</padding>
					<children>
                  <VBox alignment="CENTER" prefWidth="320.0" styleClass="event-pane-title-background">
                     <children>
                        <Text fill="WHITE" strokeType="OUTSIDE" strokeWidth="0.0" styleClass="event-pane-title" text="Events" />
                     </children>
                     <padding>
                        <Insets bottom="5.0" />
                     </padding>
                  </VBox>
						<AnchorPane fx:id="eventListPanelPlaceholder" VBox.vgrow="ALWAYS" />
					</children>
				</VBox>
				<VBox fx:id="taskList" minWidth="340" prefHeight="800" prefWidth="340">
					<padding>
						<Insets bottom="10.0" left="10.0" right="10.0" />
					</padding>
					<children>
                  <VBox alignment="CENTER" styleClass="event-pane-title-background">
                     <children>
                        <Text fill="WHITE" strokeType="OUTSIDE" strokeWidth="0.0" styleClass="task-pane-title" text="Tasks" />
                     </children>
                     <padding>
                        <Insets bottom="5.0" />
                     </padding>
                  </VBox>
						<AnchorPane fx:id="taskListPanelPlaceholder" VBox.vgrow="ALWAYS" />
					</children>
				</VBox>
			</items>
		</SplitPane>
		<AnchorPane fx:id="resultDisplayPlaceholder" styleClass="anchor-pane-with-border" VBox.vgrow="NEVER">
			<padding>
				<Insets bottom="5.0" left="10.0" right="10.0" top="5.0" />
			</padding>
		</AnchorPane>
		<AnchorPane fx:id="commandBoxPlaceholder" styleClass="anchor-pane-with-border" VBox.vgrow="NEVER">
			<padding>
				<Insets bottom="5.0" left="10.0" right="10.0" top="5.0" />
			</padding>
		</AnchorPane>
		<AnchorPane fx:id="statusbarPlaceholder" VBox.vgrow="NEVER" />
	</children>
</VBox>
```
###### \resources\view\TaskCard.fxml
``` fxml
<?import javafx.geometry.Insets?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.layout.HBox?>
<?import javafx.scene.layout.VBox?>

<HBox id="taskPane" fx:id="taskPane" maxHeight="1.7976931348623157E308" styleClass="task-pane" stylesheets="@DarkTheme.css" xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1">
	<children>
		<HBox fx:id="taskPaneInner" maxHeight="1.7976931348623157E308" onMouseEntered="#activateHoverState" onMouseExited="#deactivateHoverState" styleClass="task-pane-inner" HBox.hgrow="ALWAYS">
			<children>
				<HBox alignment="CENTER_LEFT" maxHeight="1.7976931348623157E308" prefWidth="216.0" spacing="5" HBox.hgrow="ALWAYS">
					<children>
						<HBox maxHeight="1.7976931348623157E308" HBox.hgrow="ALWAYS">
							<children>
								<Label fx:id="indexLabel" alignment="TOP_CENTER" maxHeight="1.7976931348623157E308" maxWidth="1.7976931348623157E308" minWidth="50.0" prefHeight="50.0" text="\$i" textOverrun="CLIP">
									<padding>
										<Insets top="13.0" />
									</padding>
								</Label>
								<Label fx:id="titleLabel" maxHeight="1.7976931348623157E308" styleClass="cell_big_label" text="\$value" wrapText="true">
                           <padding>
                              <Insets left="15.0" right="7.0" />
                           </padding></Label>
							</children>
						</HBox>
						<HBox fillHeight="false" maxHeight="1.7976931348623157E308">
							<children>
								<Label fx:id="tagsLabel" alignment="TOP_RIGHT" maxHeight="1.7976931348623157E308" maxWidth="1.7976931348623157E308" minHeight="-Infinity" minWidth="-Infinity" styleClass="cell_big_label" text="\$tags" wrapText="true">
									<padding>
										<Insets left="3.0" right="3.0" />
									</padding>
								</Label>
							</children>
                     <opaqueInsets>
                        <Insets />
                     </opaqueInsets>
                     <padding>
                        <Insets left="4.0" right="4.0" top="10.0" />
                     </padding>
						</HBox>
					</children>
				</HBox>
				<VBox alignment="TOP_CENTER" maxHeight="1.7976931348623157E308" VBox.vgrow="ALWAYS">
					<children>
						<Label fx:id="dueLabel" alignment="CENTER" maxWidth="1.7976931348623157E308" text="\$due" />
					</children>
               <padding>
                  <Insets left="7.0" right="7.0" />
               </padding>
				</VBox>
			</children>
		</HBox>
	</children>
	<padding>
		<Insets bottom="5.0" left="7.0" right="7.0" top="5.0" />
	</padding>
   <opaqueInsets>
      <Insets />
   </opaqueInsets>
</HBox>
```
###### \resources\view\TaskListPanel.fxml
``` fxml
<?import javafx.scene.control.ListView?>
<?import javafx.scene.layout.*?>
<?import java.net.URL?>
<VBox xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1"
	fx:controller="seedu.commando.ui.TaskListPanel" AnchorPane.bottomAnchor="0.0"
	AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0"
	AnchorPane.topAnchor="0.0">
	<stylesheets>
		<URL value="@DarkTheme.css" />
		<URL value="@Extensions.css" />
	</stylesheets>
	<children>
		<ListView fx:id="taskListView" VBox.vgrow="ALWAYS" />
	</children>
</VBox>
```
