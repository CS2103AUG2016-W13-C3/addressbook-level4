# A0142230B
###### \java\seedu\commando\commons\events\logic\ToDoListFilePathChangeRequestEvent.java
``` java
/**
 * An event requesting to change the to-do list file path
 */

public class ToDoListFilePathChangeRequestEvent extends BaseEvent {

    public final String path;

    public ToDoListFilePathChangeRequestEvent(String path) {
        this.path = path;
    }

    @Override
    public String toString() {
        return "Change the default to-do list file path to "+ path;
    }
}
```
###### \java\seedu\commando\logic\commands\CommandFactory.java
``` java
    private Command buildImportCommand() throws IllegalValueException {
        // Extract the file path
        String path = commandParser.extractText()
            .orElseThrow(
                () -> new IllegalValueException(Messages.MISSING_IMPORT_PATH)
            );

        return new ImportCommand(path);
    }

```
###### \java\seedu\commando\logic\commands\CommandFactory.java
``` java
    private Command buildExportCommand() throws IllegalValueException {
        // Extract the file path
        Boolean isOverride = commandParser.isOverrideThenExtract();
        String path = commandParser.extractText()
            .orElseThrow(
                () -> new IllegalValueException(Messages.MISSING_EXPORT_PATH)
            );

        return new ExportCommand(path, isOverride);
    }

```
###### \java\seedu\commando\logic\commands\CommandFactory.java
``` java
	private Command buildStoreCommand() throws IllegalValueException {
		// Check if override
		Boolean isOverride = commandParser.isOverrideThenExtract();
		String path = commandParser.extractText()
				.orElseThrow(() -> new IllegalValueException(Messages.MISSING_STORE_PATH));

		return new StoreCommand(path, isOverride);
	}

```
###### \java\seedu\commando\logic\commands\CommandFactory.java
``` java
    private Command buildListCommand() throws IllegalValueException {
        // Extract the date range, if exists
        Optional<DateRange> dateRange = extractAnyDateRange();

        // Wrong format
        ensureInputIsEmpty(ListCommand.COMMAND_WORD);

        // Should not have recurrence info in the input
        if (dateRange.isPresent() && dateRange.get().recurrence != Recurrence.None) {
            throw new IllegalValueException(String.format(Messages.INVALID_COMMAND_FORMAT, ListCommand.COMMAND_WORD));
        } else {
            return new ListCommand(dateRange);
        }
    }

```
###### \java\seedu\commando\logic\commands\DeleteCommand.java
``` java
	@Override
	public CommandResult execute() throws NoModelException {
		Model model = getModel();
		ToDoList listToDelete = new ToDoList();
		ToDoList listToEdit = new ToDoList();

		// If to-do with the index is valid, add it to the listToDelete
		// If delete any fields is required, add it to the listToEdit,too.
		// else throw error message and return
		for (int index : toDoIndices) {
			Optional<UiToDo> toDoToDelete = model.getUiToDoAtIndex(index);
			if (!toDoToDelete.isPresent()) {
				return new CommandResult(String.format(Messages.TODO_ITEM_INDEX_INVALID, index), true);
			}
			ToDo toDoToEdit = new ToDo(toDoToDelete.get());

			try {
				listToDelete.add(toDoToDelete.get());
			} catch (IllegalValueException exception) {
				return new CommandResult(exception.getMessage(), true);
			}

			CommandResult errorResult = deleteFieldsRequested(index, toDoToEdit);
			if (errorResult != null) {
				return errorResult;
			}

			try {
				listToEdit.add(toDoToEdit);
			} catch (IllegalValueException exception) {
				return new CommandResult(exception.getMessage(), true);
			}
		}

        // if no deletion of fields, delete the whole to-do
        if (!ifDeleteTags && !ifDeleteTime && !ifDeleteRecurrence) {
            try {
                // Form comma-separated list of to-dos to be deleted
                String toDoTitles = getToDoTitlesString(model);

                model.changeToDoList(new ToDoListChange(new ToDoList(), listToDelete));

                return new CommandResult(String.format(Messages.DELETE_COMMAND, toDoTitles));
            } catch (IllegalValueException exception) {
                return new CommandResult(exception.getMessage(), true);
            }
        } else {
            // if any deletion of fields, edit the to-do
            try {
                // Form comma-separated list of to-dos to be deleted
                String toDoTitles = getToDoTitlesString(model);

                model.changeToDoList(new ToDoListChange(listToEdit, listToDelete));

                return new CommandResult(String.format(Messages.EDIT_COMMAND, toDoTitles));

            } catch (IllegalValueException exception) {
                return new CommandResult(exception.getMessage(), true);
            }

        }
    }
	
	/**
	 * Delete the requested field(s) of toDoToEdit
	 * 
	 * @return CommandResult with error message, if no error returns null
	 */
	private CommandResult deleteFieldsRequested(int index, ToDo toDoToEdit) {
		if (ifDeleteTags) {
			if (toDoToEdit.getTags().size() > 0) {
				toDoToEdit.setTags(Collections.emptySet());
			} else {
				return new CommandResult(String.format(Messages.DELETE_COMMAND_NO_TAGS, index), true);
			}
		}
		if (ifDeleteTime) {
			if (toDoToEdit.hasTimeConstraint()) {
				toDoToEdit.clearTimeConstraint();
			} else {
				return new CommandResult(String.format(Messages.DELETE_COMMAND_NO_TIME_CONSTRAINTS, index), true);
			}
		}
		if (ifDeleteRecurrence) {
			// Check if there is a date range and it is recurring
			Optional<DateRange> dateRangeOptional = toDoToEdit.getDateRange();
			Optional<DueDate> dueDateOptional = toDoToEdit.getDueDate();

			if (dateRangeOptional.isPresent() && dateRangeOptional.get().recurrence != Recurrence.None) {
				try {
					toDoToEdit.setDateRange(new DateRange(dateRangeOptional.get().startDate,
							dateRangeOptional.get().endDate, Recurrence.None));
				} catch (IllegalValueException e) {
					assert false : "Deleting recurrence should always be valid";
				}
			} else if (dueDateOptional.isPresent() && dueDateOptional.get().recurrence != Recurrence.None) {
				toDoToEdit.setDueDate(new DueDate(dueDateOptional.get().value, Recurrence.None));
			} else {
				return new CommandResult(String.format(Messages.DELETE_COMMAND_NO_RECURRENCE, index), true);
			}
		}
		return null;
	}

    private String getToDoTitlesString(Model model) {
        return toDoIndices.stream().map(
            toDoIndex -> model.getUiToDoAtIndex(toDoIndex).get().getTitle().toString()
        ).collect(Collectors.joining(", "));
    }

    /**
     * Sets the delete command to delete the time constraints of the to-dos at indices.
     */
    public void deletesTime() {
        this.ifDeleteTime = true;
    }

    /**
     * Sets the delete command to delete the tags of the to-dos at indices.
     */
    public void deletesTags() {
        this.ifDeleteTags = true;
    }

    /**
     * Sets the delete command to delete the recurrences of the to-dos at indices.
     */
    public void deletesRecurrence() {
        this.ifDeleteRecurrence = true;
    }
}
```
###### \java\seedu\commando\logic\commands\ExportCommand.java
``` java
/**
 * Exports the to-do list to a destination file path.
 */
public class ExportCommand extends Command {

    public static final String COMMAND_WORD = "export";

    private String path;
	private Boolean isOverride;

    /**
     * Initializes a export command.
     * @param inputPath requested file path to export data, non-null
	 * @param isOverride if override the path file
     */
    public ExportCommand(String inputPath, boolean isOverride) {
        assert inputPath != null;
        this.path = inputPath;
		this.isOverride = isOverride;
    }

    /**
     * Asserts that {@code model} are non-null
     */
	@Override
	public CommandResult execute() throws NoModelException {
		Model model = getModel();

		File file = new File(path);

		// Check if the path has a file name to save
		if (path.endsWith("\\")) {
			return new CommandResult(Messages.MISSING_EXPORT_FILE, true);
		}
		// Check if the destination file already exists and no override request(avoid overwriting
		// important data)
		else if (file.exists() && !isOverride) {
			return new CommandResult(String.format(Messages.EXPORT_COMMAND_FILE_EXIST, path), true);
		} 		
		else {
			XmlToDoListStorage export = new XmlToDoListStorage(path);

			try {
				export.saveToDoList(model.getToDoList(), path);
			} catch (IOException e) {
				return new CommandResult(e.getMessage(), true);
			}

			return new CommandResult(String.format(Messages.EXPORT_COMMAND, path));
		}
	}
}
```
###### \java\seedu\commando\logic\commands\FinishCommand.java
``` java
/**
 * Marks a to-do item as done.
 */
public class FinishCommand extends Command {

    public static final String COMMAND_WORD = "finish";

    public final List<Integer> toDoIndices;

    /**
     * Initializes a finish command.
     * @param toDoIndices list of indices of to-dos that to finish
     */
    public FinishCommand(List<Integer> toDoIndices) {
        this.toDoIndices = toDoIndices;
    }

    @Override
    public CommandResult execute() throws NoModelException {
        Model model = getModel();
        ToDoList listToFinish = new ToDoList();
        ToDoList finishedToDos = new ToDoList();

        // If to-do with the index is valid and not finished, mark it as finished, else throw error message and return
		LocalDateTime datetimeFinished = LocalDateTime.now();

		for (int index : toDoIndices) {
			Optional<UiToDo> toDoToFinish = model.getUiToDoAtIndex(index);

			CommandResult errorResult = checkToDoFinishable(index, toDoToFinish);

			if (errorResult != null) {
				return errorResult;
			} else {
				try {
					listToFinish.add(toDoToFinish.get());
					// Mark as finished
					finishedToDos.add(new ToDo(toDoToFinish.get()).setDateFinished(datetimeFinished));
				} catch (IllegalValueException exception) {
					return new CommandResult(exception.getMessage(), true);
				}
			}
		}
        
        return updateToDoListChange(model, listToFinish, finishedToDos);
    }

    private String getToDoTitlesString(Model model) {
        return toDoIndices.stream().map(
            toDoIndex -> model.getUiToDoAtIndex(toDoIndex).get().getTitle().toString()
        ).collect(Collectors.joining(", "));
    }
    
	/**
	 * Update the to-do list after changes to the to-dos
	 * @return CommandResult with error message, if no error returns null
	 */
	private CommandResult updateToDoListChange(Model model, ToDoList listToFinish, ToDoList finishedToDos) {
		try {
			// Form comma-separated list of to-dos to be finished
	        String toDoTitles = getToDoTitlesString(model);
			model.changeToDoList(new ToDoListChange(finishedToDos, listToFinish));
			return new CommandResult(String.format(Messages.FINISH_COMMAND, toDoTitles));
		} catch (IllegalValueException exception) {
			return new CommandResult(exception.getMessage(), true);
		}
	}
	/**
	 * Check if the given to-do is valid and can be finished.
	 * @param toDoToFinish the given to-do
	 * @return CommandResult with error message, if no error returns null
	 */
	private CommandResult checkToDoFinishable(int index, Optional<UiToDo> toDoToFinish) {
		if (!toDoToFinish.isPresent()) {
			return new CommandResult(String.format(Messages.TODO_ITEM_INDEX_INVALID, index), true);
		}

		else if (toDoToFinish.get().isEvent()) {
			return new CommandResult(String.format(Messages.FINISH_COMMAND_CANNOT_FINISH_EVENT,
					toDoToFinish.get().getTitle().toString()), true);
		}

		else if (toDoToFinish.get().isFinished()) {
			return new CommandResult(
					String.format(Messages.FINISH_COMMAND_ALREADY_FINISHED, toDoToFinish.get().getTitle().toString()),
					true);
		}
		return null;
	}
}
```
###### \java\seedu\commando\logic\commands\ImportCommand.java
``` java

/**
* Imports the to-do list from a destination file path.
*/
public class ImportCommand extends Command {

	public static final String COMMAND_WORD = "import";

	private String path;

  /**
   * Initializes a import command.
   * @param inputPath file path of source data, non-null
   */
	public ImportCommand(String inputPath) {
		assert inputPath != null;
		this.path = inputPath;
	}

	/**
	 * Asserts that {@code model} are non-null
	 */
	@Override
	public CommandResult execute() throws NoModelException {
		Model model = getModel();

		File file = new File(path);

		// Check if the path has a file name to save
		if (path.endsWith("\\")) {
			return new CommandResult(Messages.MISSING_IMPORT_FILE, true);
		}

		// Check if the source file exists (should not);
		else if (!file.exists()) {
			return new CommandResult(String.format(Messages.IMPORT_COMMAND_FILE_NOT_EXIST, path), true);
		}

		else {
			// Read the toDoList from the import path
			try {
				XmlSerializableToDoList newXmlToDoList = XmlFileStorage.loadDataFromSaveFile(file);
				updateToDoList(model, newXmlToDoList);
			} catch (FileNotFoundException e) {
				return new CommandResult(String.format(Messages.IMPORT_COMMAND_FILE_NOT_EXIST, path), true);
			} catch (DataConversionException e) {
				return new CommandResult(String.format(Messages.IMPORT_COMMAND_INVALID_DATA, path), true);
			} catch (IllegalValueException e) {
				return new CommandResult(e.getMessage(), true);
			}

			return new CommandResult(String.format(Messages.IMPORT_COMMAND, path));
		}
	}

	private void updateToDoList(Model model, XmlSerializableToDoList newXmlToDoList) throws IllegalValueException {
		model.changeToDoList(new ToDoListChange(newXmlToDoList.getToDos(), model.getToDoList()));
	}

}
```
###### \java\seedu\commando\logic\commands\ListCommand.java
``` java

/**
 * Lists all to-dos within a specified date range.
 */
public class ListCommand extends Command {
    public static final String COMMAND_WORD = "list";
    private Optional<DateRange> dateRange;

    /**
     * Initializes a list command.
     * @param dateRange requested date range to list
     */
    public ListCommand(Optional<DateRange> dateRange) {
        this.dateRange = dateRange;
    }

    @Override
    public CommandResult execute() throws NoModelException {
        Model model = getModel();

        // if no time provided, show all to-dos
        if (!dateRange.isPresent()) {
            model.clearUiToDoListFilter(Model.FILTER_MODE.ALL);
            return new CommandResult(Messages.LIST_COMMAND_CLEAR);
        }

        // Search the toDoList and filter with the dateRange
        model.setUiToDoListFilter(dateRange.get());

        // No to-dos found in search
        if (model.getUiEvents().isEmpty() && model.getUiTasks().isEmpty()) {
            return new CommandResult(String.format(Messages.LIST_COMMAND_NO_TODOS, getDateRangeString()));
        }

        return new CommandResult(String.format(Messages.LIST_COMMAND, getDateRangeString().replaceAll("\\n", " ")));
    }

    private String getDateRangeString() {
        return DateTimePrettifier.prettifyDateTimeRange(
            dateRange.get().startDate, dateRange.get().endDate
        );
    }
}
```
###### \java\seedu\commando\logic\commands\StoreCommand.java
``` java
/**
 *  Change the to-do list file path.
 */
public class StoreCommand extends Command {

    public static final String COMMAND_WORD = "store";

    private String path;
    private Boolean isOverride;
    
    /**
     * Initializes a store command.
     * @param inputPath requested file path to store data, non-null
     * @param isOverride if override the path file
     */
    public StoreCommand(String inputPath, Boolean isOverride) {
        assert inputPath != null;
        this.path = inputPath;
        this.isOverride = isOverride;
    }

    /**
     * Asserts that {@code eventsCenter} and {@code model} are non-null
     */
    @Override
	public CommandResult execute() throws NoEventsCenterException, NoModelException {
		EventsCenter eventsCenter = getEventsCenter();

		File file = new File(path);

		// Check if the path has a file name to save
		if (path.endsWith("\\")) {
			return new CommandResult(Messages.MISSING_STORE_FILE, true);
		}

		// Check if the destination file already exists and no override request(avoid overwriting
		// important data);
		else if (file.exists() && !isOverride) {
			return new CommandResult(String.format(Messages.STORE_COMMAND_FILE_EXIST, path), true);
		}

		// Send a event to change the file path
		else {
			eventsCenter.post(new ToDoListFilePathChangeRequestEvent(path));
			return new CommandResult(String.format(Messages.STORE_COMMAND, path));
		}
	}
}
```
###### \java\seedu\commando\logic\commands\UnfinishCommand.java
``` java
/**
 * Marks a to-do item as not done.
 */
public class UnfinishCommand extends Command {

    public static final String COMMAND_WORD = "unfinish";

	public final List<Integer> toDoIndices;

    /**
     * Initializes a unfinish command.
     * @param toDoIndices list of indices of to-dos that to unfinish
     */
	public UnfinishCommand(List<Integer> toDoIndices) {
		this.toDoIndices = toDoIndices;
	}

	@Override
	public CommandResult execute() throws NoModelException {
		Model model = getModel();
		ToDoList listToUnfinish = new ToDoList();
		ToDoList unfinishedToDos = new ToDoList();

		// If to-do with the index is valid and finished, mark it as unfinished,
		// else throw error message and return
		for (int index : toDoIndices) {
			Optional<UiToDo> toDoToUnfinish = model.getUiToDoAtIndex(index);

			CommandResult errorResult = checkToDoUnfinishable(index, toDoToUnfinish);

			if (errorResult != null) {
				return errorResult;
			} else {
				try {
					listToUnfinish.add(toDoToUnfinish.get());

					// Mark as unfinished
					unfinishedToDos.add(new ToDo(toDoToUnfinish.get()).setIsFinished(false));
				} catch (IllegalValueException e) {
					return new CommandResult(e.getMessage(), true);
				}
			}
		}
			return updateToDoListChange(model, listToUnfinish, unfinishedToDos);
	}

    private String getToDoTitlesString(Model model) {
        return toDoIndices.stream().map(
            toDoIndex -> model.getUiToDoAtIndex(toDoIndex).get().getTitle().toString()
        ).collect(Collectors.joining(", "));
    }
    
	/**
	 * Update the to-do list after changes to the to-dos
	 * @return CommandResult with error message, if no error returns null
	 */
	private CommandResult updateToDoListChange(Model model, ToDoList listToUnfinish, ToDoList unfinishedToDos) {
		try {
			// Form comma-separated list of to-dos to be unfinished
	        String toDoTitles = getToDoTitlesString(model);
			model.changeToDoList(new ToDoListChange(unfinishedToDos, listToUnfinish));
			return new CommandResult(String.format(Messages.UNFINISHED_COMMAND, toDoTitles));
		} catch (IllegalValueException exception) {
			return new CommandResult(exception.getMessage(), true);
		}
	}

	/**
	 * Check if the given to-do is valid and can be unfinished.
	 * @param toDoToUnfinish the given to-do
	 * @return CommandResult with error message, if no error returns null
	 */
	private CommandResult checkToDoUnfinishable(int index, Optional<UiToDo> toDoToUnfinish) {
		if (!toDoToUnfinish.isPresent()) {
			return new CommandResult(String.format(Messages.TODO_ITEM_INDEX_INVALID, index), true);
		}

		else if (toDoToUnfinish.get().isEvent()) {
			return new CommandResult(String.format(Messages.UNFINISH_COMMAND_CANNOT_UNFINISH_EVENT,
					toDoToUnfinish.get().getTitle().toString()), true);
		}

		else if (!toDoToUnfinish.get().isFinished()) {
			return new CommandResult(String.format(Messages.UNFINISH_COMMAND_ALREADY_ONGOING,
					toDoToUnfinish.get().getTitle().toString()), true);
		}
		return null;
	}
}
```
###### \java\seedu\commando\logic\parser\CommandParser.java
``` java

    /**
     * From start, extracts multiple integers in input.
     * It can be a range of integers or different integers separate by space.
     *
     * @return A List of integers found
     * @throws IllegalValueException
     */
    public List<Integer> extractIndicesList() throws IllegalValueException {
        final Matcher matcher = INDEXRANGE_PATTERN.matcher(input.trim());
        List<Integer> indices = new ArrayList<Integer>();
        int firstInt = -1;
        int secondInt = -1;
        Optional<Integer> aNumber;

        // Add the index range to a list of indices
        // Case one: command type : [index] [to|-] [index]
        if (matcher.find()) {
            try {
                firstInt = Integer.parseInt(matcher.group("firstInt"));
                secondInt = Integer.parseInt(matcher.group("secondInt"));
            } catch (NumberFormatException exception) {
                assert false : "Shouldn't be able to fail parsing of integer based on pattern";
            }

            if (firstInt > secondInt) {
                throw new IllegalValueException(Messages.INDEXRANGE_CONSTRAINTS);
            } else {
                for (int i = firstInt; i <= secondInt; i++) {
                    indices.add(i);
                }
            }
            input = matcher.group("left").trim();
        }
        // Case two: command type : {[index]..}
        else {
            aNumber = extractInteger();
            while (aNumber.isPresent()) {
                indices.add(aNumber.get());
                aNumber = extractInteger();
            }
        }
        return indices;

    }
    
    /**
     * Extract the keyword 'override' from input
     * @return true if 'override' found
     */
    public boolean isOverrideThenExtract() {
        final Matcher matcher = OVERRIDE_PATTERN.matcher(input.trim());
        
        if (matcher.find()) {
            input = matcher.group("path").trim();
            return true;
        }
        else {
        	return false;
        }
    }
    
    

```
###### \java\seedu\commando\model\Model.java
``` java

    /**
     * Sets a date range filter on the UI to-dos and sets filter mode to be ALL.
     * Asserts dateRange to be non-null.
     */
    void setUiToDoListFilter(DateRange dateRange);

    enum FILTER_MODE {
        FINISHED, UNFINISHED, ALL
    }
}
```
###### \java\seedu\commando\model\ModelManager.java
``` java
    @Override
    public void setUiToDoListFilter(DateRange dateRange) {
        logger.info("Filtering UI to-dos from " + dateRange.startDate.toString() + " to " + dateRange.endDate.toString());

        uiModel.setToDoListFilter(dateRange);

        logUiToDoList();
    }
}
```
###### \java\seedu\commando\model\ui\UiModel.java
``` java

    /**
     * @see Model#setUiToDoListFilter(DateRange)
     */
    public void setToDoListFilter(DateRange dateRange) {
        assert dateRange != null;

        this.filterMode = Model.FILTER_MODE.ALL;

        updateEventsAndTasksByTime(dateRange);
    }

```
###### \java\seedu\commando\model\ui\UiModel.java
``` java

    /**
     * Update the UI to-dos based on {@link #toDoListManager}'s to-do list and the date range filter
     */
    private void updateEventsAndTasksByTime(DateRange filterDateRange) {
        // Sort and filter events and tasks for UI
        List<ReadOnlyToDo> events = filterAndSortEventsByTime(toDoListManager.getToDoList().getToDos(), filterDateRange);
        List<ReadOnlyToDo> tasks = filterAndSortTasksByTime(toDoListManager.getToDoList().getToDos(), filterDateRange);
        // Update its own lists of UI to-dos
        updateUiToDos(events, tasks);
    }

```
###### \java\seedu\commando\model\ui\UiModel.java
``` java

    /**
     * Filter tasks which are within the filterDateRange from the given toDoList.
     *
     * @return a list of filtered tasks
     */
    private List<ReadOnlyToDo> filterAndSortTasksByTime(List<ReadOnlyToDo> toDos, DateRange filterDateRange) {
        List<ReadOnlyToDo> tasks = new ArrayList<ReadOnlyToDo>();
        for (ReadOnlyToDo toDo : toDos) {
            if (isTaskInDateRange(toDo, filterDateRange)) {
                tasks.add(toDo);
            }
        }
        // For tasks, sort by created date first (latest first)
        tasks.sort((task1, task2) -> task2.getDateCreated().compareTo(task1.getDateCreated()));

        // Then, by whether they have due date and that date (latest first)
        tasks.sort((task1, task2) -> compareDueDates(task1, task2));

        // Then, by whether they are finished and finished date (latest first)
        tasks.sort((task1, task2) -> compareDateFinished(task2, task1));

        return tasks;
    }

    /**
     * Check if a toDo is a task and it is in the filterDateRange
     *
     * @return true if the toDo is a task and it is in the filterDateRange
     */
    private boolean isTaskInDateRange(ReadOnlyToDo toDo, DateRange filterDateRange) {
        if (!toDo.getDueDate().isPresent()) {
            return false;
        }
        LocalDateTime dueDate = toDo.getDueDate().get().value;

        return isTimeInRange(dueDate, filterDateRange);
    }

    /**
     * Filter events which are within the filterDateRange from the given toDoList.
     *
     * @return a list of filtered events
     */
    private List<ReadOnlyToDo> filterAndSortEventsByTime(List<ReadOnlyToDo> toDos, DateRange filterDateRange) {
        List<ReadOnlyToDo> events = new ArrayList<ReadOnlyToDo>();
        for (ReadOnlyToDo toDo : toDos) {
            if (isEventInDateRange(toDo, filterDateRange)) {
                events.add(toDo);
            }
        }

        // For events, sort by created date first (latest first)
        events.sort((event1, event2) -> event2.getDateCreated().compareTo(event1.getDateCreated()));

        // Then, by start dates (earlier first)
        events.sort((event1, event2) -> compareDateRangeStarts(event1, event2));

        // Then, by whether they are finished and finished date (latest first)
        events.sort((event1, event2) -> compareDateFinished(event2, event1));

        return events;
    }

    /**
     * Check if a toDo is a event and it is in the filterDateRange
     *
     * @return true if the toDo is a event and it is in the filterDateRange
     */
    private boolean isEventInDateRange(ReadOnlyToDo toDo, DateRange filterDateRange) {
        if (!toDo.getDateRange().isPresent()) {
            return false;
        }
        LocalDateTime startTime = toDo.getDateRange().get().startDate;
        LocalDateTime endTime = toDo.getDateRange().get().endDate;

        // Case 1: start time is in the range
        if (isTimeInRange(startTime, filterDateRange)) {
            return true;
        }
        // Case 2:end time is in the range
        if (isTimeInRange(endTime, filterDateRange)) {
            return true;
        }

        // Case 3: filterDateRange is in the range between startTime and endTime
        if (startTime.isBefore(filterDateRange.startDate) && endTime.isAfter(filterDateRange.endDate)) {
            return true;
        }

        return false;
    }

    /**
     * Check if a LocalDateTime is within a dateRange
     *
     * @return true if the time is in the dateRange
     */
    private boolean isTimeInRange(LocalDateTime time, DateRange dateRange) {
        return (time.isAfter(dateRange.startDate) || time.isEqual(dateRange.startDate))
            && (time.isBefore(dateRange.endDate) || time.isEqual(dateRange.endDate));
    }

```
###### \java\seedu\commando\storage\JsonUserPrefsStorage.java
``` java
/**
 * A class to access UserPrefs stored in the hard disk as a json file
 */
public class JsonUserPrefsStorage implements UserPrefsStorage{

    private static final Logger logger = LogsCenter.getLogger(JsonUserPrefsStorage.class);

    private String filePath;

    public JsonUserPrefsStorage(String filePath){
        this.filePath = filePath;
    }

    @Override
    public Optional<UserPrefs> readUserPrefs() throws DataConversionException, IOException {
        return readUserPrefs(filePath);
    }

    @Override
    public void saveUserPrefs(UserPrefs userPrefs) throws IOException {
        saveUserPrefs(userPrefs, filePath);
    }

    @Override
    public void setUserPrefsFilePath(String filePath) {
        this.filePath = filePath;
    }

    /**
     * Similar to {@link #readUserPrefs()}
     * @param prefsFilePath location of the data. Cannot be null.
     * @throws DataConversionException if the file format is not as expected.
     */
    public Optional<UserPrefs> readUserPrefs(String prefsFilePath) throws DataConversionException {
        assert prefsFilePath != null;

        File prefsFile = new File(prefsFilePath);

        if (!prefsFile.exists()) {
            logger.info("Prefs file "  + prefsFile + " not found");
            return Optional.empty();
        }

        UserPrefs prefs;

        try {

            UserPrefs.JsonObject jsonObject = FileUtil.deserializeObjectFromJsonFile(prefsFile, UserPrefs.JsonObject.class);
            prefs = new UserPrefs();
            prefs.setJsonObject(jsonObject);

        } catch (IOException e) {
            logger.warning("Error reading from prefs file " + prefsFile + ": " + e);
            throw new DataConversionException(e);
        }

        return Optional.of(prefs);
    }

    /**
     * Similar to {@link #saveUserPrefs(UserPrefs)}
     * @param prefsFilePath location of the data. Cannot be null.
     */
    public void saveUserPrefs(UserPrefs userPrefs, String prefsFilePath) throws IOException {
        assert userPrefs != null;
        assert prefsFilePath != null;

        FileUtil.serializeObjectToJsonFile(new File(prefsFilePath), userPrefs.getJsonObject());
    }
}
```
###### \java\seedu\commando\storage\Storage.java
``` java

/**
 * API of the Storage component
 */
public interface Storage extends ToDoListStorage, UserPrefsStorage {}
```
###### \java\seedu\commando\storage\StorageManager.java
``` java
/**
 * Concrete implementation of {@link Storage} for the Storage component.
 * Reads data from and writes data to the file system
 */
public class StorageManager extends ComponentManager implements Storage {
    private static final Logger logger = LogsCenter.getLogger(StorageManager.class);
    private ToDoListStorage toDoListStorage;
    private UserPrefsStorage userPrefsStorage;

    public StorageManager(String toDoListFilePath, String userPrefsFilePath) {
        this(new XmlToDoListStorage(toDoListFilePath), new JsonUserPrefsStorage(userPrefsFilePath));
    }

    public StorageManager(ToDoListStorage toDoListStorage, UserPrefsStorage userPrefsStorage) {
        super();
        this.toDoListStorage = toDoListStorage;
        this.userPrefsStorage = userPrefsStorage;
    }

    //================================================================================
    // CRUD user prefs operations
    //================================================================================

    @Override
    public Optional<UserPrefs> readUserPrefs() throws DataConversionException, IOException {
        return userPrefsStorage.readUserPrefs();
    }

    @Override
    public void saveUserPrefs(UserPrefs userPrefs) throws IOException {
        userPrefsStorage.saveUserPrefs(userPrefs);
    }

    @Override
    public void setUserPrefsFilePath(String filePath) {
        userPrefsStorage.setUserPrefsFilePath(filePath);
    }

    //================================================================================
    // CRUD to-do list operations
    //================================================================================

    @Override
    public String getToDoListFilePath() {
        return toDoListStorage.getToDoListFilePath();
    }

    @Override
    public Optional<ReadOnlyToDoList> readToDoList() throws DataConversionException, IOException {
        return readToDoList(toDoListStorage.getToDoListFilePath());
    }

    @Override
    public Optional<ReadOnlyToDoList> readToDoList(String filePath) throws DataConversionException, IOException {
        logger.fine("Attempting to read data from file: " + filePath);
        return toDoListStorage.readToDoList(filePath);
    }

    @Override
    public void saveToDoList(ReadOnlyToDoList toDoList) throws IOException {
        saveToDoList(toDoList, toDoListStorage.getToDoListFilePath());
    }

    @Override
    public void saveToDoList(ReadOnlyToDoList toDoList, String filePath) throws IOException {
        logger.fine("Attempting to write to data file: " + filePath);
        toDoListStorage.saveToDoList(toDoList, filePath);
        raise(new ToDoListSavedEvent(filePath)); // post event that to-do list has been saved to the file system
    }

	@Override
	public void setToDoListFilePath(String path) {
		logger.info("Change the to-do list file path to " + path);
		toDoListStorage.setToDoListFilePath(path);
	}
}
```
###### \java\seedu\commando\storage\ToDoListStorage.java
``` java
/**
 * Represents a storage for {@link ToDoList}.
 */
public interface ToDoListStorage {

    /**
     * Returns the file path of the data file.
     */
    String getToDoListFilePath();
    
    /**
     * Set the file path of the data file to another location
     */
    void setToDoListFilePath(String path);

    /**
     * Returns to-do list data data as a {@link ReadOnlyToDoList}.
     *   Returns {@code Optional.empty()} if storage file is not found.
     * @throws DataConversionException if the data in storage is not in the expected format.
     * @throws IOException if there was any problem when reading from the storage.
     */
    Optional<ReadOnlyToDoList> readToDoList() throws DataConversionException, IOException;

    /**
     * @see #getToDoListFilePath()
     */
    Optional<ReadOnlyToDoList> readToDoList(String filePath) throws DataConversionException, IOException;

    /**
     * Saves the given {@link ReadOnlyToDoList} to the storage.
     * @param toDoList cannot be null.
     * @throws IOException if there was any problem writing to the file.
     */
    void saveToDoList(ReadOnlyToDoList toDoList) throws IOException;

    /**
     * @see #saveToDoList(ReadOnlyToDoList)
     */
    void saveToDoList(ReadOnlyToDoList toDoList, String filePath) throws IOException;

}
```
###### \java\seedu\commando\storage\UserPrefsStorage.java
``` java
/**
 * Represents a storage for {@link seedu.commando.model.UserPrefs}.
 */
public interface UserPrefsStorage {

    /**
     * Returns UserPrefs data from storage.
     *   Returns {@code Optional.empty()} if storage file is not found.
     * @throws DataConversionException if the data in storage is not in the expected format.
     * @throws IOException if there was any problem when reading from the storage.
     */
    Optional<UserPrefs> readUserPrefs() throws DataConversionException, IOException;

    /**
     * Saves the given {@link seedu.commando.model.UserPrefs} to the storage.
     * @param userPrefs cannot be null.
     * @throws IOException if there was any problem writing to the file.
     */
    void saveUserPrefs(UserPrefs userPrefs) throws IOException;

    void setUserPrefsFilePath(String filePath);
}
```
###### \java\seedu\commando\storage\XmlAdaptedToDo.java
``` java

/**
 * JAXB-friendly version of the to-do
 */
class XmlAdaptedToDo {
    private static final Logger logger = LogsCenter.getLogger(XmlAdaptedToDo.class);
    private static final DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
    private static final String MaxDateString = "MAX";
    private static final String MinDateString = "MIN";

    @XmlElement(required = true)
    private String title;
    @XmlElement(required = true)
    private String dueDate;
    @XmlElement(required = true)
    private String dateRangeStart;
    @XmlElement(required = true)
    private String dateRangeEnd;
    @XmlElement(required = true)
    private String dateCreated;
    @XmlElement(required = true)
    private String dateFinished;
    @XmlElement(required = true)
    private String dateRangeRecurrence;
    @XmlElement(required = true)
    private String dueDateRecurrence;

    @XmlElement
    private Set<String> tagged;

    /**
     * No-arg constructor for JAXB use.
     */
    public XmlAdaptedToDo() {
    }

    /**
     * Converts a given to-do into this class for JAXB use.
     */
    public XmlAdaptedToDo(ReadOnlyToDo toDo) {
        title = toDo.getTitle().value;

        if (toDo.getDateRange().isPresent()) {
            dateRangeStart = stringifyDateTime(toDo.getDateRange().get().startDate);
            dateRangeEnd = stringifyDateTime(toDo.getDateRange().get().endDate);
            dateRangeRecurrence = toDo.getDateRange().get().recurrence.toString();
        }

        if (toDo.getDueDate().isPresent()) {
            dueDate = stringifyDateTime(toDo.getDueDate().get().value);
            dueDateRecurrence = toDo.getDueDate().get().recurrence.toString();
        }

        if (toDo.getDateFinished().isPresent()) {
            dateFinished = stringifyDateTime(toDo.getDateFinished().get());
        }

        dateCreated = stringifyDateTime(toDo.getDateCreated());
        tagged = toDo.getTags().stream().map(tag -> tag.value).collect(Collectors.toSet());
    }

    /**
     * Converts this jaxb-friendly adapted ToDo object into the model's to-do
     *
     * @throws IllegalValueException if there were any data constraints violated in the adapted ToDo
     */
    public ToDo toModelType() throws IllegalValueException {
        final Title title = new Title(this.title);
        ToDo todo = new ToDo(title);

        if (this.tagged != null) {
            final Set<Tag> toDoTags = this.tagged.stream().map(Tag::new).collect(Collectors.toSet());

            todo.setTags(toDoTags);
        }

        // Check if the value is empty
        if (dueDate != null) {
            try {
                todo.setDueDate(new DueDate(
                    parseDateTime(dueDate),
                    parseRecurrence(dueDateRecurrence)
                ));
            } catch (DateTimeParseException exception) {
                // invalid due date, log it for debugging
                logger.warning("Unable to parse due date: " + dueDate);
            }
        }

        // Check if the dateRange is empty
        if (dateRangeStart != null && dateRangeEnd != null) {
            try {
                todo.setDateRange(new DateRange(
                    parseDateTime(dateRangeStart),
                    parseDateTime(dateRangeEnd),
                    parseRecurrence(dateRangeRecurrence)
                ));
            } catch (DateTimeParseException exception) {
                // invalid date range, log it for debugging
                logger.warning("Unable to parse date range: " + dateRangeStart + " - " + dateRangeEnd);
            }
        }

        // Check if the date finished is empty
        if (dateFinished != null) {
            try {
                todo.setDateFinished(parseDateTime(dateFinished));
            } catch (DateTimeParseException exception) {
                // invalid date finished, log it for debugging
                logger.warning("Unable to parse date finished: " + dateFinished);
            }
        }

        // Check if the date created is empty
        if (dateCreated != null) {
            try {
                todo.setDateCreated(parseDateTime(dateCreated));
            } catch (DateTimeParseException exception) {
                // invalid date created, log it for debugging
                logger.warning("Unable to parse date created: " + dateCreated);
            }
        }

        return todo;
    }

    private static Recurrence parseRecurrence(String recurrenceString) {
        Recurrence validRecurrence = Recurrence.None;
        if (recurrenceString != null) {
            try {
                validRecurrence = Recurrence.valueOf(recurrenceString);
            } catch (IllegalArgumentException exception) {
                // invalid recurrence, log it for debugging
                logger.warning("Unable to parse recurrence: " + recurrenceString);
            }
        }

        return validRecurrence;
    }

    private static LocalDateTime parseDateTime(String dateTimeString) {
        if (dateTimeString.equals(MaxDateString)) {
            return LocalDateTime.MAX;
        } else if (dateTimeString.equals(MinDateString)) {
            return LocalDateTime.MIN;
        } else {
            return LocalDateTime.parse(dateTimeString, dateFormatter);
        }
    }

    private static String stringifyDateTime(LocalDateTime localDateTime) {
       if (localDateTime.equals(LocalDateTime.MAX)) {
           return MaxDateString;
       } else if (localDateTime.equals(LocalDateTime.MIN)) {
           return MinDateString;
       } else {
           return dateFormatter.format(localDateTime);
       }
    }
}
```
###### \java\seedu\commando\storage\XmlFileStorage.java
``` java
/**
 * Stores ToDoList data in an XML file
 */
public class XmlFileStorage {
    /**
     * Saves the given toDoList data to the specified file.
     */
    public static void saveDataToFile(File file, XmlSerializableToDoList toDoList)
            throws FileNotFoundException {
        try {
            XmlUtil.saveDataToFile(file, toDoList);
        } catch (JAXBException e) {
            assert false : "Unexpected exception " + e.getMessage();
        }
    }

    /**
     * Returns toDoList in the file or an empty toDoList
     */
    public static XmlSerializableToDoList loadDataFromSaveFile(File file)
        throws DataConversionException, FileNotFoundException {
        try {
            return XmlUtil.getDataFromFile(file, XmlSerializableToDoList.class);
        } catch (JAXBException exception) {
            throw new DataConversionException(exception);
        }
    }
}
```
###### \java\seedu\commando\storage\XmlSerializableToDoList.java
``` java
/**
 * An Immutable ToDoList that is serializable to XML format
 */
@XmlRootElement(name = "todolist")
public class XmlSerializableToDoList {

    @XmlElement
    private List<XmlAdaptedToDo> toDos = new ArrayList<>();

    /**
     * Empty constructor required for marshalling
     */
    public XmlSerializableToDoList() {
    }

    /**
     * Conversion
     */
    public XmlSerializableToDoList(ReadOnlyToDoList toDos) {
        this.toDos.addAll(toDos.getToDos().stream().map(XmlAdaptedToDo::new).collect(Collectors.toList()));
    }

    public ReadOnlyToDoList getToDos() throws IllegalValueException {
        ToDoList toDoList = new ToDoList();

        for (XmlAdaptedToDo xmlAdaptedToDo : toDos) {
            toDoList.add(xmlAdaptedToDo.toModelType());
        }

        return toDoList;
    }
}
```
###### \java\seedu\commando\storage\XmlToDoListStorage.java
``` java
/**
 * A class to access to-do list data stored as an xml file on the hard disk.
 */
public class XmlToDoListStorage implements ToDoListStorage {
    private static final Logger logger = LogsCenter.getLogger(XmlToDoListStorage.class);
    private String filePath;

    public XmlToDoListStorage(String filePath){
        this.filePath = filePath;
    }

    public String getToDoListFilePath(){
        return filePath;
    }

    /**
     * Reads the to-do list data at {@param filePath}
     * @param filePath location to read the to-do list. Must be non-null
     * @throws DataConversionException if the file is not in the correct format.
     */
    public Optional<ReadOnlyToDoList> readToDoList(String filePath) throws DataConversionException, FileNotFoundException {
        assert filePath != null;

        File toDoListFile = new File(filePath);

        if (!toDoListFile.exists()) {
            logger.info("To-do list data file "  + toDoListFile + " not found");
            return Optional.empty();
        } else {
            logger.info("Using to-do list data file " + toDoListFile);
        }

        XmlSerializableToDoList xmlToDoList = XmlFileStorage.loadDataFromSaveFile(new File(filePath));

        try {
            ToDoList toDoList = new ToDoList(xmlToDoList.getToDos());
            return Optional.of(toDoList);

        } catch (IllegalValueException exception) {
            throw new DataConversionException(exception);
        }
    }

    /**
     * Saves the to-do list data to {@param filePath}
     * @param toDoList to-do list to save. Must be non-null
     * @param filePath location to save the to-do list. Must be non-null
     */
    public void saveToDoList(ReadOnlyToDoList toDoList, String filePath) throws IOException {
        assert toDoList != null;
        assert filePath != null;

        File file = new File(filePath);
        FileUtil.createIfMissing(file);
        XmlFileStorage.saveDataToFile(file, new XmlSerializableToDoList(toDoList));
    }

    /**
     * Reads the to-do list from storage
     */
    @Override
    public Optional<ReadOnlyToDoList> readToDoList() throws DataConversionException, IOException {
        return readToDoList(filePath);
    }

    /**
     * Saves the to-do list to storage
     * @param toDoList to-do list to save. Must be non-null
     */
    @Override
    public void saveToDoList(ReadOnlyToDoList toDoList) throws IOException {
        assert toDoList != null;

        saveToDoList(toDoList, filePath);
    }

	@Override
	public void setToDoListFilePath(String path) {
		assert path != null;

		this.filePath = path;
	}
}
```
