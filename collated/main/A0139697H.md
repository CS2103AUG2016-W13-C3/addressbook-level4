# A0139697H
###### \java\seedu\commando\commons\core\Messages.java
``` java
/**
 * Container for user visible messages.
 */
public class Messages {
    public static final String HELP_TOPICS = "add | edit | delete | find | list | clear | finish | unfinish | recall | undo | redo | faq | datetime | cheatsheet";
    public static final String DATE_FORMAT = "Date Time Formats: 9 jan 2018 23:59 | Jan 9 2019 1900h | coming friday morning | today 23:59";
    public static final String HELP_COMMAND_FORMAT = ">> help\n"
        + ">> help <topic>\n"
        + "Available topics: " + HELP_TOPICS;

```
###### \java\seedu\commando\logic\commands\AddCommand.java
``` java

/**
 * Adds a to-do to the to-do list.
 */
public class AddCommand extends Command {
    public static final String COMMAND_WORD = "add";

    // To-do that is going to be added
    private final ToDo toDo;

    /**
     * Initializes an add command.
     *
     * @param title title of to-do to add, non-null
     */
    public AddCommand(Title title) {
        assert title != null;

        toDo = new ToDo(title);
    }

    @Override
    public CommandResult execute() throws NoModelException {
        Model model = getModel();

        try {
            ensureOnlyDueDateOrDateRangePresent();

            model.changeToDoList(new ToDoListChange(
                new ToDoList().add(toDo),
                new ToDoList()
            ));

            return new CommandResult(getFeedback());

        } catch (IllegalValueException exception) {
            return new CommandResult(exception.getMessage(), true);
        }
    }

    private String getFeedback() {
        String feedback = String.format(Messages.ADD_COMMAND, toDo.getTitle().toString());

        // If event already over, warn user
        if (toDo.getDateRange().isPresent()
            && toDo.getDateRange().get().endDate.isBefore(LocalDateTime.now())) {
            feedback += "\n" + Messages.ADD_COMMAND_EVENT_OVER_WARNING;
        }

        return feedback;
    }

    private void ensureOnlyDueDateOrDateRangePresent() throws IllegalValueException {
        // Ensure to-do doesn't have both duedate and daterange
        if (toDo.getDateRange().isPresent() && toDo.getDueDate().isPresent()) {
            throw new IllegalValueException(Messages.TODO_CANNOT_HAVE_DUEDATE_AND_DATERANGE);
        }
    }

    /**
     * Sets the date range of the to-do to be added, must be non-null.
     *
     * @param dateRange date range to set
     */
    public void setDateRange(DateRange dateRange) {
        assert dateRange != null;

        toDo.setDateRange(dateRange);
    }

    /**
     * Sets the due date of the to-do to be added, must be non-null.
     *
     * @param dueDate due date to set
     */
    public void setDueDate(DueDate dueDate) {
        assert dueDate != null;

        toDo.setDueDate(dueDate);
    }

    /**
     * Gets the title of the to-do to be added.
     *
     * @return optional of title of to-do to be added, empty if none
     */
    public Title getTitle() {
        return toDo.getTitle();
    }

    /**
     * Sets the tags of the to-do to be added, must be non-null.
     *
     * @param tags set of tags to set
     */
    public void setTags(Set<Tag> tags) {
        assert tags != null;

        toDo.setTags(tags);
    }
}
```
###### \java\seedu\commando\logic\commands\ClearCommand.java
``` java
/**
 * Clears the to-do list
 */
public class ClearCommand extends Command {

    public static final String COMMAND_WORD = "clear";

    public ClearCommand() {}

    @Override
    public CommandResult execute() throws NoModelException {
        Model model = getModel();

        try {
            // Delete all to-dos
            model.changeToDoList(new ToDoListChange(
                new ToDoList(),
                model.getToDoList()
            ));

            return new CommandResult(Messages.TODO_LIST_CLEARED);
        } catch (IllegalValueException exception) {
            return new CommandResult(exception.getMessage(), true);
        }
    }
}
```
###### \java\seedu\commando\logic\commands\Command.java
``` java

/**
 * Represents a command with hidden internal logic and the ability to be executed.
 */
public abstract class Command {

    private EventsCenter eventsCenter;
    private Model model;

    /**
     * Sets the EventsCenter for the command.
     * {@param eventsCenter} must be non-null.
     */
    public void setEventsCenter(EventsCenter eventsCenter) {
        assert eventsCenter != null;

        this.eventsCenter = eventsCenter;
    }

    /**
     * Sets the Model for the command.
     * {@param model} must be non-null.
     */
    public void setModel(Model model) {
        assert model != null;

        this.model = model;
    }

    public static class NoEventsCenterException extends Exception {
    }

    public static class NoModelException extends Exception {
    }

    /**
     * Gets the events center set by {@link #setEventsCenter(EventsCenter)}.
     *
     * @return events center of this command
     * @throws NoEventsCenterException if {@link #setEventsCenter(EventsCenter)} hasn't been called
     */
    protected EventsCenter getEventsCenter() throws NoEventsCenterException {
        if (eventsCenter == null) {
            throw new NoEventsCenterException();
        }

        return eventsCenter;
    }

    /**
     * Gets the model set by {@link #setModel(Model)}}.
     *
     * @return model of this command
     * @throws NoModelException if {@link #setModel(Model)} hasn't been called
     */
    protected Model getModel() throws NoModelException {
        if (model == null) {
            throw new NoModelException();
        }

        return model;
    }

    /**
     * Executes the command.
     *
     * @return result of the command packaged in {@link CommandResult}
     */
    public abstract CommandResult execute() throws NoModelException, NoEventsCenterException;
}
```
###### \java\seedu\commando\logic\commands\CommandFactory.java
``` java

/**
 * Maps and builds commands from input strings, using {@link CommandParser}.
 * In charge of splitting up input strings to required parts for commands.
 */
public class CommandFactory {
    private static final String KEYWORD_DELETE_TIME = "time";
    private static final String KEYWORD_DELETE_TAG = "tag";
    private static final String KEYWORD_DELETE_RECURRENCE = "recurrence";

    private CommandParser commandParser = new CommandParser();

    public static class InvalidCommandFormatException extends Exception {
        public final String command;

        public InvalidCommandFormatException(String message, String command) {
            super(message);
            this.command = command;
        }
    }

    public static class UnknownCommandWordException extends Exception {
        public final String commandWord;

        UnknownCommandWordException(String commandWord) {
            this.commandWord = commandWord;
        }
    }

    public static class MissingCommandWordException extends Exception {}

    /**
     * Interprets an input string as a command, initializes it, and returns it.
     *
     * @return instance of a command
     * @throws InvalidCommandFormatException if command format is invalid
     * @throws UnknownCommandWordException if command word is unknown
     * @throws MissingCommandWordException if command word is missing
     */
    public Command build(String inputString) throws InvalidCommandFormatException,
        UnknownCommandWordException, MissingCommandWordException {
        commandParser.setInput(inputString);

        // Check if command word exists
        Optional<String> commandWord = commandParser.extractWord();

        if (!commandWord.isPresent()) {
            throw new MissingCommandWordException();
        }

        String processedCommandWord = commandWord.get().toLowerCase();
        try {
            switch (processedCommandWord) {
                case AddCommand.COMMAND_WORD: return buildAddCommand();
                case DeleteCommand.COMMAND_WORD: return buildDeleteCommand();
                case FinishCommand.COMMAND_WORD: return buildFinishCommand();
                case UnfinishCommand.COMMAND_WORD: return buildUnfinishCommand();
                case FindCommand.COMMAND_WORD: return buildFindCommand();
                case ExitCommand.COMMAND_WORD: return buildExitCommand();
                case ClearCommand.COMMAND_WORD: return buildClearCommand();
                case HelpCommand.COMMAND_WORD: return buildHelpCommand();
                case EditCommand.COMMAND_WORD: return buildEditCommand();
                case UndoCommand.COMMAND_WORD: return buildUndoCommand();
                case RedoCommand.COMMAND_WORD: return buildRedoCommand();
                case StoreCommand.COMMAND_WORD: return buildStoreCommand();
                case ExportCommand.COMMAND_WORD: return buildExportCommand();
                case ImportCommand.COMMAND_WORD: return buildImportCommand();
                case RecallCommand.COMMAND_WORD: return buildRecallCommand();
                case ListCommand.COMMAND_WORD: return buildListCommand();
                default: throw new UnknownCommandWordException(processedCommandWord);
            }
        } catch (IllegalValueException e) {
            throw new InvalidCommandFormatException(e.getMessage(), processedCommandWord);
        }
    }

    private Command buildRecallCommand() {
        RecallCommand command = new RecallCommand();

        // Extract tags
        Set<Tag> tags = commandParser.extractTrailingTags();
        if (!tags.isEmpty()) {
            command.setTags(tags);
        }

        // Try to find keywords
        Set<String> keywords = commandParser.extractWords().stream().collect(Collectors.toSet());
        command.setKeywords(keywords);

        return command;
    }


    private Command buildExitCommand() throws IllegalValueException {
        ensureInputIsEmpty(ExitCommand.COMMAND_WORD);

        return new ExitCommand();
    }

```
###### \java\seedu\commando\logic\commands\CommandFactory.java
``` java
    private Command buildAddCommand() throws IllegalValueException {
        // Check if quoted title exists
        Optional<String> quotedTitle = commandParser.extractQuotedTitle();

        // Extract tags
        Set<Tag> tags = commandParser.extractTrailingTags();

        // Extract date range, if exists
        Optional<DateRange> dateRange = extractToDoDateRange();

        // Extract due date, if exists
        Optional<DueDate> dueDate = commandParser.extractTrailingDueDate();

        // Initialize command
        // Extract title, if there was no quoted title
        // Otherwise, use the quoted title
        AddCommand command;
        if (quotedTitle.isPresent()) {
            command = new AddCommand(new Title(quotedTitle.get()));
        } else {
            String title = commandParser.extractText().orElseThrow(() -> new IllegalValueException(Messages.MISSING_TODO_TITLE));
            command = new AddCommand(new Title(title));
        }

        // Put in fields
        if (!tags.isEmpty()) {
            command.setTags(tags);
        }

        dueDate.ifPresent(command::setDueDate);
        dateRange.ifPresent(command::setDateRange);

        ensureInputIsEmpty(AddCommand.COMMAND_WORD);

        return command;
    }

    private Command buildDeleteCommand() throws IllegalValueException {
        List<Integer> indices = extractIndices();

        DeleteCommand deleteCommand = new DeleteCommand(indices);

        // check for fields
        List<String> words = commandParser.extractWords();

        int fieldsCount = 0;

        if (words.contains(KEYWORD_DELETE_TAG)) {
            deleteCommand.deletesTags();
            fieldsCount++;
        }

        if (words.contains(KEYWORD_DELETE_TIME)) {
            deleteCommand.deletesTime();
            fieldsCount++;
        }

        if (words.contains(KEYWORD_DELETE_RECURRENCE)) {
            deleteCommand.deletesRecurrence();
            fieldsCount++;
        }

        // If there were extra words besides the fields, invalid command format
        if (fieldsCount != words.size()) {
            throw new IllegalValueException(String.format(Messages.INVALID_COMMAND_FORMAT, DeleteCommand.COMMAND_WORD));
        }

        return deleteCommand;
    }

    private Command buildFinishCommand() throws IllegalValueException {
        List<Integer> indices = extractIndices();
        ensureInputIsEmpty(FinishCommand.COMMAND_WORD);

        return new FinishCommand(indices);
    }

    private Command buildUnfinishCommand() throws IllegalValueException {
        List<Integer> indices = extractIndices();
        ensureInputIsEmpty(UnfinishCommand.COMMAND_WORD);

        return new UnfinishCommand(indices);
    }

    private Command buildFindCommand() {
        FindCommand command = new FindCommand();

        // Extract tags
        Set<Tag> tags = commandParser.extractTrailingTags();
        if (!tags.isEmpty()) {
            command.setTags(tags);
        }

        // Try to find keywords
        Set<String> keywords = commandParser.extractWords().stream().collect(Collectors.toSet());
        command.setKeywords(keywords);

        return command;
    }

    private Command buildClearCommand() throws IllegalValueException {
        ensureInputIsEmpty(ClearCommand.COMMAND_WORD);

        return new ClearCommand();
    }

    private Command buildHelpCommand() {
        // Try to find command word
        Optional<String> word = commandParser.extractText();

        if (word.isPresent()) {
            return new HelpCommand(word.get());
        } else {
            return new HelpCommand();
        }
    }

    private Command buildEditCommand() throws IllegalValueException {
        int index = commandParser.extractInteger().orElseThrow(
            () -> new IllegalValueException(Messages.MISSING_TODO_ITEM_INDEX)
        );

        Optional<String> quotedTitle = commandParser.extractQuotedTitle();

        EditCommand command = new EditCommand(index);

        // Extract tags
        Set<Tag> tags = commandParser.extractTrailingTags();

        // Put in fields
        if (!tags.isEmpty()) {
            command.setTags(tags);
        }
        extractToDoDateRange().ifPresent(command::setDateRange);
        commandParser.extractTrailingDueDate().ifPresent(command::setDueDate);

        // Try to extract title, if there was no quoted title
        // Otherwise, use the quoted title
        if (quotedTitle.isPresent()) {
            command.setTitle(new Title(quotedTitle.get()));
        } else {
            commandParser.extractText().ifPresent(
                title -> command.setTitle(new Title(title))
            );
        }

        ensureInputIsEmpty(EditCommand.COMMAND_WORD);

        return command;
    }

```
###### \java\seedu\commando\logic\commands\CommandResult.java
``` java

/**
 * Represents the result of a command execution.
 */
public class CommandResult {
    private final String feedback;
    private boolean hasError;

    /**
     * Initializes the result of a command.
     *
     * @param feedback feedback to be shown to user
     * @param hasError if there was an error and command failed
     */
    public CommandResult(String feedback, boolean hasError) {
        assert feedback != null;

        this.feedback = feedback;
        this.hasError = hasError;
    }

    /**
     * Initializes the result of successful command.
     */
    public CommandResult(String feedback) {
        this(feedback, false);
    }

    public String getFeedback() {
        return feedback;
    }

    public boolean hasError() {
        return hasError;
    }
}
```
###### \java\seedu\commando\logic\commands\DeleteCommand.java
``` java

/**
 * Deletes to-do(s), or their fields.
 */
public class DeleteCommand extends Command {

    public static final String COMMAND_WORD = "delete";

    private final List<Integer> toDoIndices;
    private boolean ifDeleteTime = false;
    private boolean ifDeleteTags = false;
    private boolean ifDeleteRecurrence = false;

    /**
     * Initializes a delete command.
     *
     * @param toDoIndices list of indices of UI to-dos to target, non-null
     */
    public DeleteCommand(List<Integer> toDoIndices) {
        assert toDoIndices != null;

        this.toDoIndices = toDoIndices;
    }

```
###### \java\seedu\commando\logic\commands\EditCommand.java
``` java

/**
 * Edits a to-do in the current to-do list.
 */
public class EditCommand extends Command {
    public static final String COMMAND_WORD = "edit";

    private final int toDoIndex;
    private Title title = null;
    private DateRange dateRange = null;
    private DueDate dueDate = null;
    private Set<Tag> tags = null;

    /**
     * Initializes an edit command.
     *
     * @param toDoIndex index of UI to-do to edit
     */
    public EditCommand(int toDoIndex) {
        this.toDoIndex = toDoIndex;
    }

    public CommandResult execute() throws NoModelException {
        Model model = getModel();

        try {
            ReadOnlyToDo toDoToEdit = getToDoAtIndex(model, toDoIndex);
            ToDo editedToDo = getEditedToDo(toDoToEdit);
            ensureToDoEdited(toDoToEdit, editedToDo);
            ensureOnlyDueDateOrDateRangePresent(editedToDo);

            model.changeToDoList(new ToDoListChange(
                new ToDoList().add(editedToDo),
                new ToDoList().add(toDoToEdit)
            ));

            return new CommandResult(getFeedback(editedToDo));

        } catch (IllegalValueException exception) {
            return new CommandResult(exception.getMessage(), true);
        }
    }

    private String getFeedback(ToDo editedToDo) {
        String feedback = String.format(Messages.EDIT_COMMAND, editedToDo.getTitle().toString());

        // If event already over, warn user
        if (editedToDo.getDateRange().isPresent()
            && editedToDo.getDateRange().get().endDate.isBefore(LocalDateTime.now())) {
            feedback += "\n" + Messages.EDIT_COMMAND_EVENT_OVER_WARNING;
        }
        return feedback;
    }

    private void ensureToDoEdited(ReadOnlyToDo toDoToEdit, ToDo editedToDo) throws IllegalValueException {
        // Check if to-do has changed
        if (editedToDo.isSameStateAs(toDoToEdit)) {
            throw new IllegalValueException(Messages.EDIT_COMMAND_NO_EDITS);
        }
    }

    private ToDo getEditedToDo(ReadOnlyToDo toDoToEdit) {
        // Copy original to-do
        ToDo newToDo = new ToDo(toDoToEdit);

        // Set fields if exist
        if (title != null) {
            newToDo.setTitle(title);
        }

        if (dueDate != null) {
            newToDo.setDueDate(dueDate);
        }

        if (dateRange != null) {
            newToDo.setDateRange(dateRange);
        }

        if (tags != null) {
            newToDo.setTags(tags);
        }

        return newToDo;
    }

    private void ensureOnlyDueDateOrDateRangePresent(ReadOnlyToDo toDo) throws IllegalValueException {
        // Ensure to-do doesn't have both duedate and daterange
        if (toDo.getDateRange().isPresent() && toDo.getDueDate().isPresent()) {
            throw new IllegalValueException(Messages.TODO_CANNOT_HAVE_DUEDATE_AND_DATERANGE);
        }
    }

    private ReadOnlyToDo getToDoAtIndex(Model model, int toDoIndex) throws IllegalValueException {
        Optional<UiToDo> toDoToEdit = model.getUiToDoAtIndex(toDoIndex);

        if (!toDoToEdit.isPresent()) {
            throw new IllegalValueException(String.format(Messages.TODO_ITEM_INDEX_INVALID, toDoIndex));
        }

        return toDoToEdit.get();
    }

    /**
     * Sets the title for the target to-do, must be non-null.
     *
     * @param title title to set
     */
    public void setTitle(Title title) {
        assert title != null;

        this.title = title;
    }

    /**
     * Sets the date range for the target to-do, must be non-null.
     *
     * @param dateRange date range to set
     */
    public void setDateRange(DateRange dateRange) {
        assert dateRange != null;

        this.dateRange = dateRange;
    }

    /**
     * Sets the due date for the target to-do, must be non-null.
     *
     * @param dueDate due date to set
     */
    public void setDueDate(DueDate dueDate) {
        assert dueDate != null;

        this.dueDate = dueDate;
    }

    /**
     * Sets the tags to replace for the target to-do, must be non-null.
     *
     * @param tags tags to set
     */
    public void setTags(Set<Tag> tags) {
        assert tags != null;

        this.tags = tags;
    }
}
```
###### \java\seedu\commando\logic\commands\ExitCommand.java
``` java
/**
 * Terminates the program.
 */
public class ExitCommand extends Command {

    public static final String COMMAND_WORD = "exit";

    /**
     * Initializes an exit command.
     */
    public ExitCommand() {}

    @Override
    public CommandResult execute() throws NoEventsCenterException {
        EventsCenter eventsCenter = getEventsCenter();

        eventsCenter.post(new ExitAppRequestEvent());
        return new CommandResult(Messages.EXIT_APPLICATION);
    }
}
```
###### \java\seedu\commando\logic\commands\FindCommand.java
``` java

/**
 * Shows all unfinished to-dos, optionally filtering by keywords and tags.
 */
public class FindCommand extends Command {
    public static final String COMMAND_WORD = "find";

    private Set<String> keywords = Collections.emptySet();
    private Set<Tag> tags = Collections.emptySet();

    /**
     * Initializes a find command.
     */
    public FindCommand() {}

    /**
     * Asserts that {@code uiLogic} is non-null
     */
    @Override
    public CommandResult execute() throws NoModelException {
        Model model = getModel();

        if (keywords.isEmpty() && tags.isEmpty()) {
            // if no keywords or tags are provided, show all unfinished to-dos
            model.clearUiToDoListFilter(Model.FILTER_MODE.UNFINISHED);
            return new CommandResult(Messages.FIND_COMMAND_CLEAR);
        }

        model.setUiToDoListFilter(keywords, tags, Model.FILTER_MODE.UNFINISHED);

        // If no to-dos found in search
        if (model.getUiEvents().isEmpty() && model.getUiTasks().isEmpty()) {
            return new CommandResult(String.format(Messages.FIND_COMMAND_NO_TODOS, getSearchString()));
        }

        return new CommandResult(String.format(Messages.FIND_COMMAND, getSearchString()));
    }

    private String getSearchString() {
        Stream<String> keywordsStream = new TreeSet<>(keywords).stream();
        Stream<String> tagsStream = new TreeSet<>(tags).stream().map(Tag::toString);

        return "[" + Stream.concat(keywordsStream, tagsStream).collect(Collectors.joining(", ")) + "]";
    }

    /**
     * Sets the keywords for the command, must be non-null.
     *
     * @param keywords set of keywords to set
     */
    public void setKeywords(Set<String> keywords) {
        assert keywords != null;

        this.keywords = keywords;
    }

    /**
     * Sets the tags for the command, must be non-null.
     *
     * @param tags set of tags to set
     */
    public void setTags(Set<Tag> tags) {
        assert tags != null;

        this.tags = tags;
    }
}
```
###### \java\seedu\commando\logic\commands\HelpCommand.java
``` java

/**
 * Show the user guide in a new window, jumping to the appropriate
 * section of the user guide if necessary.
 */
public class HelpCommand extends Command {
    public static final String COMMAND_WORD = "help";

    private final String commandWord;

    /**
     * Shows general help.
     */
    public HelpCommand() {
        commandWord = "";
    }

    /**
     * Shows help for specific command word {@param commandWord}.
     */
    public HelpCommand(String commandWord) {
        this.commandWord = commandWord;
    }

    @Override
    public CommandResult execute() throws NoEventsCenterException {
        EventsCenter eventsCenter = getEventsCenter();

        if (commandWord.isEmpty()) {
            eventsCenter.post(new ShowHelpRequestEvent(""));
        } else {
            Optional<String> anchor = Config.getUserGuideAnchorForCommandWord(commandWord);

            // Check if the command word is recognized
            if (!anchor.isPresent()) {
                return new CommandResult(Messages.HELP_COMMAND_INVALID_TOPIC, true);
            }

            eventsCenter.post(new ShowHelpRequestEvent(anchor.get()));
        }

        return new CommandResult(String.format(Messages.HELP_WINDOW_SHOWN, commandWord));
    }
}
```
###### \java\seedu\commando\logic\commands\RecallCommand.java
``` java
/**
 * Shows all finished to-dos, optionally filtering by keywords and tags.
 */
public class RecallCommand extends Command {
    public static final String COMMAND_WORD = "recall";

    private Set<String> keywords = Collections.emptySet();
    private Set<Tag> tags = Collections.emptySet();

    /**
     * Initializes a recall command.
     */
    public RecallCommand() {}

    @Override
    public CommandResult execute() throws NoModelException {
        Model model = getModel();

        if (keywords.isEmpty() && tags.isEmpty()) {
            // if no keywords or tags are provided, show all finished to-dos
            model.clearUiToDoListFilter(Model.FILTER_MODE.FINISHED);
            return new CommandResult(Messages.RECALL_COMMAND_CLEAR);
        }

        model.setUiToDoListFilter(keywords, tags, Model.FILTER_MODE.FINISHED);

        // If no to-dos found in search
        if (model.getUiEvents().isEmpty() && model.getUiTasks().isEmpty()) {
            return new CommandResult(String.format(Messages.RECALL_COMMAND_NO_TODOS, getSearchString()));
        }

        return new CommandResult(String.format(Messages.RECALL_COMMAND, getSearchString()));
    }

    private String getSearchString() {
        Stream<String> keywordsStream = new TreeSet<>(keywords).stream();
        Stream<String> tagsStream = new TreeSet<>(tags).stream().map(Tag::toString);

        return "[" + Stream.concat(keywordsStream, tagsStream).collect(Collectors.joining(", ")) + "]";
    }


    /**
     * Sets the keywords for the command, must be non-null.
     *
     * @param keywords set of keywords to set
     */
    public void setKeywords(Set<String> keywords) {
        assert keywords != null;

        this.keywords = keywords;
    }

    /**
     * Sets the tags for the command, must be non-null.
     *
     * @param tags set of tags to set
     */
    public void setTags(Set<Tag> tags) {
        assert tags != null;

        this.tags = tags;
    }
}
```
###### \java\seedu\commando\logic\Logic.java
``` java

/**
 * API of the Logic component.
 */
public interface Logic {

    /**
     * Executes an input string as a command and returns the result.
     *
     * @param commandText input string as entered by the user to be parsed as a command
     * @return result of the command packaged in {@link CommandResult}
     */
    CommandResult execute(String commandText);

    /**
     * Returns observable read-only list of UI to-dos considered as events by {@link UiToDo#isEvent()}
     * to be displayed on the UI.
     * The ordering of the list is to be respected.
     *
     * @return an observable read-only list of {@link UiToDo} that are events
     */
    UnmodifiableObservableList<UiToDo> getUiEvents();

    /**
     * Returns observable read-only list of UI to-dos considered as tasks by {@link UiToDo#isTask()}
     * to be displayed on the UI.
     * The ordering of the list is to be respected.
     *
     * @return an observable read-only list of {@link UiToDo} that are tasks
     */
    UnmodifiableObservableList<UiToDo> getUiTasks();

    /**
     * Gets the full list of to-dos, read-only.
     *
     * @return the full list of to-dos, read-only
     */
    ReadOnlyToDoList getToDoList();
}
```
###### \java\seedu\commando\logic\LogicManager.java
``` java

/**
 * Concrete implementation of {@link Logic} for the Logic component.
 * Executes commands from the UI, using the API provided by Model and Storage.
 */
public class LogicManager extends ComponentManager implements Logic {
    private final Logger logger = LogsCenter.getLogger(LogicManager.class);

    private final Model model;
    private final Storage storage;
    private final UserPrefs userPrefs;
    private final CommandFactory commandFactory = new CommandFactory();

    public LogicManager(Model model, Storage storage, UserPrefs userPrefs) {
        this.model = model;
        this.storage = storage;
        this.userPrefs = userPrefs;
    }

    @Override
    public CommandResult execute(String commandText) {
        logger.info("User command: " + commandText + "");

        try {
            return executeCommand(commandText);
        } catch (CommandFactory.InvalidCommandFormatException e) {
            return getCommandResultForInvalidFormat(e);
        } catch (CommandFactory.UnknownCommandWordException e) {
            return new CommandResult(String.format(Messages.UNKNOWN_COMMAND, e.commandWord), true);
        } catch (CommandFactory.MissingCommandWordException e) {
            return new CommandResult(Messages.MISSING_COMMAND_WORD, true);
        }
    }

    @Override
    public UnmodifiableObservableList<UiToDo> getUiEvents() {
        return model.getUiEvents();
    }

    @Override
    public UnmodifiableObservableList<UiToDo> getUiTasks() {
        return model.getUiTasks();
    }

    @Override
    public ReadOnlyToDoList getToDoList() {
        return model.getToDoList();
    }

    /**
     * Called upon an event that the Model's to-do list has changed.
     *
     * It saves the current version of the to-do list to the hard disk at the default
     * to-do list filepath with Storage.
     *
     * Raises {@link DataSavingExceptionEvent} if there was an error during saving.
     */
    @Subscribe
    public void handleToDoListChangedEvent(ToDoListChangedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event, "Local data changed, saving to file"));

        try {
            storage.saveToDoList(event.toDoList);
        } catch (IOException e) {
            raise(new DataSavingExceptionEvent(e));
        }
    }

    /**
     * Called upon an event that the to-do list file path change has been requested.
     *
     * It changes to-do list file path in user prefs and storage and saves the
     * to-do data to that new file path with Storage.
     */
    @Subscribe
    public void handleToDoListFilePathRequestEvent(ToDoListFilePathChangeRequestEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));

        storage.setToDoListFilePath(event.path);

        try {
            storage.saveToDoList(model.getToDoList());
        } catch (IOException exception) {
            logger.warning("Failed to save to-do list data file: " + StringUtil.getDetails(exception));
        }

        userPrefs.setToDoListFilePath(event.path);
    }

    private CommandResult getCommandResultForInvalidFormat(CommandFactory.InvalidCommandFormatException e) {
        // If invalid command format, check if Messages has sample commands for that command
        // Append to exception message if there is
        Optional<String> commandFormatMessage = Messages.getCommandFormatMessage(e.command);
        if (commandFormatMessage.isPresent()) {
            return new CommandResult(e.getMessage() + "\n" + commandFormatMessage.get(), true);
        } else {
            return new CommandResult(e.getMessage(), true);
        }
    }

    private CommandResult executeCommand(String commandText)
        throws CommandFactory.InvalidCommandFormatException,
        CommandFactory.UnknownCommandWordException,
        CommandFactory.MissingCommandWordException {

        Command command = commandFactory.build(commandText);

        command.setEventsCenter(eventsCenter);
        command.setModel(model);

        try {
            return command.execute();
        } catch (Command.NoEventsCenterException | Command.NoModelException exception) {
            assert false : "there should always be EventsCenter or Model";
            return new CommandResult(exception.getMessage(), true);
        }
    }
}
```
###### \java\seedu\commando\logic\parser\CommandParser.java
``` java

/**
 * In charge of parsing an input command string, piece-wise, with the help of
 * {@link DateTimeParser}.
 * <p>
 * Methods modify the input string by extracting appropriate parts of it,
 * and input is always kept trimmed.
 */
public class CommandParser {
    public static final String KEYWORD_DATERANGE_START = "from";
    public static final String KEYWORD_DATERANGE_END = "to";
    public static final String KEYWORD_DATERANGE_DATE = "on";
    public static final String KEYWORD_DUEDATE = "by";
    public static final String RECURRENCE_REGEX = "daily|weekly|monthly|yearly";
    public static final String TAG_PREFIX = "#";
    public static final String QUOTE_CHARACTER = "`";

    // Pattern for "from ... to ... (recurrence)?"
    private static final Pattern DATERANGE_TWO_SIDED_PATTERN = Pattern.compile(
        "(?<left>.*)"
            + "(" + KEYWORD_DATERANGE_START + "\\s+" + "(?<start>(.+\\s+)?)" + KEYWORD_DATERANGE_END + "(?<end>(\\s+.+?)?))"
            + "(?<recurrence>(\\s+" + RECURRENCE_REGEX + ")?)$",
        Pattern.CASE_INSENSITIVE
    );

    // Pattern for "on ... (recurrence)?"
    private static final Pattern DATERANGE_SINGLE_DATE_PATTERN = Pattern.compile(
        "(?<left>.*)"
            + "(" + KEYWORD_DATERANGE_DATE + "\\s+(?<date>(.+?)?))"
            + "(?<recurrence>(\\s+" + RECURRENCE_REGEX + ")?)$",
        Pattern.CASE_INSENSITIVE
    );

    // Pattern for "from ... (recurrence)?"
    private static final Pattern DATERANGE_START_DATE_PATTERN = Pattern.compile(
        "(?<left>.*)(" + KEYWORD_DATERANGE_START + "\\s+(?<start>(.+?)))"
            + "(?<recurrence>(\\s+" + RECURRENCE_REGEX + ")?)$",
        Pattern.CASE_INSENSITIVE
    );

    // Pattern for "to ... (recurrence)?"
    private static final Pattern DATERANGE_END_DATE_PATTERN = Pattern.compile(
        "(?<left>.*)(" + KEYWORD_DATERANGE_END + "\\s+(?<end>(.+?)))"
            + "(?<recurrence>(\\s+" + RECURRENCE_REGEX + ")?)$",
        Pattern.CASE_INSENSITIVE
    );

    private static final Pattern DUEDATE_PATTERN = Pattern.compile(
        "(?<left>.*)" + KEYWORD_DUEDATE + "\\s+" + "(?<date>.+?)"
            + "(?<recurrence>(\\s+" + RECURRENCE_REGEX + ")?)$",
        Pattern.CASE_INSENSITIVE
    );

    private static final Pattern FIRST_WORD_PATTERN = Pattern.compile("^(?<word>\\S+)(?<left>.*?)$");
    private static final Pattern FIRST_QUOTED_TEXT_PATTERN = Pattern.compile("^" + QUOTE_CHARACTER + "(?<text>.*)" + QUOTE_CHARACTER + "(?<left>.*?)$");
    private static final Pattern FIRST_INTEGER_PATTERN = Pattern.compile("^(?<integer>-?\\d+)(?<left>.*?)$");

    private static final Pattern TAGS_PATTERN = Pattern.compile(
        "(?<left>.*?)(?<tags>((\\s+|^)" + TAG_PREFIX + "\\S*)+)$",
        Pattern.CASE_INSENSITIVE
    );
    private static final Pattern INDEXRANGE_PATTERN = Pattern.compile(
        "^(?<firstInt>-?\\d+)" + "\\s*" + "((to)|-)" + "\\s*" + "(?<secondInt>-?\\d+)(?<left>.*?)$",
        Pattern.CASE_INSENSITIVE
    );

    private String input;
    private DateTimeParser dateTimeParser = new DateTimeParser();

    /**
     * Set the current input the parser is working on, and resets
     * any contextual info from the last input.
     *
     * @param input input to set
     */
    public void setInput(String input) {
        this.input = input;
        dateTimeParser.resetContext();
    }

    /**
     * Gets current input the parser is working on.
     *
     * @return current input
     */
    public String getInput() {
        return input.trim();
    }

    /**
     * Checks whether current input trimmed is an empty string.
     *
     * @return return whether the input is empty
     */
    public boolean isInputEmpty() {
        return input.trim().isEmpty();
    }

    /**
     * Extract a trailing due date from the input.
     * <p>
     * Date range is defined by: "by (valid_datetime)" + optional " (valid_recurrence)",
     * and must be at the end of the string to be considered.
     *
     * @return optional of a due date if found, empty otherwise
     */
    public Optional<DueDate> extractTrailingDueDate() {
        final Matcher matcher = DUEDATE_PATTERN.matcher(input);

        if (matcher.find()) {
            String dateString = matcher.group("date");
            String recurrenceString = matcher.group("recurrence");

            // Parse datetime and recurrence
            Optional<DueDate> dueDate = parseDueDate(dateString, recurrenceString);

            // If legit date, extract from input and return due date
            if (dueDate.isPresent()) {
                input = matcher.group("left").trim();
                return dueDate;
            }
        }

        // Didn't find any matches
        return Optional.empty();
    }

    /**
     * Extract a trailing date range from the input of the form:
     * - "from (valid_datetime) to (valid_datetime)" + an optional "(valid_recurrence)"
     * and must be at the end of the string to be considered.
     *
     * @return optional of date range, empty if not found
     * @throws IllegalValueException if a trailing date range pattern is found but either one of the datetime is valid,
     *                               other invalid, or parsed DateRange is not invalid
     */
    public Optional<DateRange> extractTrailingTwoSidedDateRange() throws IllegalValueException {
        final Matcher matcher = DATERANGE_TWO_SIDED_PATTERN.matcher(input);

        // Find "from ... to ..."
        if (matcher.find()) {
            String recurrenceString = matcher.group("recurrence");
            String startString = matcher.group("start");
            String endString = matcher.group("end");

            Optional<DateRange> dateRange = parseDateRangeWithStartAndEnd(startString, endString, recurrenceString);

            // If legit date range, extract from input and return it
            if (dateRange.isPresent()) {
                input = matcher.group("left").trim();
                return dateRange;
            }
        }

        return Optional.empty();
    }

    /**
     * Extract a trailing date range from the input of the form:
     * - "on (valid_datetime)" + an optional "(valid_recurrence)"
     * and must be at the end of the string to be considered.
     *
     * @return optional of date range, empty if not found
     */
    public Optional<DateRange> extractTrailingSingleDateDateRange() {
        final Matcher matcher = DATERANGE_SINGLE_DATE_PATTERN.matcher(input);

        // Find "on ..."
        if (matcher.find()) {
            String recurrenceString = matcher.group("recurrence");
            String dateString = matcher.group("date");

            Optional<DateRange> dateRange = parseDateRangeWithSingleDate(dateString, recurrenceString);

            // If legit date range, extract from input and return it
            if (dateRange.isPresent()) {
                input = matcher.group("left").trim();
                return dateRange;
            }
        }

        return Optional.empty();
    }

    /**
     * Extract a trailing date range from the input of the form:
     * - "to (valid_datetime)" + an optional "(valid_recurrence)"
     * and must be at the end of the string to be considered.
     *
     * @return optional of date range, empty if not found
     */
    public Optional<DateRange> extractTrailingEndDateDateRange() {
        final Matcher matcher = DATERANGE_END_DATE_PATTERN.matcher(input);

        // Find "to ..."
        if (matcher.find()) {
            String recurrenceString = matcher.group("recurrence");
            String dateString = matcher.group("end");

            Optional<DateRange> dateRange = parseDateRangeWithEnd(dateString, recurrenceString);

            // If legit date range, extract from input and return it
            if (dateRange.isPresent()) {
                input = matcher.group("left").trim();
                return dateRange;
            }
        }

        return Optional.empty();
    }

    /**
     * Extract a trailing date range from the input of the form:
     * - "from (valid_datetime)" + an optional "(valid_recurrence)"
     * and must be at the end of the string to be considered.
     *
     * @return optional of date range, empty if not found
     */
    public Optional<DateRange> extractTrailingStartDateDateRange() {
        final Matcher matcher = DATERANGE_START_DATE_PATTERN.matcher(input);

        // Find "from ..."
        if (matcher.find()) {
            String recurrenceString = matcher.group("recurrence");
            String dateString = matcher.group("start");

            Optional<DateRange> dateRange = parseDateRangeWithStart(dateString, recurrenceString);

            // If legit date range, extract from input and return it
            if (dateRange.isPresent()) {
                input = matcher.group("left").trim();
                return dateRange;
            }
        }

        return Optional.empty();
    }

    /**
     * Extracts all text in input. Input of parser will be empty after this call.
     *
     * @return text extracted
     */
    public Optional<String> extractText() {
        String text = input.trim();
        input = "";

        return text.isEmpty() ? Optional.empty() : Optional.of(text);
    }


    /**
     * From start, extracts a quoted title in input, if found
     * e.g. "`quoted` text" returns "quoted" and retains input "text"
     *
     * @return quoted text with quotes removed and trimmed if found,
     * empty if no quotes found
     * @throws IllegalValueException if quoted title found is empty
     */
    public Optional<String> extractQuotedTitle() throws IllegalValueException {
        final Matcher matcher = FIRST_QUOTED_TEXT_PATTERN.matcher(input);

        if (matcher.find()) {
            String text = matcher.group("text").trim();

            if (text.isEmpty()) {
                throw new IllegalValueException(Messages.MISSING_TODO_TITLE);
            }

            input = matcher.group("left").trim();
            return Optional.of(text);
        }

        return Optional.empty();
    }

    /**
     * From start, extracts all trailing tags from the current input.
     * Extraction ends when the next word is not a tag.
     * Tags which are empty strings are removed.
     *
     * @return a set of tags, with the tag prefix removed
     */
    public Set<Tag> extractTrailingTags() {
        final Matcher matcher = TAGS_PATTERN.matcher(input);

        if (matcher.find()) {
            input = matcher.group("left").trim();

            // Split to words to get tags
            return Arrays.stream(matcher.group("tags").trim()
                .split("\\s+"))
                .map(word -> {
                    word = word.trim(); // trim any leading spaces
                    assert word.indexOf(TAG_PREFIX) == 0; // pattern should have ensured this
                    return new Tag(word.substring(TAG_PREFIX.length()).trim());
                }).filter(x -> !x.value.isEmpty())
                .collect(Collectors.toSet());
        }

        return Collections.emptySet();
    }

    /**
     * From start, extracts a single word in input, if found
     *
     * @return optional of word extracted from input, empty if not found
     */
    public Optional<String> extractWord() {
        final Matcher matcher = FIRST_WORD_PATTERN.matcher(input.trim());
        if (matcher.find()) {
            // Remove extracted first word
            input = matcher.group("left").trim();
            return Optional.of(matcher.group("word"));
        }

        return Optional.empty();
    }

    /**
     * Extracts all words in input
     * If input is empty, returns empty list
     */
    public List<String> extractWords() {
        return Arrays.stream(extractText().orElse("").split("\\s+"))
            .filter(x -> !x.trim().isEmpty())
            .collect(Collectors.toList());
    }

    /**
     * From start, extracts an integer in input, if found
     *
     * @return optional of found integer extracted from input, empty if not found
     */
    public Optional<Integer> extractInteger() {
        final Matcher matcher = FIRST_INTEGER_PATTERN.matcher(input.trim());

        if (matcher.find()) {
            // Remove extracted first integer
            String integerString = matcher.group("integer");
            input = matcher.group("left").trim();

            try {
                return Optional.of(Integer.parseInt(integerString));
            } catch (NumberFormatException exception) {
                assert false : "Shouldn't be able to fail parsing of integer based on pattern";
            }

        }

        return Optional.empty();
    }
```
###### \java\seedu\commando\logic\parser\CommandParser.java
``` java

    /**
     * Parses a recurrence string to a {@link Recurrence}
     * Asserts {@param recurrence} matches {@link #RECURRENCE_REGEX} or an empty string
     *
     * @return recurrence if valid, null if invalid, Recurrence.None if empty string
     */
    private Recurrence parseRecurrence(String recurrence) {
        switch (recurrence.trim()) {
            case "daily":
                return Recurrence.Daily;
            case "weekly":
                return Recurrence.Weekly;
            case "monthly":
                return Recurrence.Monthly;
            case "yearly":
                return Recurrence.Yearly;
            case "":
                return Recurrence.None;
            default:
                assert false;
        }

        return Recurrence.None;
    }

    private void throwIfEmptyString(String value, String message)
        throws IllegalValueException {
        if (value.trim().isEmpty()) {
            throw new IllegalValueException(message);
        }
    }

    private Optional<DateRange> parseDateRangeWithStartAndEnd(String startDateString, String endDateString, String recurrenceString)
        throws IllegalValueException {

        // Check both "from" and "to" fields are not empty
        throwIfEmptyString(startDateString, Messages.MISSING_TODO_DATERANGE_START + "\n" + Messages.DATE_FORMAT);
        throwIfEmptyString(endDateString, Messages.MISSING_TODO_DATERANGE_END + "\n" + Messages.DATE_FORMAT);

        // Parse start datetime with default time of midnight, end datetime with default time of 2359h
        Optional<LocalDateTime> startDateTime = dateTimeParser.parseDateTime(startDateString, LocalTime.MIDNIGHT);
        Optional<LocalDateTime> endDateTime = dateTimeParser.parseDateTime(endDateString, LocalTime.of(23, 59));

        if (!startDateTime.isPresent() && !endDateTime.isPresent()) {
            // Both start and end dates invalid, maybe its not a date range
            return Optional.empty();
        } else if (startDateTime.isPresent() && !endDateTime.isPresent()) {
            throw new IllegalValueException(Messages.INVALID_TODO_DATERANGE_END + "\n" + Messages.DATE_FORMAT);
        } else if (endDateTime.isPresent() && !startDateTime.isPresent()) {
            throw new IllegalValueException(Messages.INVALID_TODO_DATERANGE_START + "\n" + Messages.DATE_FORMAT);
        } else {
            assert startDateTime.isPresent() && endDateTime.isPresent();

            Recurrence recurrence = parseRecurrence(recurrenceString);
            return Optional.of(new DateRange(startDateTime.get(), endDateTime.get(), recurrence));
        }
    }

    private Optional<DateRange> parseDateRangeWithEnd(String endDateString, String recurrenceString) {
        if (endDateString.isEmpty()) {
            return Optional.empty();
        }

        Optional<LocalDateTime> date = dateTimeParser.parseDateTime(endDateString);

        // Invalid datetime
        if (!date.isPresent()) {
            return Optional.empty();
        }

        Recurrence recurrence = parseRecurrence(recurrenceString);

        try {
            // Return from now to the date end
            DateRange dateRange = new DateRange(LocalDateTime.now(), date.get(), recurrence);
            return Optional.of(dateRange);
        } catch (IllegalValueException e) {
            // Date range was invalid - should not treat it as date range then
            return Optional.empty();
        }
    }

    private Optional<DateRange> parseDateRangeWithStart(String startDateString, String recurrenceString) {
        if (startDateString.isEmpty()) {
            return Optional.empty();
        }

        Optional<LocalDateTime> date = dateTimeParser.parseDateTime(startDateString);

        // Invalid datetime
        if (!date.isPresent()) {
            return Optional.empty();
        }

        Recurrence recurrence = parseRecurrence(recurrenceString);

        try {
            // Return from date start onwards
            DateRange dateRange = new DateRange(date.get(), LocalDateTime.MAX, recurrence);
            return Optional.of(dateRange);
        } catch (IllegalValueException e) {
            // Date range was invalid - should not treat it as date range then
            return Optional.empty();
        }
    }

    private Optional<DateRange> parseDateRangeWithSingleDate(String dateString, String recurrenceString) {

        if (dateString.isEmpty()) {
            return Optional.empty();
        }

        Optional<Pair<LocalDateTime, LocalDateTime>> period
            = dateTimeParser.parseDateTimePeriod(dateString);

        // Invalid datetime
        if (!period.isPresent()) {
            return Optional.empty();
        }

        Recurrence recurrence = parseRecurrence(recurrenceString);

        try {
            DateRange dateRange = new DateRange(period.get().getKey(), period.get().getValue(), recurrence);
            return Optional.of(dateRange);
        } catch (IllegalValueException e) {
            // Date range was invalid - should not treat it as date range then
            return Optional.empty();
        }
    }

    private Optional<DueDate> parseDueDate(String dateString, String recurrenceString) {
        // Parse datetime and recurrence
        Optional<LocalDateTime> date = dateTimeParser.parseDateTime(dateString);
        Recurrence recurrence = parseRecurrence(recurrenceString);

        if (date.isPresent()) {
            return Optional.of(new DueDate(date.get(), recurrence));
        } else {
            return Optional.empty();
        }
    }
}
```
###### \java\seedu\commando\logic\parser\DateTimeParser.java
``` java

/**
 * Parses datetimes with help of {@link com.joestelmach.natty.Parser}
 */
public class DateTimeParser {
    public static final LocalTime MorningLocalTime = LocalTime.of(8, 0);
    public static final LocalTime AfternoonLocalTime = LocalTime.of(12, 0);
    public static final LocalTime EveningLocalTime = LocalTime.of(19, 0);
    public static final LocalTime NightLocalTime = LocalTime.of(21, 0);

    private static final String MonthWordRegexString = "January|Feburary|March|April|June|July|August|September|October|November|December|" +
        "Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Sept|Oct|Nov|Dec";
    private static final String DayWordRegexString = "Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday|Mon|Tue|Tues|Wed|Thu|Thur|Thurs|Fri|Sat|Sun";
    private static final String YearRegexString = "(?<year>\\d{4}|\\d{2})";
    private static final String TwoDigitYearRegexString = "\\d{2}$";
    private static final String MonthRegexString = "(0?[1-9])|10|11|12";
    private static final String DayOfMonthRegexString = "([12]\\d)|([3][01])|(0?[1-9])";
    private static final String Hours24RegexString = "(1\\d)|20|21|22|23|(0?\\d)";
    private static final String Hours12RegexString = "11|12|(0?[1-9])";
    private static final String MinutesRegexString = "([1234]\\d)|(5[0-9])|(0?\\d)";

    private static final String DateWithSlashesRegexString = "(?<day>" + DayOfMonthRegexString + ")\\/(?<month>" + MonthRegexString + ")(\\/" + YearRegexString + ")?";
    private static final String DateWithMonthWordRegexString = "((" + DayOfMonthRegexString + ")(th|rd|st|nd)?)\\s+" +
        "(" + MonthWordRegexString + ")(\\s+" + YearRegexString + ")?";
    private static final String DateWithMonthWordReversedRegexString = "(" + MonthWordRegexString + ")\\s+" +
        "(" + DayOfMonthRegexString + ")(th|rd|st|nd)?(\\s+" + YearRegexString + ")?";
    private static final String DateWithDayWordRegexString = "((this|coming|next)\\s+)?(" + DayWordRegexString + ")";
    private static final String DateWithLaterAgoRegexString = "((\\d+\\d)|([2-9]))\\s+(days|weeks|months|years)\\s+(later|ago)";
    private static final String DateWithLastNextRegexString = "(last|this|next)\\s+(week|month|year)";
    private static final String DatePresetsRegexString = "today|tomorrow|tmr|yesterday";

    private static final String Time24HourRegexString = "(" + Hours24RegexString + ")(\\.|:)(" + MinutesRegexString + ")";
    private static final String Time12HourRegexString = "(" + Hours12RegexString + ")(\\.|:)?(" + MinutesRegexString + ")?(am|pm)";
    private static final String TimePresetsNightRegexString = "(this\\s+)?(night|tonight)";
    private static final String TimePresetsRegexString = "(this\\s+)?(morning|afternoon|noon|evening|midnight)";
    private static final String TimeHourNotationRegexString = "(?<hours>" + Hours24RegexString + ")(?<minutes>" + MinutesRegexString + ")h";

    private static final String[] supportedDateRegexStrings = new String[]{
        DateWithSlashesRegexString,
        DateWithMonthWordRegexString,
        DateWithMonthWordReversedRegexString,
        DateWithDayWordRegexString,
        DateWithLaterAgoRegexString,
        DateWithLastNextRegexString,
        DatePresetsRegexString
    };

    private static final String[] supportedTimeRegexStrings = new String[]{
        Time24HourRegexString,
        TimeHourNotationRegexString,
        Time12HourRegexString,
        TimePresetsRegexString,
        TimePresetsNightRegexString
    };

    private static final String InitializationDateString = "today";

    private Parser parser = new Parser();
    private LocalDate lastLocalDate; // Date of last parsed datetime

    public DateTimeParser() {
        parseDateTime(InitializationDateString, LocalTime.MIDNIGHT);
    }

    /**
     * Resets any contextual info used based on history of parsing.
     */
    public void resetContext() {
        lastLocalDate = null;
    }

    /**
     * Parses an input string as a datetime period.
     *
     * @param input input string to be parsed
     * @return optional of pair of (start datetime, end datetime), empty if invalid datetime
     * @see #parseDateTime(String, LocalTime)
     */
    public Optional<Pair<LocalDateTime, LocalDateTime>> parseDateTimePeriod(String input) {
        // Get the datetime the input string represents
        Optional<LocalDateTime> localDateTime = parseDateTime(input);

        // If input string doesn't represent a datetime, return empty
        if (!localDateTime.isPresent()) {
            return Optional.empty();
        }

        String trimmedInput = input.trim();

        // Check if the input is trying to represent a period of > 1 day
        if (ifInputMatchesWeekPeriod(trimmedInput)) {
            return Optional.of(getWeekPeriod(localDateTime.get()));
        } else if (ifInputMatchesMonthPeriod(trimmedInput)) {
            return Optional.of(getMonthPeriod(localDateTime.get()));
        } else if (ifInputMatchesYearPeriod(trimmedInput)) {
            return Optional.of(getYearPeriod(localDateTime.get()));
        }

        return Optional.of(getDayPeriod(localDateTime.get()));
    }

    /**
     * {@link #parseDateTime(String, LocalTime)}, but with a default time of midnight
     */
    public Optional<LocalDateTime> parseDateTime(String input) {
        return parseDateTime(input, LocalTime.MIDNIGHT);
    }

    /**
     * Parses an input string as a datetime.
     * <p>
     * Works like {@link com.joestelmach.natty.Parser#parse(String)}, but:
     * - First passed through a stricter filter that regulates what is a valid datetime format.
     * - Converted to LocalDateTime
     * - If time is deemed as "inferred" (in natty), time = {@param defaultTime}
     * - If date is "inferred" and there were previous parses, date is set as that of last parsed datetime
     * - Seconds and nano-seconds field is always set to 0 (ignored)
     *
     * @param input       input string to parse
     * @param defaultTime default time to set if time is not explicit in {@param input}
     * @return optional of datetime, empty if invalid datetime
     */
    public Optional<LocalDateTime> parseDateTime(String input, LocalTime defaultTime) {
        Optional<String> preprocessedInput = preprocessInput(input.trim());

        // If pre-processing fails, return empty
        if (!preprocessedInput.isPresent()) {
            return Optional.empty();
        }

        // Let natty parse pre-processed input
        List<DateGroup> dateGroups = parser.parse(preprocessedInput.get());

        // Returns empty if natty didn't manage to parse it
        if (dateGroups.isEmpty()) {
           return Optional.empty();
        }

        DateGroup dateGroup = dateGroups.get(0);
        List<Date> dates = dateGroup.getDates();
        if (dates.isEmpty()) {
            return Optional.empty();
        }

        // Returns the first datetime parsed by natty
        return Optional.of(toLocalDateTime(dateGroup, dates.get(0), defaultTime));
    }

    /**
     * Converts natty's output {@code DateGroup} and {@code Date} to a {@code LocalDateTime}.
     */
    private LocalDateTime toLocalDateTime(DateGroup dateGroup, Date date, LocalTime defaultTime) {
        Instant instant = Instant.ofEpochMilli(date.getTime());
        ZoneId zoneId = ZoneOffset.systemDefault();
        LocalDateTime localDateTime = LocalDateTime.ofInstant(instant, zoneId);

        // Check if date is inferred
        if (dateGroup.isDateInferred() && lastLocalDate != null) {
            localDateTime = LocalDateTime.of(lastLocalDate, localDateTime.toLocalTime());
        }

        // Check if time is inferred
        if (dateGroup.isTimeInferred()) {
            localDateTime = LocalDateTime.of(localDateTime.toLocalDate(), defaultTime);
        }

        // Reset seconds
        localDateTime = localDateTime.withSecond(0).withNano(0);

        // Remember last date parsed
        lastLocalDate = localDateTime.toLocalDate();

        return localDateTime;
    }

    /**
     * Determines with regex whether {@param input} is a supported datetime.
     * Pre-processes it to before being parsed in natty
     *
     * @param input input string to pre-process, must be trimmed
     * @return optional of the datetime string after validation and pre-processing, empty if
     * deemed as a datetime format not supported by this class
     */
    private Optional<String> preprocessInput(String input) {
        if (input.isEmpty()) {
            return Optional.empty();
        }

        // Try to match a date
        Optional<Matcher> dateMatcher = findDateRegexMatch(input);

        String dateString = "";
        if (dateMatcher.isPresent()) {
            dateString = getDateFromMatcher(dateMatcher.get());

            // Extract out date string from text
            input = input.substring(dateMatcher.get().end()).trim();
        }

        // Try to match a time
        Optional<Matcher> timeMatcher = findTimeRegexMatch(input);

        String timeString = "";
        if (timeMatcher.isPresent()) {
            timeString = getTimeFromMatcher(timeMatcher.get());

            // Extract out date string from text
            input = input.substring(timeMatcher.get().end()).trim();
        }

        // If there is any characters left in text, invalid datetime
        if (!input.trim().isEmpty()) {
            return Optional.empty();
        } else {
            String dateTimeString = dateString + " " + timeString;
            dateTimeString = handleDateTimeWithLaterAgo(dateString, timeString, dateTimeString);

            return Optional.of(dateTimeString);
        }
    }

    private String getTimeFromMatcher(Matcher timeMatcher) {
        String timeString = timeMatcher.group().trim();
        timeString = handleTimeFormatHour(timeString, timeMatcher);
        timeString = handleTimeNight(timeString, timeMatcher);
        return timeString;
    }

    private String getDateFromMatcher(Matcher dateMatcher) {
        String dateString = dateMatcher.group().trim();
        dateString = handleDateWithSlashes(dateString, dateMatcher);
        dateString = handleDateTwoDigitYear(dateString, dateMatcher);
        return dateString;
    }

    private String handleDateTimeWithLaterAgo(String dateString, String timeString, String dateTimeString) {
        // Special case: if DateWithLaterRegexString is used,
        // swap date and time (for parsing in natty)
        if (dateString.matches(DateWithLaterAgoRegexString)) {
            return timeString + " " + dateString;
        } else {
            return dateTimeString;
        }
    }

    private String handleTimeNight(String timeString, Matcher matcher) {
        // Special case: for TimePresetsNightRegexString format,
        // Set time to 9pm
        if (ifMatcherUsesRegex(matcher, TimePresetsNightRegexString)) {
            return NightLocalTime.toString();
        } else {
            return timeString;
        }
    }

    private String handleTimeFormatHour(String timeString, Matcher matcher) {
        // Special case: for TimeHourNotationRegexString format,
        // Change to colon format (natty parses it wrongly when there is no year in the date)
        if (ifMatcherUsesRegex(matcher, TimeHourNotationRegexString)) {
            return matcher.group("hours") + ":" + matcher.group("minutes");
        } else {
            return timeString;
        }
    }

    private String handleDateTwoDigitYear(String dateString, Matcher matcher) {
        // Tweak for year: if it is a 2 digit year, change it to 4
        // Check if year string exists in datetime
        try {
            if (matcher.group("year") != null && matcher.group("year").length() == 2) {
                // Get string version of today's year
                String thisFullYear = String.valueOf(LocalDateTime.now().getYear());
                // If today's year is more than 2 digits, append the front (size - 2) digits
                if (thisFullYear.length() > 2) {
                    String fullYear = thisFullYear.substring(0, thisFullYear.length() - 2)
                        + matcher.group("year");
                    return dateString.replaceFirst(TwoDigitYearRegexString, fullYear);
                }
            }
        } catch (IllegalArgumentException exception) {
        } // no group with "year"

        return dateString;
    }

    private String handleDateWithSlashes(String dateString, Matcher matcher) {
        // Special case: for DateWithSlashesRegexString format,
        // Swap month and day
        if (ifMatcherUsesRegex(matcher, DateWithSlashesRegexString)) {
            return matcher.group("month") + "/" + matcher.group("day")
                + (matcher.group("year") != null ? ("/" + matcher.group("year")) : "");
        } else {
            return dateString;
        }
    }


    private Pair<LocalDateTime, LocalDateTime> getDayPeriod(LocalDateTime localDateTime) {
        // Return a single day until 2359h
        return new Pair<>(localDateTime, localDateTime.withHour(23).withMinute(59));
    }

    private Pair<LocalDateTime, LocalDateTime> getYearPeriod(LocalDateTime localDateTime) {
        // Return from 1st to last day of year 2359h
        return new Pair<>(
            localDateTime.withDayOfYear(1),
            localDateTime.plusYears(1).withDayOfYear(1).minusDays(1)
                .withHour(23).withMinute(59)
        );
    }

    private Pair<LocalDateTime, LocalDateTime> getMonthPeriod(LocalDateTime localDateTime) {
        // Return from 1st to last day of month 2359h
        return new Pair<>(
            localDateTime.withDayOfMonth(1),
            localDateTime.plusMonths(1).withDayOfMonth(1).minusDays(1)
                .withHour(23).withMinute(59)
        );
    }

    private Pair<LocalDateTime, LocalDateTime> getWeekPeriod(LocalDateTime localDateTime) {
        // Return from monday to sunday of that week 2359h
        return new Pair<>(
            localDateTime.with(DayOfWeek.MONDAY),
            localDateTime.with(DayOfWeek.SUNDAY).withHour(23).withMinute(59)
        );
    }

    private boolean ifInputMatchesWeekPeriod(String input) {
        return (input.matches(DateWithLaterAgoRegexString)
            || input.matches(DateWithLastNextRegexString))
            && input.toLowerCase().contains("week");
    }

    private boolean ifInputMatchesMonthPeriod(String input) {
        return (input.matches(DateWithLaterAgoRegexString)
            || input.matches(DateWithLastNextRegexString))
            && input.toLowerCase().contains("month");
    }

    private boolean ifInputMatchesYearPeriod(String input) {
        return (input.matches(DateWithLaterAgoRegexString)
            || input.matches(DateWithLastNextRegexString))
            && input.toLowerCase().contains("year");
    }

    private Optional<Matcher> findDateRegexMatch(String input) {
        for (String regexString : supportedDateRegexStrings) {
            Matcher matcher = Pattern.compile(prepareRegexString(regexString), Pattern.CASE_INSENSITIVE).matcher(input);

            // If matched from the start
            if (matcher.find() && matcher.start() == 0) {
                return Optional.of(matcher);
            }
        }

        return Optional.empty();
    }

    private Optional<Matcher> findTimeRegexMatch(String input) {
        for (String regexString : supportedTimeRegexStrings) {
            Matcher matcher = Pattern.compile(prepareRegexString(regexString), Pattern.CASE_INSENSITIVE).matcher(input);

            // If matched from the start
            if (matcher.find() && matcher.start() == 0) {
                return Optional.of(matcher);
            }
        }

        return Optional.empty();
    }

    private String prepareRegexString(String regexString) {
        // regex + (space or end of string)
        return regexString + "(\\s+|$)";
    }

    private boolean ifMatcherUsesRegex(Matcher matcher, String regexString) {
        return matcher.pattern().pattern().equals(prepareRegexString(regexString));
    }
}
```
###### \java\seedu\commando\model\Model.java
``` java

/**
 * The API of the Model component.
 */
public interface Model {
    /**
     * Gets the internal to-do list, read-only. Call {@link #changeToDoList(ToDoListChange)}
     * to modify the list.
     *
     * @return its to-do list, read-only
     */
    ReadOnlyToDoList getToDoList();

    /**
     * Applies a change to its to-do list.
     *
     * @throws IllegalValueException if the change was invalid
     */
    void changeToDoList(ToDoListChange change) throws IllegalValueException;

    /**
     * Undos the last successful change to its to-do list.
     *
     * @return true if there was a change that was undone
     */
    boolean undoToDoList();

    /**
     * Redos the last successful undo to its to-do list.
     *
     * @return true if there was an undo that was redone
     */
    boolean redoToDoList();

    /**
     * Returns observable read-only list of UI to-dos considered as events by {@link UiToDo#isEvent()}.
     * This changes with the filter on the UI to-dos and the to-do list of model.
     * The ordering of the list is to be respected.
     *
     * @return an observable read-only list of {@link UiToDo} that are events
     */
    UnmodifiableObservableList<UiToDo> getUiEvents();

    /**
     * Return observable read-only list of UI to-dos considered as tasks by {@link UiToDo#isTask()}.
     * This changes with the filter on the UI to-dos and the to-do list of model.
     * The ordering of the list is to be respected.
     *
     * @return an observable read-only list of {@link UiToDo} that are tasks
     */
    UnmodifiableObservableList<UiToDo> getUiTasks();

    /**
     * Returns the {@link UiToDo} in {@link #getUiEvents()} and {@link #getUiTasks()}
     * that have the {@link UiToDo#getIndex()} of {@param toDoIndex}, in constant time.
     *
     * @return the UI to-do with the given index, if exists
     */
    Optional<UiToDo> getUiToDoAtIndex(int index);

    /**
     * Clears any keywords, tags or daterange filters on the UI to-dos
     * and sets the filter mode.
     * Asserts parameters to be non-null.
     */
    void clearUiToDoListFilter(FILTER_MODE filterMode);

    /**
     * Sets a filter mode, keywords filter, and tags filter on the UI to-dos.
     * Asserts parameters to be non-null.
     * <p>
     * If {@param filterMode} ==
     * - ALL: all to-dos that match keywords and tags are shown.
     * - FINISHED: finished to-dos that match keywords and tags are shown
     * - UNFINISHED: unfinished to-dos or finished to-dos that are finished on the
     * the current day, that match keywords and tags, are shown.
     */
    void setUiToDoListFilter(Set<String> keywords, Set<Tag> tags, FILTER_MODE filterMode);

```
###### \java\seedu\commando\model\ModelManager.java
``` java

/**
 * Concrete implementation of {@link Model} for the Model component.
 * Defines how data is represented and holds the data of the application in-memory.
 */
public class ModelManager extends ComponentManager implements Model {
    private static final Logger logger = LogsCenter.getLogger(ModelManager.class);

    private final ToDoListManager toDoListManager;
    private final UiModel uiModel;

    /**
     * Initializes a ModelManager with the given to-do list.
     * Asserts parameters to be non-null.
     *
     * @param toDoList the internal to-do list will be a deep copy of this
     */
    public ModelManager(ReadOnlyToDoList toDoList) {
        super();
        assert toDoList != null;

        logger.fine("Initializing with to-do list: " + toDoList);

        toDoListManager = new ToDoListManager(toDoList);
        uiModel = new UiModel(toDoListManager);

        logUiToDoList();
    }

    /**
     * @see ModelManager(ReadOnlyToDoList), but with an empty to-do list
     */
    public ModelManager() {
        this(new ToDoList());
    }

    @Override
    public ReadOnlyToDoList getToDoList() {
        return toDoListManager.getToDoList();
    }

    @Override
    public synchronized void changeToDoList(ToDoListChange change) throws IllegalValueException {
        logger.info("Applying change to to-do list: " + change);
        toDoListManager.changeToDoList(change);

        // if to-do list has changed, reset any find or history filter
        clearUiToDoListFilter(FILTER_MODE.UNFINISHED);
        indicateToDoListChanged();
        logUiToDoList();
    }

    @Override
    public boolean undoToDoList() {
        logger.info("Undoing to-do list...");
        boolean hasChanged = toDoListManager.undoToDoList();

        if (hasChanged) {
            clearUiToDoListFilter(FILTER_MODE.UNFINISHED);
            indicateToDoListChanged();
            logUiToDoList();
        }

        return hasChanged;
    }

    @Override
    public boolean redoToDoList() {
        logger.info("Redoing to-do list...");
        boolean hasChanged = toDoListManager.redoToDoList();

        if (hasChanged) {
            clearUiToDoListFilter(FILTER_MODE.UNFINISHED);
            indicateToDoListChanged();
            logUiToDoList();
        }

        return hasChanged;
    }

    @Override
    public UnmodifiableObservableList<UiToDo> getUiEvents() {
        return uiModel.getEvents();
    }

    @Override
    public UnmodifiableObservableList<UiToDo> getUiTasks() {
        return uiModel.getTasks();
    }

    @Override
    public Optional<UiToDo> getUiToDoAtIndex(int index) {
        return uiModel.getToDoAtIndex(index);
    }

    @Override
    public void clearUiToDoListFilter(FILTER_MODE filterMode) {
        logger.info("Clearing filter on UI to-dos with filter mode: " + filterMode);

        uiModel.clearToDoListFilter(filterMode);
        logUiToDoList();
    }

    @Override
    public void setUiToDoListFilter(Set<String> keywords, Set<Tag> tags, FILTER_MODE filterMode) {
        logger.info("Filtering UI to-dos by keywords " + keywords + " and tags " + tags
            + " with filter mode: " + filterMode);

        uiModel.setToDoListFilter(keywords, tags, filterMode);

        logUiToDoList();
    }

    /**
     * Raises an event to indicate the model has changed.
     */
    private void indicateToDoListChanged() {
        raise(new ToDoListChangedEvent(toDoListManager.getToDoList()));
    }

    private void logUiToDoList() {
        // log events and tasks shown
        logger.info("Events: " + uiModel.getEvents().stream().map(uiToDo -> uiToDo.getIndex() + ") " + uiToDo.getTitle())
            .collect(Collectors.joining(", ")));

        logger.info("Tasks: " + uiModel.getTasks().stream().map(uiToDo -> uiToDo.getIndex() + ") " + uiToDo.getTitle())
            .collect(Collectors.joining(", ")));
    }

```
###### \java\seedu\commando\model\todo\DateRange.java
``` java

/**
 * Represents a date range of a to-do, immutable.
 * Ignores the seconds and nano-seconds field of its datetimes, unless it is MIN or MAX.
 */
public class DateRange {
    private static DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm");

    public final LocalDateTime startDate, endDate;
    public final Recurrence recurrence;

    /**
     * @see #DateRange(LocalDateTime, LocalDateTime, Recurrence), but with no recurrence.
     */
    public DateRange(LocalDateTime startDate, LocalDateTime endDate) throws IllegalValueException {
        this(startDate, endDate, Recurrence.None);
    }

    /**
     * Constructor for a date range.
     * Asserts parameters are non-null.
     * Conditions for validity:
     * - {@param endDate} must not be before {@param startDate}
     * - gap between {@param startDate} and {@param endDate} must not be more than the recurrence interval
     *
     * @throws IllegalValueException if given set of arguments is invalid
     */
    public DateRange(LocalDateTime startDate, LocalDateTime endDate, Recurrence recurrence)
        throws IllegalValueException {
        assert !CollectionUtil.isAnyNull(startDate, endDate, recurrence);

        checkIfValid(startDate, endDate, recurrence);

        this.startDate = processDateTime(startDate);
        this.endDate = processDateTime(endDate);
        this.recurrence = recurrence;
    }

    /**
     * Copy constructor
     */
    public DateRange(DateRange dateRange) {
        this.startDate = dateRange.startDate;
        this.endDate = dateRange.endDate;
        this.recurrence = dateRange.recurrence;
    }

    /**
     * Checks if a set of fields for the class is valid.
     *
     * @throws IllegalValueException if some set of fields is invalid
     */
    private static void checkIfValid(LocalDateTime startDate, LocalDateTime endDate, Recurrence recurrence)
        throws IllegalValueException {

        // Checks if start date is before end date
        if (endDate.isBefore(startDate)) {
            throw new IllegalValueException(Messages.TODO_DATERANGE_END_MUST_AFTER_START + "\n" + Messages.DATE_FORMAT);
        }

        // Checks gap between dates must not be more than the recurrence interval
        if (recurrence != Recurrence.None
            && recurrence.getNextDate(startDate).isBefore(endDate)) {
            throw new IllegalValueException(Messages.TODO_DATERANGE_RECURRENCE_INVALID + "\n" + Messages.DATE_FORMAT);
        }
    }

    @Override
    public String toString() {
        String dateString;
        if (startDate.equals(LocalDateTime.MIN) && endDate.equals(LocalDateTime.MAX)) {
            dateString = "forever";
        } else if (startDate.equals(LocalDateTime.MIN)) {
            dateString = "until " + endDate.format(dateFormatter);
        } else if (endDate.equals(LocalDateTime.MAX)) {
            dateString = "from " + startDate.format(dateFormatter) + " onwards";
        } else {
            dateString = "from " + startDate.format(dateFormatter) + " to " + endDate.format(dateFormatter);
        }
        return dateString
            + ((recurrence == Recurrence.None) ? "" : " " + recurrence.toString().toLowerCase());
    }

    @Override
    public boolean equals(Object other) {
        // short circuit if same object
        // instanceof handles nulls
        return other == this
            || (other instanceof DateRange
            && (startDate.equals(((DateRange) other).startDate)
            && endDate.equals(((DateRange) other).endDate)
            && recurrence.equals(((DateRange) other).recurrence))); // state check
    }

    @Override
    public int hashCode() {
        return Objects.hash(startDate, endDate, recurrence);
    }

    private LocalDateTime processDateTime(LocalDateTime localDateTime) {
        if (localDateTime.equals(LocalDateTime.MAX) || localDateTime.equals(LocalDateTime.MIN)) {
            return localDateTime;
        } else {
            return localDateTime.withSecond(0).withNano(0);
        }
    }
}
```
###### \java\seedu\commando\model\todo\ReadOnlyToDo.java
``` java

/**
 * A read-only immutable interface for a to-do.
 */
public interface ReadOnlyToDo {

    /**
     * Gets the title of the to-do.
     * A title is compulsory for a to-do.
     *
     * @return title of the to-do
     */
    Title getTitle();

    /**
     * Gets the date range of the to-do.
     *
     * @return optional of the date range, empty if the to-do has none
     */
    Optional<DateRange> getDateRange();

    /**
     * Gets the due date of the to-do.
     *
     * @return optional of the due date, empty if the to-do has none
     */
    Optional<DueDate> getDueDate();

    /**
     * Gets the set of tags of the to-do.
     *
     * @return set of tags of the to-do
     */
    Set<Tag> getTags();

    /**
     * Gets the date created of the to-do.
     * By default, it is set as the datetime when the to-do was initialized.
     *
     * @return date created of the to-do
     */
    LocalDateTime getDateCreated();

    /**
     * Returns true if to-do contains either a date range or a due date.
     *
     * @return whether to-do has a time constraint
     */
    default boolean hasTimeConstraint() {
        return getDateRange().isPresent()
            || getDueDate().isPresent();
    }

    /**
     * Gets the date finished for the to-do.
     * If there is a recurring date range or due date, this would always be empty.
     * If there is a non-recurring date range, this would return the end date
     * if the current time is after the end date, empty otherwise (not over).
     *
     * @return optional of date finished of the to-do, empty if the date has no date finished.
     */
    Optional<LocalDateTime> getDateFinished();

    /**
     * Returns true if date finished is set and it is before the current time.
     *
     * @return whether to-do is considered finished
     */
    default boolean isFinished() {
        return getDateFinished().isPresent() && LocalDateTime.now().isAfter(getDateFinished().get());
    }

    /**
     * An observable value that changes when any of the to-do's fields are updated.
     *
     * @return an {@code ObservableValue} that tracks all fields of the to-do.
     */
    ObservableValue getObservableValue();

    /**
     * Returns true if both to-dos have the same state.
     * All fields, except date created, must be equal.
     *
     * @param other the other to-do to compare with
     * @return whether current to-do has the same state as {@param other}
     */
    default boolean isSameStateAs(ReadOnlyToDo other) {
        // short circuit if same object
        // other != null to avoid NPE below
        return other == this
            || (other != null
            && other.getTitle().equals(getTitle())
            && other.getDateRange().equals(getDateRange())
            && other.getDueDate().equals(getDueDate())
            && other.getTags().equals(getTags())
            && other.getDateFinished().equals(getDateFinished()));
    }

    /**
     * Returns true if both are considered "similar",
     * which means these fields must be equal:
     * - title
     * - due date
     * - date range
     * - tags
     *
     * @param other the other to-do to compare with
     * @return whether current to-do is similar to {@param other}
     */
    default boolean isSimilar(ReadOnlyToDo other) {
        return other == this // short circuit if same object
            || (other != null // this is first to avoid NPE below
            && other.getTitle().equals(getTitle())
            && other.getDateRange().equals(getDateRange())
            && other.getDueDate().equals(getDueDate())
            && other.getTags().equals(getTags()));
    }

    /**
     * Returns a complete textual representation of the to-do as a string, displaying
     * all its fields.
     *
     * @return a string that represents the to-do
     */
    default String getText() {
        return String.join(", ",
            "Title: " + getTitle(),
            "Date Range: " + (getDateRange().isPresent() ? getDateRange().get() : "none"),
            "Due Date: " + (getDueDate().isPresent() ? getDueDate().get() : "none"),
            "Tags: " + getTags(),
            "Date Created: " + getDateCreated(),
            "Date Finished: " + (getDateFinished().isPresent() ? getDateFinished().get() : "none"));
    }
}
```
###### \java\seedu\commando\model\todo\ReadOnlyToDoList.java
``` java

/**
 * Unmodifiable view of a to-do list.
 */
public interface ReadOnlyToDoList {

    /**
     * Gets a read-only list of read-only to-dos it contains.
     *
     * @return an observable read-only list of read-only to-dos it contains
     */
    UnmodifiableObservableList<ReadOnlyToDo> getToDos();

    /**
     * Checks if the list contains a to-do that is considered as similar
     * as the given to-do.
     * See {@link ReadOnlyToDo#isSimilar(ReadOnlyToDo)}.
     *
     * @param toDo a to-do to check
     * @return whether {@param toDo} exists in the list
     */
    boolean contains(ReadOnlyToDo toDo);

    /**
     * Checks if the list is considered similar as the given to-do list,
     * which means both their to-dos must be considered similar.
     * See {@link ReadOnlyToDo#isSimilar(ReadOnlyToDo)}.
     *
     * @param toDoList a to-do list to check
     * @return whether this to-do list is considered similar to {@param toDoList}
     */
    boolean isSimilar(ReadOnlyToDoList toDoList);

    /**
     * Returns a complete textual representation of the to-do list as a string, displaying
     * all to-dos.
     *
     * @return a string that represents the to-do list
     */
    default String getText() {
        return "[" + getToDos().stream().map(ReadOnlyToDo::toString).collect(Collectors.joining(", ")) + "]";
    }
}
```
###### \java\seedu\commando\model\todo\Recurrence.java
``` java

/**
 * Represents a recurrence in a to-do.
 */
public enum Recurrence {
    Daily,
    Weekly,
    Monthly,
    Yearly,
    None;

    /**
     * Gets the next datetime for this recurrence, based on a starting datetime.
     *
     * @param date starting datetime for the recurrence
     * @return the next datetime based on this recurrence
     */
    public LocalDateTime getNextDate(LocalDateTime date) {
        switch (this) {
            case Daily:
                return date.plusDays(1);
            case Weekly:
                return date.plusWeeks(1);
            case Monthly:
                return date.plusMonths(1);
            case Yearly:
                return date.plusYears(1);
            case None:
                return date;
        }

        return date;
    }
}
```
###### \java\seedu\commando\model\todo\ToDo.java
``` java

    /**
     * Called when a to-do is to advance its date range to after {@param dateUntil}
     * based on its recurrence.
     * Will only have an effect if to-do has a date range with a recurrence,
     */
    private void advanceDateRange(LocalDateTime dateUntil) {
        if (dateRange == null
            || dateUntil.isBefore(dateRange.endDate)
            || dateRange.recurrence == Recurrence.None) {
            return;
        }

        // The initial if-else should cover this
        assert dateRange != null && dateRange.recurrence != Recurrence.None;

        // Keep moving date forward based on recurrence interval
        // until it is not before the current date
        LocalDateTime startDate = dateRange.startDate;
        LocalDateTime endDate = dateRange.endDate;
        while (!startDate.isAfter(dateUntil)) {
            startDate = dateRange.recurrence.getNextDate(startDate);
            endDate = dateRange.recurrence.getNextDate(endDate);
        }
        try {
            dateRange = new DateRange(startDate, endDate, dateRange.recurrence);
        } catch (IllegalValueException exception) {
            assert false : "new date range should be valid";
        }

        updateValue();
    }

    /**
     * Called when a to-do is to advance its due date to after {@param dateUntil}
     * based on its recurrence.
     * Will only have an effect if to-do has a due date with a recurrence,
     */
    private void advanceDueDate(LocalDateTime dateUntil) {
        if (dueDate == null
            || dateUntil.isBefore(dueDate.value)
            || dueDate.recurrence == Recurrence.None) {
            return;
        }

        // The initial if-else should cover this
        assert dueDate != null && dueDate.recurrence != Recurrence.None;

        // Keep moving date forward based on recurrence interval
        // until it is not before the current date
        LocalDateTime date = dueDate.value;
        while (!date.isAfter(dateUntil)) {
            date = dueDate.recurrence.getNextDate(date);
        }
        dueDate = new DueDate(date, dueDate.recurrence);

        updateValue();
    }
}
```
###### \java\seedu\commando\model\todo\ToDoList.java
``` java

/**
 * Represents a list of to-dos.
 */
public class ToDoList implements ReadOnlyToDoList {
    private final ObservableList<ReadOnlyToDo> list;
    private final UnmodifiableObservableList<ReadOnlyToDo> protectedList;

    {
        // Initializes an observable list to store to-dos, which
        // calls its listeners when any of its to-dos change
        list = FXCollections.observableArrayList(toDo -> new Observable[]{
            toDo.getObservableValue()
        });

        // Initializes a read-only wrapper around the list of to-dos
        protectedList = new UnmodifiableObservableList<>(list);
    }

    /**
     * Initializes an empty to-do list.
     */
    public ToDoList() {
    }

    /**
     * Copy constructor
     */
    public ToDoList(ReadOnlyToDoList listToBeCopied) {
        reset(listToBeCopied.getToDos());
    }

    /**
     * @see #add(ReadOnlyToDoList)
     */
    public ToDoList add(ReadOnlyToDo toDo) throws IllegalValueException {
        if (contains(toDo)) {
            throw new IllegalValueException(Messages.TODO_ALREADY_EXISTS);
        }

        list.add(toDo);

        return this;
    }

    /**
     * @see #remove(ReadOnlyToDoList)
     */
    public ToDoList remove(ReadOnlyToDo toDo) throws IllegalValueException {
        if (!contains(toDo)) {
            throw new IllegalValueException(Messages.TODO_NOT_FOUND);
        }

        list.remove(toDo);

        return this;
    }

    /**
     * Add all to-dos in {@param toDoList}. Duplicate to-dos are not allowed, based on
     * {@link ReadOnlyToDo#isSimilar(ReadOnlyToDo)}
     *
     * @param toDoList all to-dos to add to the to-do list
     * @throws IllegalValueException if any to-do in {@param toDoList} already exists
     */
    public ToDoList add(ReadOnlyToDoList toDoList) throws IllegalValueException {
        assert toDoList != null;

        for (ReadOnlyToDo toDo : toDoList.getToDos()) {
            if (contains(toDo)) {
                throw new IllegalValueException(Messages.TODO_ALREADY_EXISTS);
            }
        }

        list.addAll(toDoList.getToDos());

        return this;
    }

    /**
     * Removes every to-do in {@param toDoList} that is considered {@link ReadOnlyToDo#isSimilar(ReadOnlyToDo)}
     * to any to-do in the to-do list.
     *
     * @param toDoList all to-dos to delete from the to-do list
     * @throws IllegalValueException if any to-do in {@param toDoList} was not found for deletion
     */
    public ToDoList remove(ReadOnlyToDoList toDoList) throws IllegalValueException {
        assert toDoList != null;

        for (ReadOnlyToDo toDoToRemove : toDoList.getToDos()) {
            if (!contains(toDoToRemove)) {
                throw new IllegalValueException(Messages.TODO_NOT_FOUND);
            }
        }

        list.removeAll(toDoList.getToDos());

        return this;
    }

    /**
     * Clears the list and sets it to a deep copy of a new to-do list
     *
     * @param newToDos the new to-do list to reset to
     */
    public void reset(List<ReadOnlyToDo> newToDos) {
        List<ToDo> toDos = new LinkedList<>();
        newToDos.forEach(toDo -> toDos.add(new ToDo(toDo)));
        list.setAll(toDos);
    }

    @Override
    public String toString() {
        return getText();
    }

    @Override
    public UnmodifiableObservableList<ReadOnlyToDo> getToDos() {
        return protectedList;
    }

    @Override
    public boolean contains(ReadOnlyToDo toDo) {
        return list.filtered(x -> x.isSimilar(toDo)).size() > 0;
    }

    @Override
    public boolean isSimilar(ReadOnlyToDoList toDoList) {
        return list.size() == toDoList.getToDos().size()
            && list.filtered(toDoList::contains).size() == list.size();
    }

    @Override
    public boolean equals(Object other) {
        // short circuit if same object
        // instanceof handles nulls
        return other == this
            || (other instanceof ToDoList
            && list.equals(((ToDoList) other).list));
    }

    @Override
    public int hashCode() {
        return Objects.hash(list);
    }
}
```
###### \java\seedu\commando\model\todo\ToDoListChange.java
``` java
/**
 * An immutable representation of a change in {@link ReadOnlyToDoList}
 */
public class ToDoListChange {
    private final ReadOnlyToDoList addedToDos;
    private final ReadOnlyToDoList deletedToDos;

    /**
     * Constructor for a to-do list change.
     *
     * @param addedToDos   list of to-dos to be added, which is deep copied
     * @param deletedToDos list of to-dos to be deleted, which is deep copied
     */
    public ToDoListChange(ReadOnlyToDoList addedToDos, ReadOnlyToDoList deletedToDos) {
        this.addedToDos = new ToDoList(addedToDos);
        this.deletedToDos = new ToDoList(deletedToDos);
    }

    /**
     * Gets a read-only list of read-only to-dos to be added in this change
     *
     * @return list of to-dos to add
     */
    public ReadOnlyToDoList getAddedToDos() {
        return addedToDos;
    }

    /**
     * Gets a read-only list of read-only to-dos to be deleted in this change
     *
     * @return list of to-dos to delete
     */
    public ReadOnlyToDoList getDeletedToDos() {
        return deletedToDos;
    }

    /**
     * Gets the reverse of the current change.
     *
     * @return reverse of this change
     */
    public ToDoListChange getReverseChange() {
        return new ToDoListChange(deletedToDos, addedToDos);
    }

    @Override
    public boolean equals(Object other) {
        // short circuit if same object
        // instanceof handles nulls
        return other == this
            || (other instanceof ToDoListChange
            && addedToDos.equals(((ToDoListChange) other).addedToDos)
            && deletedToDos.equals(((ToDoListChange) other).deletedToDos));
    }

    @Override
    public int hashCode() {
        return Objects.hash(addedToDos, deletedToDos);
    }

    @Override
    public String toString() {
        return "To add " + addedToDos + ",a to delete " + deletedToDos;
    }
}
```
###### \java\seedu\commando\model\ToDoListManager.java
``` java
/**
 * In charge of supporting the editing, undoing and redoing of the to-do list,
 *   hinging on the {@link ToDoListChange} class.
 */
public class ToDoListManager {
    private final ToDoList toDoList;

    // changes that can be undone
    private final ArrayList<ToDoListChange> toDoListChanges = new ArrayList<>();

    // changes that can be redone
    private final ArrayList<ToDoListChange> toDoListUndoChanges = new ArrayList<>();

    private ToDoListChange lastToDoListChange;

    /**
     * Initializes with the given to-do list, which is managed internally.
     * Asserts parameters are non-null.
     *
     * @param toDoList the internal to-do list will be a deep copy of this
     */
    public ToDoListManager(ReadOnlyToDoList toDoList) {
        assert toDoList != null;

        this.toDoList = new ToDoList(toDoList);
    }

    /**
     * @see Model#getToDoList()
     */
    public ReadOnlyToDoList getToDoList() {
        return toDoList;
    }

    /**
     * @see Model#changeToDoList(ToDoListChange)
     */
    public void changeToDoList(ToDoListChange change) throws IllegalValueException {
        applyToDoListChange(change);
        toDoListChanges.add(change);

        // Reset undo list upon a change
        toDoListUndoChanges.clear();
    }

    /**
     * @see Model#undoToDoList()
     */
    public boolean undoToDoList() {
        // Nothing else to undo if the list of changes is empty
        if (toDoListChanges.isEmpty()) {
            return false;
        }

        ToDoListChange change = toDoListChanges.get(toDoListChanges.size() - 1);

        try {
            applyToDoListChange(change.getReverseChange());
        } catch (IllegalValueException exception) {
            // undo should always work
            assert false;
            return false;
        }

        // move changes from change list to to undo change list
        toDoListUndoChanges.add(change);
        toDoListChanges.remove(toDoListChanges.size() - 1);

        return true;
    }

    /**
     * @see Model#redoToDoList()
     */
    public boolean redoToDoList() {
        // Check if there are any undos to redo
        if (toDoListUndoChanges.isEmpty()) {
            return false;
        }

        ToDoListChange change = toDoListUndoChanges.get(toDoListUndoChanges.size() - 1);

        try {
            applyToDoListChange(change);
        } catch (IllegalValueException exception) {
            // Redo should always work
            assert false;
            return false;
        }

        // move changes from undo change list to change list
        toDoListChanges.add(change);
        toDoListUndoChanges.remove(toDoListUndoChanges.size() - 1);

        return true;
    }

    /**
     * Tries to apply a change to the to-do list.
     * @throws IllegalValueException if there were duplicate to-dos added or
     *   there were non-existent to-dos deleted.
     */
    private void applyToDoListChange(ToDoListChange change) throws IllegalValueException {
        lastToDoListChange = change;

        toDoList.remove(change.getDeletedToDos());

        try {
            toDoList.add(change.getAddedToDos());
        } catch (IllegalValueException exception) {
            // there were duplicate to-dos
            // revert removal of to-dos
            toDoList.add(change.getDeletedToDos());
            lastToDoListChange = null;
            throw exception;
        }
    }

    /**
     * Gets the last successful change to the to-do list, considering undos and redos
     *
     * @return an optional of the last change, empty if there was none
     */
    public Optional<ToDoListChange> getLastToDoListChange() {
        return Optional.ofNullable(lastToDoListChange);
    }
}
```
###### \java\seedu\commando\model\ui\UiModel.java
``` java

/**
 * In charge of processing and filtering the list of to-dos for the UI.
 */
public class UiModel {
    private final ToDoListManager toDoListManager;
    private final ObservableList<UiToDo> events = FXCollections.observableArrayList();
    private final ObservableList<UiToDo> tasks = FXCollections.observableArrayList();
    private final UnmodifiableObservableList<UiToDo> protectedEvents = new UnmodifiableObservableList<>(events);
    private final UnmodifiableObservableList<UiToDo> protectedTasks = new UnmodifiableObservableList<>(tasks);
    private final ArrayList<UiToDo> toDoAtIndices = new ArrayList<>();
    private int runningIndex;

    // Parameters for filtering
    private Model.FILTER_MODE filterMode = Model.FILTER_MODE.ALL;

    /**
     * @param toDoListManager ToDoListManager it tracks and grabs the list of to-dos from
     */
    public UiModel(ToDoListManager toDoListManager) {
        this.toDoListManager = toDoListManager;

        // Initialize the filter to show unfinished to-dos
        clearToDoListFilter(Model.FILTER_MODE.UNFINISHED);

        // Start tracking changes to-do list, and update UI to-dos when a change happens
        toDoListManager.getToDoList().getToDos().addListener(new ListChangeListener<ReadOnlyToDo>() {
            @Override
            public void onChanged(Change<? extends ReadOnlyToDo> change) {
                clearToDoListFilter(filterMode);
            }
        });
    }

    /**
     * @see Model#getUiToDoAtIndex(int)
     */
    public Optional<UiToDo> getToDoAtIndex(int index) {
        if (index - 1 < 0 || index - 1 >= toDoAtIndices.size()) {
            return Optional.empty();
        } else {
            return Optional.of(toDoAtIndices.get(index - 1));
        }
    }

    /**
     * @see Model#clearUiToDoListFilter(Model.FILTER_MODE)
     */
    public void clearToDoListFilter(Model.FILTER_MODE filterMode) {
        assert !CollectionUtil.isAnyNull(filterMode);
        setToDoListFilter(Collections.emptySet(), Collections.emptySet(), filterMode);
    }

    /**
     * @see Model#setUiToDoListFilter(Set, Set, Model.FILTER_MODE)
     */
    public void setToDoListFilter(Set<String> keywords, Set<Tag> tags, Model.FILTER_MODE filterMode) {
        assert !CollectionUtil.isAnyNull(keywords, tags, filterMode);

        this.filterMode = filterMode;

        updateEventsAndTasks(keywords, tags);
    }

```
###### \java\seedu\commando\model\ui\UiModel.java
``` java

    /**
     * @see Model#getUiEvents()
     */
    public UnmodifiableObservableList<UiToDo> getEvents() {
        return protectedEvents;
    }

    /**
     * @see Model#getUiTasks()
     */
    public UnmodifiableObservableList<UiToDo> getTasks() {
        return protectedTasks;
    }

    /**
     * Update the UI to-dos based on {@link #toDoListManager}'s to-do list and
     * the keywords and tags filter.
     */
    private void updateEventsAndTasks(Set<String> keywords, Set<Tag> tags) {
        // Sort and filter events and tasks for UI
        List<ReadOnlyToDo> events = filterAndSortEvents(toDoListManager.getToDoList().getToDos(), keywords, tags);
        List<ReadOnlyToDo> tasks = filterAndSortTasks(toDoListManager.getToDoList().getToDos(), keywords, tags);

        // Update its own lists of UI to-dos
        updateUiToDos(events, tasks);
    }

```
###### \java\seedu\commando\model\ui\UiModel.java
``` java

    /**
     * Populate its lists of UI to-dos based on supplied to-dos
     */
    private void updateUiToDos(List<ReadOnlyToDo> events, List<ReadOnlyToDo> tasks) {
        toDoAtIndices.clear();
        runningIndex = 0;

        Optional<ToDoListChange> lastChange = toDoListManager.getLastToDoListChange();

        ReadOnlyToDoList newToDos = lastChange.isPresent()
            ? lastChange.get().getAddedToDos() : new ToDoList();

        // Map each event to a UI to-do and add an index to each
        // Also check if the events are new with respect to last change
        this.events.setAll(events.stream().map(
            toDo -> new UiToDo(toDo, ++runningIndex, newToDos.contains(toDo))
        ).collect(Collectors.toList()));
        toDoAtIndices.addAll(this.events);

        // Then do the same for tasks
        this.tasks.setAll(tasks.stream().map(
            toDo -> new UiToDo(toDo, ++runningIndex, newToDos.contains(toDo))
        ).collect(Collectors.toList()));
        toDoAtIndices.addAll(this.tasks);

        // running index should be incremented by no. of to-dos
        assert runningIndex == toDoAtIndices.size();
    }
```
###### \java\seedu\commando\model\ui\UiModel.java
``` java
    private List<ReadOnlyToDo> filterAndSortTasks(List<ReadOnlyToDo> toDos,
                                                  Set<String> keywords, Set<Tag> tags) {
        List<ReadOnlyToDo> tasks = toDos.stream()
            .filter(toDoFilterModePredicate)
            .filter(toDo -> ifMatchesKeywordsAndTags(toDo, keywords, tags))
            .filter(UiToDo::isTask)
            .collect(Collectors.toList());

        // For tasks, sort by created date first (latest first)
        tasks.sort((task1, task2) -> task2.getDateCreated().compareTo(task1.getDateCreated()));

        // Then, by whether they have due date and that date (latest first)
        tasks.sort((task1, task2) -> compareDueDates(task1, task2));

        // Then, by whether they are finished and finished date (latest first)
        tasks.sort((task1, task2) -> compareDateFinished(task2, task1));

        return tasks;
    }

    private List<ReadOnlyToDo> filterAndSortEvents(List<ReadOnlyToDo> toDos,
                                                   Set<String> keywords, Set<Tag> tags) {
        List<ReadOnlyToDo> events = toDos.stream()
            .filter(toDoFilterModePredicate)
            .filter(toDo -> ifMatchesKeywordsAndTags(toDo, keywords, tags))
            .filter(UiToDo::isEvent)
            .collect(Collectors.toList());

        // For events, sort by created date first (latest first)
        events.sort((event1, event2) -> event2.getDateCreated().compareTo(event1.getDateCreated()));

        // Then, by start dates (earlier first)
        events.sort((event1, event2) -> compareDateRangeStarts(event1, event2));

        // Then, by whether they are finished and finished date (latest first)
        events.sort((event1, event2) -> compareDateFinished(event2, event1));

        return events;
    }

    //================================================================================
    //  Utility methods for sorting and filtering
    //================================================================================

    private int compareDateFinished(ReadOnlyToDo toDo1, ReadOnlyToDo toDo2) {
        LocalDateTime date1 = toDo1.getDateFinished().orElse(LocalDateTime.MAX);
        LocalDateTime date2 = toDo2.getDateFinished().orElse(LocalDateTime.MAX);

        return date1.compareTo(date2);
    }

    private int compareDueDates(ReadOnlyToDo toDo1, ReadOnlyToDo toDo2) {
        LocalDateTime date1 = toDo1.getDueDate().isPresent() ?
            toDo1.getDueDate().get().value : LocalDateTime.MAX;
        LocalDateTime date2 = toDo2.getDueDate().isPresent() ?
            toDo2.getDueDate().get().value : LocalDateTime.MAX;

        return date1.compareTo(date2);
    }

    private int compareDateRangeStarts(ReadOnlyToDo toDo1, ReadOnlyToDo toDo2) {
        LocalDateTime date1 = toDo1.getDateRange().isPresent() ?
            toDo1.getDateRange().get().startDate : LocalDateTime.MAX;
        LocalDateTime date2 = toDo2.getDateRange().isPresent() ?
            toDo2.getDateRange().get().startDate : LocalDateTime.MAX;

        return date1.compareTo(date2);
    }

    private boolean checkForKeyword(ReadOnlyToDo toDo, String keyword) {
        return StringUtil.substringIgnoreCase(toDo.getTitle().value, keyword) ||
            toDo.getTags().stream().anyMatch(toDoTag -> StringUtil.substringIgnoreCase(toDoTag.value, keyword));
    }

    private boolean checkForTag(ReadOnlyToDo toDo, Tag tag) {
        return toDo.getTags().stream().anyMatch(toDoTag -> toDoTag.value.equalsIgnoreCase(tag.value));
    }

    /**
     * Predicate that filters to-dos based on filter mode
     */
    private Predicate<ReadOnlyToDo> toDoFilterModePredicate = toDo -> {
        switch (filterMode) {
            case ALL:
                return true;
            case UNFINISHED:
                // if unfinished mode but to-do is finished before the current day
                return !toDo.isFinished()
                    || (toDo.isFinished() && toDo.getDateFinished().get().toLocalDate().isEqual(LocalDate.now()));
            case FINISHED:
                // if finished mode but to-do is unfinished
                return toDo.isFinished();
            default:
                assert false : "Should have covered all filter modes";
                return false;
        }
    };

    /**
     * Returns whether a to-do matches a set of keywords and tags
     */
    private boolean ifMatchesKeywordsAndTags(ReadOnlyToDo toDo, Set<String> keywords, Set<Tag> tags) {
        return (keywords.stream()
            .allMatch(keyword -> checkForKeyword(toDo, keyword)))
            && (tags.stream()
            .allMatch(tag -> checkForTag(toDo, tag)));
    }
}
```
###### \java\seedu\commando\model\ui\UiToDo.java
``` java

/**
 * Represents a to-do on the UI.
 */
public class UiToDo implements ReadOnlyToDo {

    private final ReadOnlyToDo toDo;
    private final int index;
    private final boolean isNew;

    public UiToDo(ReadOnlyToDo toDo, int index, boolean isNew) {
        this.toDo = toDo;
        this.isNew = isNew;
        this.index = index;
    }

    /**
     * Returns whether a to-do item is an event
     */
    public static boolean isEvent(ReadOnlyToDo todo) {
        return todo.getDateRange().isPresent();
    }

    /**
     * Returns whether a to-do item is a task
     */
    public static boolean isTask(ReadOnlyToDo todo) {
        return !todo.getDateRange().isPresent();
    }

    @Override
    public Title getTitle() {
        return toDo.getTitle();
    }

    @Override
    public Optional<DateRange> getDateRange() {
        return toDo.getDateRange();
    }

    @Override
    public Optional<DueDate> getDueDate() {
        return toDo.getDueDate();
    }

    @Override
    public Set<Tag> getTags() {
        return toDo.getTags();
    }

    @Override
    public boolean isFinished() {
        return toDo.isFinished();
    }

    @Override
    public Optional<LocalDateTime> getDateFinished() {
        return toDo.getDateFinished();
    }

    @Override
    public LocalDateTime getDateCreated() {
        return toDo.getDateCreated();
    }

    @Override
    public ObservableValue getObservableValue() {
        return toDo.getObservableValue();
    }

    /**
     * @return index of the to-do on the UI.
     */
    public int getIndex() {
        return index;
    }

    /**
     * @return whether the to-do is newly added or edited.
     */
    public boolean isNew() {
        return isNew;
    }

    public boolean isEvent() {
        return isEvent(this);
    }

    public boolean isTask() {
        return isTask(this);
    }

    @Override
    public boolean equals(Object other) {
        // short circuit if same object
        // instanceof handles nulls
        return other == this
            || (other instanceof UiToDo
            && this.isSameStateAs((UiToDo) other)
            && index == ((UiToDo) other).index
            && isNew == ((UiToDo) other).isNew);
    }

    @Override
    public int hashCode() {
        return Objects.hash(toDo, index, isNew);
    }

    @Override
    public String toString() {
        return toDo + " with index of " + index
            + (isNew ? "(new)" : "");
    }
}
```
###### \java\seedu\commando\model\UserPrefs.java
``` java

/**
 * Represents the user's preferences.
 */
public class UserPrefs {
    private GuiSettings guiSettings = new GuiSettings();
    private StringProperty toDoListFilePath = new SimpleStringProperty(Config.DefaultToDoListFilePath);

    public UserPrefs() {
    }

    public GuiSettings getGuiSettings() {
        return guiSettings;
    }

    /**
     * Gets its to-do list file path,
     *
     * @return an observable string value of its to-do list file path.
     */
    public ObservableValue<String> getToDoListFilePath() {
        return toDoListFilePath;
    }

    /**
     * Sets its to-do list file path and triggers change listeners of {@link #getToDoListFilePath()}
     */
    public void setToDoListFilePath(String filePath) {
        toDoListFilePath.setValue(filePath);
    }


    /**
     * Sets its GUI settings to that given.
     * Does a deep copy of {@param guiSettings}.
     */
    public void setGuiSettings(GuiSettings guiSettings) {
        this.guiSettings = new GuiSettings(guiSettings);
    }

    /**
     * @see #setGuiSettings(GuiSettings)
     */
    public void setGuiSettings(double width, double height, int x, int y, boolean isMaximized) {
        guiSettings = new GuiSettings(width, height, x, y, isMaximized);
    }

    @Override
    public boolean equals(Object other) {
        // short circuit if same object
        // instanceof handles nulls
        return other == this
            || (other instanceof UserPrefs
            && (guiSettings.equals(((UserPrefs) other).guiSettings)
            && toDoListFilePath.getValue().equals(((UserPrefs) other).toDoListFilePath.getValue())));
    }

    @Override
    public int hashCode() {
        return Objects.hash(guiSettings, toDoListFilePath);
    }

    @Override
    public String toString() {
        return String.join(",",
            "Gui Settings: " + guiSettings,
            "To-do List File Path: " + toDoListFilePath.getValue()
        );
    }

    /**
     * Gets a {@link JsonObject} that fully defines its current state.
     *
     * @return a json object that fully defines its state.
     */
    public JsonObject getJsonObject() {
        JsonObject jsonObject = new JsonObject();
        jsonObject.guiSettings = guiSettings;
        jsonObject.toDoListFilePath = toDoListFilePath.getValue();
        return jsonObject;
    }

    /**
     * Sets fields of user prefs to that of {@param jsonObject}.
     * If any of the fields are null, the default of user prefs are used.
     */
    public void setJsonObject(JsonObject jsonObject) {
        if (jsonObject.guiSettings != null) {
            guiSettings = jsonObject.guiSettings;
        }

        if (jsonObject.toDoListFilePath != null) {
            toDoListFilePath.setValue(jsonObject.toDoListFilePath);
        }
    }

    public static class JsonObject {
        public GuiSettings guiSettings;
        public String toDoListFilePath;
    }
}
```
###### \resources\userguide\stylesheets\custom.css
``` css

kbd.light {
    display: inline-block;
    vertical-align: middle;
    background-color: #fcfcfc;
    border: solid 1px #ccc;
    border-bottom-color: #bbb;
    border-radius: 3px;
    box-shadow: inset 0 -1px 0 #bbb;
}

.command-format {
    background: #440000;
    position: relative;
}

.datagrid.class table {
    width: auto;
}

.datagrid.class table th {
    text-align: center;
}
```
###### \resources\userguide\user.html
``` html
                <p><em>You have a ton of things to do. But you are really tired of the amount of mouse-clicking to add to-dos in your to-do list management application...</em></p>
                <p>
                    Introducing <em>CommanDo</em>: it is THE to-do list manager allows you to swiftly edit your to-do list by typing out commands, mouse-free. Commands in <em>CommanDo</em> are short and intuitive, and it flows just like natural English! <em>CommanDo</em> recognizes and actively categorizes to-dos into 2 groups: <em>Events</em>, which are to-dos with time windows, and <em>Tasks</em>, which are to-dos accompanied optionally by a deadline. Here's <em>CommanDo</em> at work:
                </p>

                <figure>
                    <img src="images/Ui.png" width="600">
                    <figcaption>Using <em>CommanDo</em> to manage everything in your life</figcaption>
                </figure>

                <p>Ready to spend less time managing your to-dos and more time actually doing them? <a href="#quick-start">Start using <em>CommanDo</em> today!</a></p>
                
```
###### \resources\userguide\user.html
``` html
                <blockquote>
                    <b>Understanding Command Formats:</b> For each command, the first word is the <em>command word</em> that specifies the type of the command. What follows after are fields to fill in for that command. The following legend describes the syntax we used to specify command formats:
                    <ol class="indent">
                        <li>
                            <code><span class="inputstart">&lt;&gt;</span></code> denotes a field to fill in
                        </li>
                        <li>
                            <code>[]</code> denotes that the fields within it are optional
                        </li>
                        <li>
                            <code>/</code> separates alternatives to a keyword
                        </li>
                        <li>
                            <code>...</code> denotes that the preceding field can be repeated (i.e. able to have multiple values)
                        </li>
                    </ol>
                </blockquote>

```
###### \resources\userguide\user.html
``` html
                <blockquote>
                    <b>Datetime Formats:</b> <em>CommanDo</em> is pretty flexible in parsing your datetime fields, accepting formats like <code>5 Jan 2016 2300</code> and <code>28/12/2016 12pm</code> (where date is in the <code>DD/MM/YYYY</code> format). You can drop the year (if you mean the current year) or even a whole date (if you mean a preceding date or the current date). For the full list of usable datetime formats, refer to the later FAQ section on <a href="#supported-datetime-formats">supported datetime formats</a>.
                </blockquote>

                <figure>
                    <img src="images/Userguide/addEvent.png" width="600">
                    <figcaption>
                        Result of adding a <em>Event</em> with command:
                        <code>>> add wild party in hostel room from 31 Dec 2016 to 1 Jan 2017</code>
                    </figcaption>
                </figure>
                
                <figure>
                    <img src="images/Userguide/addEvent.png" width="600">
                    <figcaption>Result of adding a recurring <em>Event</em> with command:
                    <code>>> add physics revision from tues 9.30pm to 10pm weekly #physics</code></figcaption>
                </figure>
               
                <blockquote>
                    <b>Finding Past <em>Events</em>:</b> <em>CommanDo</em> automatically hides <em>Events</em> that are before the current day. The <a href="#recall"><code>recall</code> command</a> will allow you to browse through them.
                </blockquote>

```
###### \resources\userguide\user.html
``` html

                <pre><span class="inputstart">&gt;&gt;</span> add <span>walk from here to there</span></pre>
                <span>What it does:  Adds a <em>Task</em> with description <code>walk from here to there</code>. Although it looks like the format of an <em>Event</em>, <em>CommanDo</em> recognises that <code>here</code> and <code>there</code> are invalid datetimes.</span>
                <pre><span class="inputstart">&gt;&gt;</span> add <span>code parser to parse by tomorrow</span> by <span>today</span></pre>
                <span>What it does:  Adds a <em>Task</em> with description <code>code parser to parse by tomorrow</code> with deadline of <code>today</code></span>

                <figure>
                    <img src="images/Userguide/addDdl.png" width="600">
                    <figcaption>Result of adding a <em>Task</em> with command: <code>>> add finish FYP by tomorrow 2359h</code></figcaption>
                </figure>

```
###### \resources\userguide\user.html
``` html
                <h3 id="finish">Marking Tasks as Done: <code>finish</code></h3>

                <p>When you've completed a <em>Task</em>, mark it as done with the <code>finish</code> command. The to-do will initially be moved to the bottom of its list, and subsequently be hidden and archived on the next day. You'll be able to browse through these finished <em>Tasks</em> with the <a href="#recall"><code>recall</code> command</a>.</p>

                <span><strong>Command Formats:</strong></span>
                <pre class="command-format"><span class="inputstart">&gt;&gt;</span> finish <span>&lt;index&gt;</span>... </pre>
                <pre class="command-format"><span class="inputstart">&gt;&gt;</span> finish <span>&lt;start index&gt;</span> - <span>&lt;end index&gt;</span> </pre>

                <figure>
                    <img src="images/Userguide/finish.png" width="600">
                    <figcaption>Result of finishing the Task <code>release software V0.5</code> with <code>finish</code></figcaption>
                </figure>

                <h3 id="find">Finding To-Dos: <code>find</code></h3>

                <p>So you now have a long list of to-dos. Use the <code>find</code> command to search for specific to-dos by their description or their tags. The search targets all upcoming <em>Events</em> (from the current day onwards) and all unfinished <em>Tasks</em>. After doing the search, use the <code>find</code> command again without any keywords to revert to showing all upcoming <em>Events</em> and unfinished <em>Tasks</em>.</p>

                <span><strong>Command Format:</strong></span>
                <pre class="command-format"><span class="inputstart">&gt;&gt;</span> find [<span>&lt;keyword&gt;</span>...] [#<span>&lt;tag&gt;</span>...]</pre>

                <span><strong>Examples:</strong></span>
                <pre><span class="inputstart">&gt;&gt;</span> find <span>lunch meeting</span></pre>
                <span>What it does:   Filters to show only <em>Events</em> and <em>Tasks</em> from the current day onwards, with description or tags matching both <code>lunch</code> and <code>meeting</code>.</span>

                <pre><span class="inputstart">&gt;&gt;</span> find #<span>homework</span></pre>
                <span>What it does:    Filters to show only <em>Events</em> and <em>Tasks</em> from the current day onwards, with a tag <code>#homework</code>.</span>

                <pre><span class="inputstart">&gt;&gt;</span> find</pre>
                <span>What it does:   Clears previous <code>find</code> command and shows all to-dos from the current day onwards.</span>
                
                <p>
                    More details on how <code>find</code> works:
                    <ul id="search-logic">
                        <li>
                            For a to-do to be matched, all search keywords must be matched in its description and tags, and all search tags must be matched in its tags. 
                        </li>
                        <li>
                            Orderings of the search keywords and tags do not matter ? keywords <code>Chicken Egg</code> will match <code> Egg Chicken</code>.
                        </li>
                        <li>
                            Search keywords (but not tags) will match parts of words ? keyword <code>chicken</code> will match <code>chickens</code>, whereas keyword <code>chickens</code> will not match <code>chicken</code>.
                        </li>
                    </ul>
                </p>

                <figure>
                    <img src="images/Userguide/find.png" width="600">
                    <figcaption>Result of <code>>> find read</code></figcaption>
                </figure>

                <h3 id="recall">Browsing To-Dos that are Done: <code>recall</code></h3>

                <p>When you need to review, refer back to, or search through the <em>Events</em> that are over or <em>Tasks</em> that you have finished, use the <code>recall</code> command. It works exactly the same way as the <code>find</code> command - except it only shows to-dos that are considered done. </p>

                <span><strong>Command Format:</strong></span>
                <pre class="command-format"><span class="inputstart">&gt;&gt;</span> recall [<span>&lt;keyword&gt;</span>...] [#<span>&lt;tag&gt;</span>...]</pre>

                <span><strong>Examples:</strong></span>

                <pre><span class="inputstart">&gt;&gt;</span> recall</pre>
                <span>What it does:   Show only <em>Events</em> that are already over and <em>Tasks</em> that have been finished. </span>

                <pre><span class="inputstart">&gt;&gt;</span> recall <span>wedding</span></pre>
                <span>What it does:   Filters to show only <em>Events</em> that are already over and <em>Tasks</em> that have been finished, with description or tags matching <code>wedding</code>.</span>
                
                <figure>
                    <img src="images/Userguide/find.png" width="600">
                    <figcaption>Result of <code>>> recall wedding</code></figcaption>
                </figure>               

                <h3 id="unfinish">Marking Tasks as Not Done: <code>unfinish</code></h3>

                <p>Oops, you marked a task as done when it's not exactly done. Simply bring up the list of finished tasks using the <a href="#recall"><code>recall</code> command</a>, then use the <code>unfinish</code> command.</p>

                <span><strong>Command Format:</strong></span>
                <pre class="command-format"><span class="inputstart">&gt;&gt;</span> unfinish <span>&lt;index&gt;</span>... </pre>
                <pre class="command-format"><span class="inputstart">&gt;&gt;</span> unfinish <span>&lt;start index&gt;</span> - <span>&lt;end index&gt;</span> </pre>

                <h3 id="store">Setting Save Location: <code>store</code></h3>

                <p>Perhaps you want to save your to-do list in your <em>Dropbox</em> or <em>OneDrive</em> folder that is cloud-synced. The <code>store</code> command lets you do exactly that - it migrates the save file to that of the given file path. Note that the default save location is <code>./data/todos.xml</code>.</p>

                <span><strong>Command Format:</strong></span>
                <pre class="command-format">&gt;&gt; store <span>&lt;file_path&gt;</span></pre>

                <span><strong>Examples:</strong></span>
                <pre><span class="inputstart">&gt;&gt;</span> store <span>../../Dropbox/work/todolist.xml</span></pre>
                <span>What it does:   Changes the default file path to store the to-do list data to <code>../../Dropbox/work/todolist.xml</code> relative to your <code>commando.jar</code>, and saves the latest data to that file.</span>

                <blockquote>
                    <b>File Paths:</b> A file path can be absolute (<code>C:/Users/Jim/Dropbox/work/todolist.xml</code>) or relative to the <code>commando.jar</code> file (<code>../../Dropbox/work/todolist.xml</code>). You can use any file extension you wish, but ending with <code>.xml</code> is recommended because the date file is in <em>XML</em>.
                </blockquote>

```
###### \resources\userguide\user.html
``` html
                <h3>3. Is sharing across devices supported?</h3>

                <p><em>CommanDo</em> doesn't directly support syncing of the to-do list across devices. Instead, use the <code>export</code> command to generate a save data file, transfer the file to another device, and use the <code>import</code> command on the 2nd device to import your to-do list from that save file. Alternatively, use a cloud-syncing service (e.g. <a href="dropbox.com">Dropbox</a>) and the <code>store</code> command to sync the to-do list automatically by setting the save location to the same file on both devices. </p>

                <h3>4. I have some <em>Events</em> or <em>Tasks</em> that are not appearing!</h3>

                <p><em>CommanDo</em> automatically hides <em>Events</em> that are already over and <em>Tasks</em> that are already marked done, to ensure that your to-do list is kept clean. To see these to-dos, use the <a href="#recall"><code>recall</code> command</a>. </p>

                <h3>5. I keep forgetting how to use certain commands.</h3>

                <p>The <code>help</code> command can be used to quickly summon this guide or a relevant section of this guide when you need it. Alternatively, you can just try typing your command - if it is invalid, <em>CommanDo</em> will display the correct command format for that command in the command feedback box just below the command input. This might be helpful for you to correctively learn the command format.</p>

                <h3 id="supported-date-time-formats">6. What date & time formats can I use in my commands?</h3>

                <p><em>CommanDo</em> supports a wide variety of date and time formats, backed by the awesome date parser library <a href="http://natty.joestelmach.com/" target="_blank">Natty</a>. A valid datetime contains a valid date, a valid time, or a valid date and time. A sample of the accepted date & time formats are shown below:</p>

```
###### \resources\userguide\user.html
``` html
                    <blockquote>
                        <b>Datetime without Date or Time:</b> If your datetime is missing a date or a time, <em>CommanDo</em> will try to infer it. With no date specified, it will be inferred as the current day, or if it is not the first datetime, it will inherit the date of the first datetime. With no time specified, it will be inferred as 1200h. 
                    </blockquote>
                </div>

```
