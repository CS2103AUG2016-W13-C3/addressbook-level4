# A0139697H
###### \java\seedu\commando\commons\core\Messages.java
``` java
    public static final String UNKNOWN_COMMAND = "Unknown command: '%1$s'. Input 'help' for instructions on how to use this application.";
    public static final String UNKNOWN_COMMAND_FOR_HELP = "Unknown topic for help: '%1$s'.\n" + 
                                                          "Available Topics: add, edit, delete, find, clear, finish, unfinish, recall, undo, redo, faq, search logic, datetime formats, cheatsheet";
    public static final String MISSING_COMMAND_WORD = "Missing command word.";
    public static final String INVALID_COMMAND_FORMAT = "Invalid format for '%1$s' command!";
    public static final String MISSING_TODO_TITLE = "Missing title for to-do.";
    
    public static final String MISSING_TODO_DATERANGE_START = "Missing start date for date range of to-do.";
    public static final String MISSING_TODO_DATERANGE_END = "Missing end date for date range of to-do.";
    public static final String INVALID_TODO_DATERANGE_START = "Invalid start date for date range of to-do.";
    public static final String INVALID_TODO_DATERANGE_END = "Invalid end date for date range of to-do.";
    public static final String TODO_DATERANGE_END_MUST_AFTER_START = "The end date of the date range must be after start date.";
    public static final String TODO_DATERANGE_RECURRENCE_INVALID = "The recurrence for the given date range is not valid.";
    
    public static final String MISSING_TODO_ITEM_INDEX = "Missing to-do item index.";
    
    public static final String INDEXRANGE_CONSTRAINTS = "The end index must be equal or larger than the start index.";
    
    public static final String MISSING_STORE_PATH = "Missing the path to store.";
    public static final String MISSING_IMPORT_PATH = "Missing the path to import.";
    public static final String MISSING_EXPORT_PATH = "Missing the path to export.";
    
    public static final String MISSING_STORE_FILE = "Missing the file name to store.";
    public static final String MISSING_EXPORT_FILE = "Missing the file name to export.";
    public static final String MISSING_IMPORT_FILE = "Missing the file name to import.";
    
    public static final String TODO_DUEDATE_CONSTRAINTS = "Due date can be any date.";
    public static final String TODO_CANNOT_HAVE_DUEDATE_AND_DATERANGE = "To-do cannot have both due date and date range!";
    public static final String TODO_ADDED = "To-do added: %1$s.";
    public static final String TODO_DELETED = "To-do deleted: %1$s.";
    public static final String TODO_EDITED = "To-do edited: %1$s.";
    public static final String TODO_NO_EDITS = "But nothing happened.";
    public static final String TODO_NOT_FOUND = "To-do not found: %1$s";
    public static final String TODO_ITEM_INDEX_INVALID = "Invalid to-do index: %1$d.";
    
    public static final String EXIT_APPLICATION = "Exiting application...";
    public static final String TODO_LIST_CLEARED = "Boom. Cleared to-do list!";
    public static final String HELP_WINDOW_SHOWN = "Opened help window.";
    public static final String FIND_COMMAND = "Found %1$d events and %2$d tasks.";
    public static final String RECALL_COMMAND = "Found %1$d past events and %2$d completed tasks.";
    public static final String FIND_COMMAND_CLEAR = "Listed all to-do items.";
    public static final String RECALL_COMMAND_CLEAR = "Listed all past to-do items.";
    public static final String FINISH_COMMAND = "Task marked as done: %1$s.";
    public static final String FINISH_COMMAND_ALREADY_FINISHED = "Task already marked done: %1$s";
    public static final String FINISH_COMMAND_CANNOT_FINISH_EVENT = "To-do must be a task to be marked done: %1$s.";
    public static final String UNFINISHED_COMMAND = "Task marked as undone: %1$s.";
    public static final String UNFINISH_COMMAND_ALREADY_ONGOING = "Task already marked undone: %1$s.";
    public static final String UNFINISH_COMMAND_CANNOT_UNFINISH_EVENT = "To-do must be a task to be marked undone: %1$s.";
    public static final String UNDO_COMMAND = "Undid the last command.";
    public static final String UNDO_COMMAND_FAIL = "Nothing more to undo!";
    public static final String REDO_COMMAND = "Redid the last undo command.";
    public static final String REDO_COMMAND_FAIL = "Nothing more to redo!";
    public static final String STORE_COMMAND = "Changed the storage path to: %1$s.";
    public static final String STORE_COMMAND_FILE_EXIST = "Failed to store the storage file to %1$s: destination file exists";
    public static final String EXPORT_COMMAND = "Export the storage file to: %1$s.";
    public static final String EXPORT_COMMAND_FILE_EXIST = "Failed to export the storage file to %1$s: destination file exists";
    public static final String IMPORT_COMMAND = "Import the storage file from: %1$s.";
    public static final String IMPORT_COMMAND_FILE_NOT_EXIST = "Invalid import file: the file does not exist.";
    public static final String IMPORT_COMMAND_INVALID_DATA = "Invalid import file: the file is of an invalid format.";
    public static final String TODO_ALREADY_EXISTS = "To-do already exists!";
    public static final String DELETE_COMMAND_NO_TAGS = "To-do with index '%1$s' has no tags to delete!";
    public static final String DELETE_COMMAND_NO_TIME_CONSTRAINTS = "To-do with index '%1$s' has no time constraints to delete!";

```
###### \java\seedu\commando\logic\commands\AddCommand.java
``` java
public class AddCommand extends Command {

    public static final String COMMAND_WORD = "add";

    private final Title title;
    public DateRange dateRange;
    public DueDate dueDate;
    public Set<Tag> tags = Collections.emptySet();

    public AddCommand(Title title) {
        assert title != null;

        this.title = title;
    }

    @Override
    public CommandResult execute() throws NoModelException {
        Model model = getModel();

        // Create the to-do to add
        ToDo toDo = new ToDo(title);

        // Set fields if exist
        if (dueDate != null) {
            toDo.setDueDate(dueDate);
        }

        if (dateRange != null) {
            toDo.setDateRange(dateRange);
        }

        if (tags != null) {
            toDo.setTags(tags);
        }

        // Ensure to-do doesn't have both duedate and daterange
        if (toDo.getDateRange().isPresent() && toDo.getDueDate().isPresent()) {
            return new CommandResult(Messages.TODO_CANNOT_HAVE_DUEDATE_AND_DATERANGE, true);
        }

        try {
            model.changeToDoList(new ToDoListChange(
                new ToDoList().add(toDo),
                new ToDoList()
            ));
        } catch (IllegalValueException exception) {
            return new CommandResult(exception.getMessage(), true);
        }

        return new CommandResult(String.format(Messages.TODO_ADDED, toDo.getTitle().toString()));
    }
}
```
###### \java\seedu\commando\logic\commands\ClearCommand.java
``` java
/**
 * Clears the to-do list
 */
public class ClearCommand extends Command {

    public static final String COMMAND_WORD = "clear";

    public ClearCommand() {}

    @Override
    public CommandResult execute() throws NoModelException {
        Model model = getModel();

        try {
            // Delete all to-dos
            model.changeToDoList(new ToDoListChange(
                new ToDoList(),
                model.getToDoList()
            ));
        } catch (IllegalValueException exception) {
            return new CommandResult(exception.getMessage(), true);
        }

        return new CommandResult(Messages.TODO_LIST_CLEARED);
    }
}
```
###### \java\seedu\commando\logic\commands\Command.java
``` java
/**
 * Represents a command with hidden internal logic and the ability to be executed
 */
public abstract class Command {

    private EventsCenter eventsCenter;
    private Model model;

    /**
     * Sets the EventsCenter for the command
     * {@param eventsCenter} must be non-null
     */
    public void setEventsCenter(EventsCenter eventsCenter) {
        assert eventsCenter != null;

        this.eventsCenter = eventsCenter;
    }

    /**
     * Sets the Model for the command
     * {@param model} must be non-null
     */
    public void setModel(Model model) {
        assert model != null;

        this.model = model;
    }

    public static class NoEventsCenterException extends Exception {}

    public static class NoModelException extends Exception {}

    protected EventsCenter getEventsCenter() throws NoEventsCenterException {
        if (eventsCenter == null) {
            throw new NoEventsCenterException();
        }

        return eventsCenter;
    }

    protected Model getModel() throws NoModelException {
        if (model == null) {
            throw new NoModelException();
        }

        return model;
    }

    /**
     * Executes the command
     * @return result of the command
     */
    public abstract CommandResult execute() throws NoModelException, NoEventsCenterException;
}
```
###### \java\seedu\commando\logic\commands\CommandFactory.java
``` java
/**
 * Maps and builds commands from input strings, using {@link SequentialParser}
 * In charge of splitting up input strings to required parts for commands
 * Doesn't set context for commands
 */
public class CommandFactory {
    private static final String KEYWORD_DELETE_TIME = "time";
    private static final String KEYWORD_DELETE_TAG = "tag";

    private SequentialParser sequentialParser  = new SequentialParser();

    public static class InvalidCommandFormatException extends Exception {
        public final String command;

        public InvalidCommandFormatException(String message, String command) {
            super(message);
            this.command = command;
        }
    }

    public static class UnknownCommandWordException extends Exception {
        public final String commandWord;
        UnknownCommandWordException(String commandWord) {
            this.commandWord = commandWord;
        }
    }
    
    public static class MissingCommandWordException extends Exception {}

    /**
     * Interprets an input string as a command, initializes it, and returns it
     * @return instance of a command
     */
    public Command build(String inputString) throws InvalidCommandFormatException,
        UnknownCommandWordException, MissingCommandWordException {
        sequentialParser.setInput(inputString);

        // Check if command word exists
        Optional<String> commandWord = sequentialParser.extractWord();

        if (!commandWord.isPresent()) {
            throw new MissingCommandWordException();
        }

        String processedCommandWord = commandWord.get().toLowerCase();
        try {
            switch (processedCommandWord) {
                case AddCommand.COMMAND_WORD:
                    return buildAddCommand();
                case DeleteCommand.COMMAND_WORD:
                    return buildDeleteCommand();
                case FinishCommand.COMMAND_WORD:
                    return buildFinishCommand();
                case UnfinishCommand.COMMAND_WORD:
                    return buildUnfinishCommand();
                case FindCommand.COMMAND_WORD:
                    return buildFindCommand();
                case ExitCommand.COMMAND_WORD:
                    return buildExitCommand();
                case ClearCommand.COMMAND_WORD:
                    return buildClearCommand();
                case HelpCommand.COMMAND_WORD:
                    return buildHelpCommand();
                case EditCommand.COMMAND_WORD:
                    return buildEditCommand();
                case UndoCommand.COMMAND_WORD:
                    return buildUndoCommand();
                case RedoCommand.COMMAND_WORD:
                    return buildRedoCommand();
                case StoreCommand.COMMAND_WORD:
                    return buildStoreCommand();
                case ExportCommand.COMMAND_WORD:
                    return buildExportCommand();
                case ImportCommand.COMMAND_WORD:
                    return buildImportCommand();
                case RecallCommand.COMMAND_WORD:
                    return buildRecallCommand();
                default:
                    throw new UnknownCommandWordException(processedCommandWord);
            }
        } catch (IllegalValueException e) {
            throw new InvalidCommandFormatException(e.getMessage(), processedCommandWord);
        }
    }

    private Command buildRecallCommand() {
        RecallCommand command = new RecallCommand();

        // Extract tags
        Set<Tag> tags = sequentialParser.extractTrailingTags();
        if (!tags.isEmpty()) {
            command.tags = tags;
        }

        // Try to find keywords
        command.keywords = sequentialParser.extractWords().stream().collect(Collectors.toSet());

        return command;
    }


    private Command buildExitCommand() throws IllegalValueException {
        if (!sequentialParser.isInputEmpty()) {
            throw new IllegalValueException(String.format(Messages.INVALID_COMMAND_FORMAT, ExitCommand.COMMAND_WORD));
        }

        return new ExitCommand();
    }
```
###### \java\seedu\commando\logic\commands\CommandResult.java
``` java
/**
 * Represents the result of a command execution.
 */
public class CommandResult {

    private final String feedback;
    private boolean hasError;

    /**
     * Result of a command
     * @param feedback feedback to be shown to user
     * @param hasError if there was an error and command failed
     */
    public CommandResult(String feedback, boolean hasError) {
        assert feedback != null;

        this.feedback = feedback;
        this.hasError = hasError;
    }

    /**
     * Result of successful command
     */
    public CommandResult(String feedback) {
       this(feedback, false);
    }

    public String getFeedback() {
        return feedback;
    }

    public boolean hasError() {
        return hasError;
    }
}
```
###### \java\seedu\commando\logic\commands\DeleteCommand.java
``` java
/**
 * Deletes to-do(s), or their fields.
 */
public class DeleteCommand extends Command {

    public static final String COMMAND_WORD = "delete";

    public final List<Integer> toDoIndices;
    public boolean ifDeleteTime = false;
    public boolean ifDeleteTag = false;

	public DeleteCommand(List<Integer> toDoIndices) {
		this.toDoIndices = toDoIndices;
	}
```
###### \java\seedu\commando\logic\commands\EditCommand.java
``` java
/**
 * Edits a to-do in the current to-do list
 * Public fields are initially null and are optional parameters for the command
 */
public class EditCommand extends Command {

    public static final String COMMAND_WORD = "edit";

    private final int toDoIndex;
    public Title title;
    public DateRange dateRange;
    public DueDate dueDate;
    public Set<Tag> tags;

    public EditCommand(int toDoIndex) {
        this.toDoIndex = toDoIndex;
    }

    public CommandResult execute() throws NoModelException {
        Model model = getModel();

        Optional<UiToDo> toDoToEdit = model.getUiToDoAtIndex(toDoIndex);

        if (!toDoToEdit.isPresent()) {
            return new CommandResult(String.format(Messages.TODO_ITEM_INDEX_INVALID, toDoIndex), true);
        }

        // Copy original to-do
        ToDo newToDo = new ToDo(toDoToEdit.get());

        // Set fields if exist
        if (title != null) {
            newToDo.setTitle(title);
        }

        if (dueDate != null) {
            newToDo.setDueDate(dueDate);
        }

        if (dateRange != null) {
            newToDo.setDateRange(dateRange);
        }

        if (tags != null) {
            newToDo.setTags(tags);
        }

        // Check if to-do has changed
        if (newToDo.isSameStateAs(toDoToEdit.get())) {
            return new CommandResult(Messages.TODO_NO_EDITS, true);
        }

        // Ensure to-do doesn't have both duedate and daterange
        if (newToDo.getDateRange().isPresent() && newToDo.getDueDate().isPresent()) {
            return new CommandResult(Messages.TODO_CANNOT_HAVE_DUEDATE_AND_DATERANGE, true);
        }

        try {
            model.changeToDoList(new ToDoListChange(
                new ToDoList().add(newToDo),
                new ToDoList().add(toDoToEdit.get())
            ));
        } catch (IllegalValueException exception) {
            return new CommandResult(exception.getMessage(), true);
        }

        return new CommandResult(String.format(Messages.TODO_EDITED, newToDo.getTitle().toString()));
    }
}
```
###### \java\seedu\commando\logic\commands\ExitCommand.java
``` java
/**
 * Terminates the program
 */
public class ExitCommand extends Command {

    public static final String COMMAND_WORD = "exit";

    public ExitCommand() {}

    @Override
    public CommandResult execute() throws NoEventsCenterException {
        EventsCenter eventsCenter = getEventsCenter();

        eventsCenter.post(new ExitAppRequestEvent());
        return new CommandResult(Messages.EXIT_APPLICATION);
    }
}
```
###### \java\seedu\commando\logic\commands\FindCommand.java
``` java
/**
 * Updates the filter for to-do list to show only to-do items containing all
 * of the keywords and tags (case insensitive)
 */
public class FindCommand extends Command {
    public static final String COMMAND_WORD = "find";

    public Set<String> keywords = Collections.emptySet();
    public Set<Tag> tags = Collections.emptySet();

    /**
     * Asserts that {@code uiLogic} is non-null
     */
    @Override
    public CommandResult execute() throws NoModelException {
        Model model = getModel();

        // if no keywords or tags are provided, clear filter
        if (keywords.isEmpty() && tags.isEmpty()) {
            model.clearUiToDoListFilter(false);
            return new CommandResult(Messages.FIND_COMMAND_CLEAR);
        }

        model.setUiToDoListFilter(keywords, tags, false);
        return new CommandResult(String.format(Messages.FIND_COMMAND, model.getUiEvents().size(), model.getUiTasks().size()));
    }
}
```
###### \java\seedu\commando\logic\commands\HelpCommand.java
``` java
/**
 * Format full help instructions for every command for display.
 */
public class HelpCommand extends Command {

    public static final String COMMAND_WORD = "help";

    private final String commandWord;

    /**
     * Shows general help
     */
    public HelpCommand() {
        commandWord = "";
    }

    /**
     * Shows help for specific command word {@param commandWord}
     */
    public HelpCommand(String commandWord) {
        this.commandWord = commandWord;
    }

    @Override
    public CommandResult execute() throws NoEventsCenterException {
        EventsCenter eventsCenter = getEventsCenter();

        if (commandWord.isEmpty()) {
            eventsCenter.post(new ShowHelpRequestEvent(""));
        } else {
            Optional<String> anchor = Config.getUserGuideAnchorForCommandWord(commandWord);

            // If the command word is recognized
            if (anchor.isPresent()) {
                eventsCenter.post(new ShowHelpRequestEvent(anchor.get()));
            } else {
                return new CommandResult(String.format(Messages.UNKNOWN_COMMAND_FOR_HELP, commandWord), true);
            }
        }

        return new CommandResult(Messages.HELP_WINDOW_SHOWN);
    }
}
```
###### \java\seedu\commando\logic\commands\RecallCommand.java
``` java
/**
 * Changes to history mode, and updates the filter for to-do list
 * to show only to-do items containing all of the keywords and tags (case insensitive)
 */
public class RecallCommand extends Command {
    public static final String COMMAND_WORD = "recall";

    public Set<String> keywords = Collections.emptySet();
    public Set<Tag> tags = Collections.emptySet();

    /**
     * Asserts that {@code uiLogic} is non-null
     */
    @Override
    public CommandResult execute() throws NoModelException {
        Model model = getModel();

        // if no keywords or tags are provided, clear filter
        if (keywords.isEmpty() && tags.isEmpty()) {
            model.clearUiToDoListFilter(true);
            return new CommandResult(Messages.RECALL_COMMAND_CLEAR);
        }

        model.setUiToDoListFilter(keywords, tags, true);
        return new CommandResult(String.format(Messages.RECALL_COMMAND, model.getUiEvents().size(), model.getUiTasks().size()));
    }
}
```
###### \java\seedu\commando\logic\Logic.java
``` java
/**
 * API of the Logic component
 */
public interface Logic {
    /**
     * Executes the command and returns the result
     * @param commandText The command as entered by the user
     * @return the result of the command execution
     */
    CommandResult execute(String commandText);

    /**
     * @see Model#getUiEvents()
     * */
    UnmodifiableObservableList<UiToDo> getUiEvents();

    /**
     * @see Model#getUiTasks()
     * */
    UnmodifiableObservableList<UiToDo> getUiTasks();

    /**
     * @see Model#getToDoList()
     * */
    ReadOnlyToDoList getToDoList();
}
```
###### \java\seedu\commando\logic\LogicManager.java
``` java
/**
 * Underlying logic in application
 */
public class LogicManager extends ComponentManager implements Logic {
    private final Logger logger = LogsCenter.getLogger(LogicManager.class);

    private final Model model;
    private final Storage storage;
    private final UserPrefs userPrefs;
    private final CommandFactory commandFactory;
    {
        commandFactory = new CommandFactory();
    }

    public LogicManager(Model model, Storage storage, UserPrefs userPrefs) {
        this.model = model;
        this.storage = storage;
        this.userPrefs = userPrefs;
    }


    @Override
    public CommandResult execute(String commandText) {
        logger.info("User command: " + commandText + "");

        try {
            Command command = commandFactory.build(commandText);

            command.setEventsCenter(eventsCenter);
            command.setModel(model);

            return command.execute();
        } catch (Command.NoEventsCenterException | Command.NoModelException exception) {
            assert false; // There should always be EventsCenter or Model
            return new CommandResult(exception.getMessage(), true);
        } catch (CommandFactory.InvalidCommandFormatException e) {

            // If invalid command format, check if Messages has sample commands for that command
            // Append to exception message if there is
            Optional<String> commandFormatMessage = Messages.getInvalidCommandFormatMessage(e.command);
            if (commandFormatMessage.isPresent()) {
                return new CommandResult(e.getMessage() + "\n" + commandFormatMessage.get(), true);
            } else {
                return new CommandResult(e.getMessage(), true);
            }

        } catch (CommandFactory.UnknownCommandWordException e) {
            return new CommandResult(String.format(Messages.UNKNOWN_COMMAND, e.commandWord), true);
        } catch (CommandFactory.MissingCommandWordException e) {
            return new CommandResult(Messages.MISSING_COMMAND_WORD, true);
        }
    }

    @Override
    public UnmodifiableObservableList<UiToDo> getUiEvents() {
        return model.getUiEvents();
    }

    @Override
    public UnmodifiableObservableList<UiToDo> getUiTasks() {
        return model.getUiTasks();
    }

    @Override
    public ReadOnlyToDoList getToDoList() {
        return model.getToDoList();
    }

    /**
     * Changes to-do list file path in user prefs and storage and saves the
     * to-do data to that new file path with storage
     */
    @Subscribe
    public void handleToDoListFilePathRequestEvent(ToDoListFilePathChangeRequestEvent event){
        logger.info(LogsCenter.getEventHandlingLogMessage(event));

        storage.setToDoListFilePath(event.path);

        try {
            storage.saveToDoList(model.getToDoList());
        } catch (IOException exception) {
            logger.warning("Failed to save to-do list data file: " + StringUtil.getDetails(exception));
        }

        userPrefs.setToDoListFilePath(event.path);
    }
}
```
###### \java\seedu\commando\logic\parser\DateTimeParser.java
``` java
/**
 * Parses datetimes with help of {@link com.joestelmach.natty.Parser}
 */
public class DateTimeParser {
    public static final LocalTime DefaultLocalTime = LocalTime.NOON;
    public static final LocalTime MorningLocalTime = LocalTime.of(8, 0);
    public static final LocalTime AfternoonLocalTime = LocalTime.of(12, 0);
    public static final LocalTime EveningLocalTime = LocalTime.of(19, 0);
    public static final LocalTime NightLocalTime = LocalTime.of(21, 0);

    private static final String MonthWordRegexString = "January|Feburary|March|April|June|July|August|September|October|November|December|" +
        "Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Sept|Oct|Nov|Dec";
    private static final String DayWordRegexString = "Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday|Mon|Tue|Tues|Wed|Thu|Thur|Thurs|Fri|Sat|Sun";
    private static final String YearRegexString = "(?<year>\\d{4}|\\d{2})";
    private static final String TwoDigitYearRegexString = "\\d{2}$";

    private static final String DateWithSlashesRegexString = "(?<month>\\d{1,2})\\/(?<day>\\d{1,2})(\\/" + YearRegexString + ")?";
    private static final String DateWithMonthWordRegexString = "(\\d{1,2})((th|rd|st|nd)?)\\s+" +
        "(" + MonthWordRegexString + ")(\\s+" + YearRegexString + ")?";
    private static final String DateWithMonthWordReversedRegexString = "(" + MonthWordRegexString + ")\\s+" +
        "(\\d{1,2})(th|rd|st|nd)?(\\s+" + YearRegexString + ")?";
    private static final String DateWithDayWordRegexString = "((coming|next)\\s+)?(" + DayWordRegexString + ")";
    private static final String DateWithLaterAgoRegexString = "((\\d+\\d)|([2-9]))\\s+(days|weeks|months|years)\\s+(later|ago)";
    private static final String DateWithNextRegexString = "next (week|month|year)";
    private static final String TimeNightRegexString = "(this\\s+)?(night|tonight)";
    private static final String TimeHourRegexString = "(?<hours>\\d{1,2})(?<minutes>\\d{2})h";

    private static final String[] supportedDateRegexStrings = new String[] {
        DateWithSlashesRegexString,
        DateWithMonthWordRegexString,
        DateWithMonthWordReversedRegexString,
        DateWithDayWordRegexString,
        DateWithLaterAgoRegexString,
        DateWithNextRegexString,
        "today", "tomorrow|tmr", "yesterday"
    };

    private static final String[] supportedTimeRegexStrings = new String[] {
        "(\\d{2})(\\.|:)(\\d{2})",
        TimeHourRegexString,
        "(\\d{1,2})(\\.|:)?(\\d{2})?(am|pm)",
        "(this\\s+)?(morning|afternoon|noon|evening|midnight)",
        TimeNightRegexString
    };

    private Parser parser = new Parser();
    private LocalDate lastLocalDate; // Date of last parsed datetime

    /**
     * Resets any contextual info used based on history of parsing
     */
    public void resetContext() {
        lastLocalDate = null;
    }

    /**
     * Gets the first datetime encountered in text
     * Works based on {@link com.joestelmach.natty.Parser}, but:
     * - Converted to `LocalDateTime`
     * - If time is deemed as "inferred" (in natty), time = {@link #DefaultLocalTime}
     * - If date is "inferred" and there were previous parses, date = {@link #lastLocalDate}
     * - Seconds field is always set to 0 (ignored)
     */
    public Optional<LocalDateTime> parseDateTime(String input) {
        Optional<String> preprocessedInput = preprocessInput(input);

        // If preprocessing fails, return empty
        if (!preprocessedInput.isPresent()) {
            return Optional.empty();
        }

        List<DateGroup> dateGroups = parser.parse(preprocessedInput.get());

        // Return first date parsed
        if (!dateGroups.isEmpty()) {
            DateGroup dateGroup = dateGroups.get(0);
            List<Date> dates = dateGroup.getDates();
            if (!dates.isEmpty()) {
                return Optional.of(toLocalDateTime(dateGroup, dates.get(0)));
            }
        }

        return Optional.empty();
    }

    private LocalDateTime toLocalDateTime(DateGroup dateGroup, Date date) {
        Instant instant = Instant.ofEpochMilli(date.getTime());
        ZoneId zoneId = ZoneOffset.systemDefault();

        LocalDateTime localDateTime = LocalDateTime.ofInstant(instant, zoneId);

        // Check if date is inferred
        if (dateGroup.isDateInferred() && lastLocalDate != null) {
            localDateTime = LocalDateTime.of(
                lastLocalDate,
                localDateTime.toLocalTime()
            );
        }

        // Check if time is inferred
        if (dateGroup.isTimeInferred()) {
            localDateTime = LocalDateTime.of(
                localDateTime.toLocalDate(),
                DefaultLocalTime
            );
        }

        // Reset seconds
        localDateTime = localDateTime.withSecond(0);

        // Remember last date parsed
        lastLocalDate = localDateTime.toLocalDate();

        return localDateTime;
    }

    /**
     * Determines with regex whether this is a supported datetime
     * Preprocesses it to before being parsed in natty
      * Returns Optional.empty() if not supported
     */
    private Optional<String> preprocessInput(String input) {
        input = input.trim();

        if (input.isEmpty()) {
            return Optional.empty();
        }

        // Try to match a date
        String dateString = "";
        for (String regexString : supportedDateRegexStrings) {
            // Try to match regex + (space or end of string)
            Matcher matcher = Pattern.compile(regexString + "(\\s|$)", Pattern.CASE_INSENSITIVE).matcher(input);

            // If matched from the start
            if (matcher.find() && matcher.start() == 0) {

                // Special case: for DateWithSlashesRegexString format,
                // Swap month and day
                if (regexString.equals(DateWithSlashesRegexString)) {
                    dateString = matcher.group("day") + "/" + matcher.group("month") + "/" + matcher.group("year");
                } else {
                    dateString = matcher.group().trim();
                }

                // Tweak for year: if it is a 2 digit year, change it to 4
                // Check if year string exists in datetime
                try {
                    if (matcher.group("year") != null && matcher.group("year").length() == 2) {
                        // Get string version of today's year
                        String thisFullYear = String.valueOf(LocalDateTime.now().getYear());
                        // If today's year is more than 2 digits, append the front (size - 2) digits
                        if (thisFullYear.length() > 2) {
                            String fullYear = thisFullYear.substring(0, thisFullYear.length() - 2)
                                + matcher.group("year");
                            dateString = dateString.replaceFirst(TwoDigitYearRegexString, fullYear);
                        }
                    }
                } catch (IllegalArgumentException exception) { } // no group with "year"

                // Extract out date string from text
                input = input.substring(matcher.end()).trim();

                break; // exit loop
            }
        }

        // Try to match a time
        String timeString = "";
        for (String regexString : supportedTimeRegexStrings) {
            // Try to match regex + (space or end of string)
            Matcher matcher = Pattern.compile(regexString + "(\\s|$)").matcher(input);

            // If matched from the start
            if (matcher.find() && matcher.start() == 0) {

                // Special case: for TimeHourRegexString format,
                // Change to colon format (natty parses it wrongly when there is no year in the date)
                if (regexString.equals(TimeHourRegexString)) {
                    timeString = matcher.group("hours") + ":" + matcher.group("minutes");
                }
                // Special case: for TimeNightRegexString format,
                // Set time to 9pm
                else if (regexString.equals(TimeNightRegexString)) {
                    timeString = NightLocalTime.toString();
                } else {
                    timeString = matcher.group().trim();
                }

                input = input.substring(matcher.end()).trim();

                break; // exit loop
            }
        }

        // If there is any characters left in text, invalid datetime
        if (!input.isEmpty()) {
            return Optional.empty();
        } else {

            // Special case: if DateWithLaterRegexString is used,
            // swap date and time (for parsing in natty)
            if (dateString.matches(DateWithLaterAgoRegexString)) {
                return Optional.of(timeString + " " + dateString);
            } else {
                return Optional.of(dateString + " " + timeString);
            }
        }
    }
}
```
###### \java\seedu\commando\logic\parser\SequentialParser.java
``` java
/**
 * Parses a given input string, part by part
 * Methods modify the input string by extracting appropriate parts of it
 * Input is always kept trimmed
 */
public class SequentialParser {

    private static final String KEYWORD_DATERANGE_START = "from";
    private static final String KEYWORD_DATERANGE_END = "to";
    private static final String KEYWORD_DUEDATE = "by";
    private static final String KEYWORD_RECURRENCE = "daily|weekly|monthly|yearly";
    private static final String TAG_PREFIX = "#";
    private static final String QUOTE_CHARACTER = "`";

    private static final Pattern FIRST_WORD_PATTERN = Pattern.compile("^(?<word>\\S+)(?<left>.*?)$");
    private static final Pattern FIRST_QUOTED_TEXT_PATTERN = Pattern.compile("^" + QUOTE_CHARACTER + "(?<text>.*)" + QUOTE_CHARACTER + "(?<left>.*?)$");
    private static final Pattern FIRST_INTEGER_PATTERN = Pattern.compile("^(?<integer>-?\\d+)(?<left>.*?)$");
    private static final Pattern DATERANGE_PATTERN = Pattern.compile(
        "(?<left>.*)" + KEYWORD_DATERANGE_START + "\\s+" + "(?<start>(.+\\s+)?)"
            + KEYWORD_DATERANGE_END + "(?<end>(\\s+.+?)?)"
            + "(?<recurrence>(\\s+" + KEYWORD_RECURRENCE + ")?)$",
        Pattern.CASE_INSENSITIVE
    );
    private static final Pattern DUEDATE_PATTERN = Pattern.compile(
        "(?<left>.*)" + KEYWORD_DUEDATE + "\\s+" + "(?<date>.+?)$",
        Pattern.CASE_INSENSITIVE
    );
    private static final Pattern TAGS_PATTERN = Pattern.compile(
        "(?<left>.*?)(?<tags>((\\s+|^)" + TAG_PREFIX + "\\S*)+)$",
        Pattern.CASE_INSENSITIVE
    );
    private static final Pattern INDEXRANGE_PATTERN = Pattern.compile(
        "^(?<firstInt>-?\\d+)" + "\\s*" + "((to)|-)" + "\\s*" + "(?<secondInt>-?\\d+)(?<left>.*?)$",
        Pattern.CASE_INSENSITIVE
    );

    private String input;
    private DateTimeParser dateTimeParser;
    {
        dateTimeParser = new DateTimeParser();
    }

    /**
     * Set the current input the parser is working on
     */
    public void setInput(String input) {
        this.input = input;
        dateTimeParser.resetContext(); // reset any contextual info from last command
    }

    /**
     * Gets current input the parser is working on
     */
    public String getInput() {
        return input.trim();
    }
    
    /**
     * Checks whether current input is empty
     */
    public boolean isInputEmpty(){
        return input.trim().isEmpty();
    }

    /**
     * Extract a trailing due date from the input.
     * Date range is defined by: "by (valid_datetime)", and must be at the end of the string to be considered.
     * If a trailing date range pattern is found but datetime is not valid, also returns empty
     * @throws IllegalValueException if parsed DueDate is not valid
     */
    public Optional<DueDate> extractTrailingDueDate() throws IllegalValueException {
        final Matcher matcher = DUEDATE_PATTERN.matcher(input);

        if (matcher.find()) {
            String dateString = matcher.group("date");

            // Check if datetimes can be parsed
            Optional<LocalDateTime> date = dateTimeParser.parseDateTime(dateString);

            if (date.isPresent()) {
                // Legit date
                input = matcher.group("left").trim();
                return Optional.of(new DueDate(date.get()));
            }
        }

        return Optional.empty(); // Didn't find any matches
    }

    /**
     * Extract a trailing date range from the input.
     * Date range is defined by: "from (valid_datetime) to (valid_datetime)" + optional "(valid recurrence),
     * and must be at the end of the string to be considered.
     * If a trailing date range pattern is found but both datetimes are not valid, also returns empty
     * @throws IllegalValueException if a trailing date range pattern is found but either one of the datetime is valid, other invalid,
     * or parsed DateRange is not invalid
     */
    public Optional<DateRange> extractTrailingDateRange() throws IllegalValueException {
        final Matcher matcher = DATERANGE_PATTERN.matcher(input);

        if (matcher.find()) {
            String startString = matcher.group("start");
            String endString = matcher.group("end");
            String recurrenceString = matcher.group("recurrence");

            // Check if datetimes can be parsed
            Optional<LocalDateTime> startDateTime = dateTimeParser.parseDateTime(startString);
            Optional<LocalDateTime> endDateTime = dateTimeParser.parseDateTime(endString);

            if (startDateTime.isPresent() && !endDateTime.isPresent()) {
                if (endString.isEmpty()) {
                    throw new IllegalValueException(Messages.MISSING_TODO_DATERANGE_END + "\n" + Messages.DATE_FORMAT);
                } else {
                    throw new IllegalValueException(Messages.INVALID_TODO_DATERANGE_END + "\n" + Messages.DATE_FORMAT);
                }
            } else if (endDateTime.isPresent() && !startDateTime.isPresent()) {
               if (startString.isEmpty()) {
                   throw new IllegalValueException(Messages.MISSING_TODO_DATERANGE_START + "\n" + Messages.DATE_FORMAT);
               } else {
                   throw new IllegalValueException(Messages.INVALID_TODO_DATERANGE_START + "\n" + Messages.DATE_FORMAT);
               }
            }

            if (startDateTime.isPresent() && endDateTime.isPresent()) {
                // Legit date range
                // Extract date range from input
                input = matcher.group("left").trim();

                // Parse recurrence
                Recurrence recurrence = parseRecurrence(recurrenceString);

                assert recurrence != null : "Regex should ensure that recurrence string is valid";

                return Optional.of(new DateRange(startDateTime.get(), endDateTime.get(), recurrence));
            }
        }

        return Optional.empty(); // Didn't find any matches
    }

    /**
     * Extracts all text in input
     */
    public Optional<String> extractText() {
        String text = input.trim();
        input = "";

        return text.isEmpty() ? Optional.empty() : Optional.of(text);
    }


    /**
     * From start, extracts a quoted title in input, if found
     * e.g. "`quoted` text" returns "quoted" and retains input "text"
     * @return quoted text with quotes removed and trimmed if found,
     * empty if no quotes found
     * @throws IllegalValueException if quoted title found is empty
     */
    public Optional<String> extractQuotedTitle() throws IllegalValueException {
        final Matcher matcher = FIRST_QUOTED_TEXT_PATTERN.matcher(input);

        if (matcher.find()) {
            String text = matcher.group("text").trim();

            if (text.isEmpty()) {
                throw new IllegalValueException(Messages.MISSING_TODO_TITLE);
            }

            input = matcher.group("left").trim();
            return Optional.of(text);
        }

        return Optional.empty();
    }

    /**
     * From start, extracts all trailing tags from the current input.
     * Extraction ends when the next word is not a tag.
     * Tags which are empty strings are removed.
     * @return a set of tags, with the tag prefix removed.
     */
    public Set<Tag> extractTrailingTags() {
        final Matcher matcher = TAGS_PATTERN.matcher(input);

        if (matcher.find()) {
            input = matcher.group("left").trim();

            // Split to words to get tags
            return Arrays.stream(matcher.group("tags").trim()
                .split("\\s+"))
                .map(word -> {
                    word = word.trim(); // trim any leading spaces
                    assert word.indexOf(TAG_PREFIX) == 0; // pattern should have ensured this
                    return new Tag(word.substring(TAG_PREFIX.length()).trim());
                }).filter(x -> !x.value.isEmpty())
                .collect(Collectors.toSet());
        }

        return Collections.emptySet();
    }

    /**
     * From start, extracts a single word in input, if found
     * @return optional of word extracted from input, empty if not found
     */
    public Optional<String> extractWord() {
        final Matcher matcher = FIRST_WORD_PATTERN.matcher(input.trim());
        if (matcher.find()) {
            // Remove extracted first word
            input = matcher.group("left").trim();
            return Optional.of(matcher.group("word"));
        }

        return Optional.empty();
    }

    /**
     * Extracts all words in input
     * If input is empty, returns empty list
     */
    public List<String> extractWords() {
        return Arrays.stream(extractText().orElse("").split("\\s+"))
            .filter(x -> !x.trim().isEmpty())
            .collect(Collectors.toList());
    }

    /**
     * From start, extracts an integer in input, if found
     * @return optional of found integer extracted from input, empty if not found
     */
    public Optional<Integer> extractInteger() {
        final Matcher matcher = FIRST_INTEGER_PATTERN.matcher(input.trim());

        if (matcher.find()) {
            // Remove extracted first integer
            String integerString = matcher.group("integer");
            input = matcher.group("left").trim();

            try {
                return Optional.of(Integer.parseInt(integerString));
            } catch (NumberFormatException exception) {
                assert false : "Shouldn't be able to fail parsing of integer based on pattern";
            }

        }

        return Optional.empty();
    }
```
###### \java\seedu\commando\logic\parser\SequentialParser.java
``` java
    // Returns null if invalid recurrence
    // Returns Recurrence.None if empty string
    private Recurrence parseRecurrence(String recurrence) {
        recurrence = recurrence.trim().toLowerCase();

        switch (recurrence) {
            case "daily": return Recurrence.Daily;
            case "weekly": return Recurrence.Weekly;
            case "monthly": return Recurrence.Monthly;
            case "yearly": return Recurrence.Yearly;
            case "": return Recurrence.None;
            default: return null;
        }
    }
}
```
###### \java\seedu\commando\model\Model.java
``` java
/**
 * The API of the Model component.
 */
public interface Model {
    /** Returns the to-do list */
    ReadOnlyToDoList getToDoList();

    /** Changes the to-do list */
    void changeToDoList(ToDoListChange change) throws IllegalValueException;

    /** Undos the last change to the to-do list, returns true if successful */
    boolean undoToDoList();

    /** Redos the last undo to the to-do list, returns true if successful */
    boolean redoToDoList();

    /**
     * Returns observable list of UI events happening from the current day onwards
     * Events are in chronological order, with those finished at the bottom
     * */
    UnmodifiableObservableList<UiToDo> getUiEvents();

    /**
     *  Return observable list of UI tasks
     *  Tasks are in chronological order, with those finished at the bottom,
     *  with those with DueDate on top
     * */
    UnmodifiableObservableList<UiToDo> getUiTasks();

    /**
     *  Gets the UI to-do with {@link UiToDo#getIndex()} == {@param toDoIndex}
     * */
    Optional<UiToDo> getUiToDoAtIndex(int index);

    /**
     * Clears the filter on the UI to-do list
     */
    void clearUiToDoListFilter(boolean ifHistoryMode);

    /**
     * Sets a filter on the UI to-do list
     * @see seedu.commando.model.ui.UiModel#setToDoListFilter(Set, Set, boolean)
     */
    void setUiToDoListFilter(Set<String> keywords, Set<Tag> tags, boolean ifHistoryMode);
}
```
###### \java\seedu\commando\model\ModelManager.java
``` java
/**
 * Represents the in-memory model of the application's data
 * All changes to model should be synchronized
 */
public class ModelManager extends ComponentManager implements Model {
    private static final Logger logger = LogsCenter.getLogger(ModelManager.class);

    private final ToDoListManager toDoListManager;
    private final UiModel uiModel;
    private final UserPrefs userPrefs;

    /**
     * Initializes a ModelManager with the given to-do list
     * Parameters should be non-null
     * @param toDoList is copied during initialization
     */
    public ModelManager(ReadOnlyToDoList toDoList, UserPrefs userPrefs) {
        super();
        assert toDoList != null;
        assert userPrefs != null;

        logger.fine("Initializing with to-do list: " + toDoList + " and user prefs: " + userPrefs);

        this.userPrefs = userPrefs;

        toDoListManager = new ToDoListManager(toDoList);
        uiModel = new UiModel(toDoListManager);
    }

    public ModelManager() {
        this(new ToDoList(), new UserPrefs());
    }

    @Override
    public ReadOnlyToDoList getToDoList() {
        return toDoListManager.getToDoList();
    }

    @Override
    public synchronized void changeToDoList(ToDoListChange change) throws IllegalValueException {
        toDoListManager.changeToDoList(change);

        // if to-do list has changed, reset any find or history filter
        clearUiToDoListFilter(false);

        indicateToDoListChanged();
    }

    @Override
    public boolean undoToDoList() {
        boolean hasChanged = toDoListManager.undoToDoList();

        if (hasChanged) {
            indicateToDoListChanged();
        }

        return hasChanged;
    }

    @Override
    public boolean redoToDoList() {
        boolean hasChanged = toDoListManager.redoToDoList();

        if (hasChanged) {
            indicateToDoListChanged();
        }

        return hasChanged;
    }

    @Override
    public UnmodifiableObservableList<UiToDo> getUiEvents() {
        return uiModel.getEvents();
    }

    @Override
    public UnmodifiableObservableList<UiToDo> getUiTasks() {
        return uiModel.getTasks();
    }

    @Override
    public Optional<UiToDo> getUiToDoAtIndex(int index) {
        return uiModel.getToDoAtIndex(index);
    }

    @Override
    public void clearUiToDoListFilter(boolean ifHistoryMode) {
        uiModel.clearToDoListFilter(ifHistoryMode);
    }

    @Override
    public void setUiToDoListFilter(Set<String> keywords, Set<Tag> tags, boolean ifHistoryMode) {
        uiModel.setToDoListFilter(keywords, tags, ifHistoryMode);
    }

    /** Raises an event to indicate the model has changed */
    private void indicateToDoListChanged() {
        raise(new ToDoListChangedEvent(toDoListManager.getToDoList()));
    }

}
```
###### \java\seedu\commando\model\todo\DateRange.java
``` java
/**
 * Represents the Date Range of a to-do
 */
public class DateRange {

    public final LocalDateTime startDate, endDate;
    public final Recurrence recurrence;

    /**
     * @see #DateRange(LocalDateTime, LocalDateTime, Recurrence), but with Recurrence.None
     */
    public DateRange(LocalDateTime startDate, LocalDateTime endDate) throws IllegalValueException {
        this(startDate, endDate, Recurrence.None);
    }

    /**
     * Constructor for a date range
     * Asserts parameters are non-null
     * Conditions for validity:
     * - {@param endDate} must not be before {@param startDate}
     * - gap between {@param startDate} and {@param endDate} must not be more than the recurrence interval
     * @throws IllegalValueException if given set of values is invalid
     */
    public DateRange(LocalDateTime startDate, LocalDateTime endDate, Recurrence recurrence) 
            throws IllegalValueException {
        assert !CollectionUtil.isAnyNull(startDate,endDate, recurrence);

        checkIfValid(startDate, endDate, recurrence);

        this.startDate = startDate;
        this.endDate = endDate;
        this.recurrence = recurrence;
    }

    /**
     * Copy constructor
     */
    public DateRange(DateRange dateRange){
        this.startDate = dateRange.startDate;
        this.endDate = dateRange.endDate;
        this.recurrence = dateRange.recurrence;
    }

    private static void checkIfValid(LocalDateTime startDate, LocalDateTime endDate, Recurrence recurrence)
        throws IllegalValueException {

        if (endDate.isBefore(startDate)) {
            throw new IllegalValueException(Messages.TODO_DATERANGE_END_MUST_AFTER_START + "\n" + Messages.DATE_FORMAT);
        }

        boolean isRecurrenceValid = true;
        switch (recurrence) {
            case None: break;
            case Daily: isRecurrenceValid = !startDate.plusDays(1).isBefore(endDate); break;
            case Weekly: isRecurrenceValid = !startDate.plusWeeks(1).isBefore(endDate); break;
            case Monthly: isRecurrenceValid = !startDate.plusMonths(1).isBefore(endDate); break;
            case Yearly: isRecurrenceValid = !startDate.plusYears(1).isBefore(endDate); break;
            default:
                assert false: "Should cover all recurrences";
        }

        if (!isRecurrenceValid) {
            throw new IllegalValueException(Messages.TODO_DATERANGE_RECURRENCE_INVALID + "\n" + Messages.DATE_FORMAT);
        }
    }

    @Override
    public String toString() {
        return startDate + " - " + endDate
            + ((recurrence == Recurrence.None) ? "" : " " + recurrence.toString().toLowerCase());
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof DateRange // instanceof handles nulls
                && (startDate.equals(((DateRange) other).startDate) 
                && endDate.equals(((DateRange) other).endDate)
                && recurrence.equals(((DateRange) other).recurrence))); // state check
    }

    @Override
    public int hashCode() {
        return Objects.hash(startDate, endDate, recurrence);
    }

}
```
###### \java\seedu\commando\model\todo\ReadOnlyToDo.java
``` java
/**
 * A read-only immutable interface for a to-do
 */
public interface ReadOnlyToDo {

    Title getTitle();

    Optional<DateRange> getDateRange();

    Optional<DueDate> getDueDate();

    Set<Tag> getTags();

    LocalDateTime getDateCreated();

    default boolean hasTimeConstraint() {
        return getDateRange().isPresent()
            || getDueDate().isPresent();
    }

    /**
     * If a date range is set and current datetime is after the end of the range
     * returns end of date range regardless of whether date finished was set
     * Else, returns date finished if it is set, empty otherwise
     */
    Optional<LocalDateTime> getDateFinished();

    /**
     * If a date range is set and current datetime is after the end of the range
     * returns true regardless of whether date finished is set.
     * Else, returns if date finished is set and date finished is after current datetime
     */
    default boolean isFinished() {
        if (getDateFinished().isPresent()) {
            return LocalDateTime.now().isAfter(getDateFinished().get());
        } else {
            return getDateRange().isPresent() &&
                LocalDateTime.now().isAfter(getDateRange().get().endDate);
        }
    }

    /**
     * An observable value that changes when any of its fields are updated
     */
    ObservableValue getObservableValue();

    /**
     * Returns true if both have the same state
     * All fields must be equal
     */
    default boolean isSameStateAs(ReadOnlyToDo other) {
        return other == this // short circuit if same object
            || (other != null // this is first to avoid NPE below
            && other.getTitle().equals(getTitle())
            && other.getDateRange().equals(getDateRange())
            && other.getDueDate().equals(getDueDate())
            && other.getTags().equals(getTags())
            && other.getDateFinished().equals(getDateFinished())
            && other.getDateCreated().equals(getDateCreated())); // state checks here onwards
    }

    /**
     * Returns true if both are considered "similar", which means these fields must be equal:
     * - title
     * - due date
     * - date range
     * - tags
     */
    default boolean isSimilar(ReadOnlyToDo other) {
        return other == this // short circuit if same object
            || (other != null // this is first to avoid NPE below
            && other.getTitle().equals(getTitle())
            && other.getDateRange().equals(getDateRange())
            && other.getDueDate().equals(getDueDate())
            && other.getTags().equals(getTags()));
    }

    /**
     * Updates and returns its value, based on the current value of its fields
     */
    default String getText() {
        return String.join(", ",
            "Title: " + getTitle(),
            "Date Range: " + (getDateRange().isPresent() ? getDateRange().get() : "none"),
            "Due Date: " + (getDueDate().isPresent() ? getDueDate().get() : "none"),
            "Tags: " + getTags(),
            "Date Created: " + getDateCreated(),
            "Date Finished: " + (getDateFinished().isPresent() ? getDateFinished().get() : "none"));
    }
}
```
###### \java\seedu\commando\model\todo\ReadOnlyToDoList.java
``` java
/**
 * Unmodifiable view of a to-do list
 */
public interface ReadOnlyToDoList {
    UnmodifiableObservableList<ReadOnlyToDo> getToDos();

    /**
     *  Checks if the list contains a to-do that is considered as similar
     *  as the given to-do
     */
    boolean contains(ReadOnlyToDo toDo);

    /**
     *  Checks if the list is considered similar as the given to-do list
     */
    boolean isSimilar(ReadOnlyToDoList toDoList);

    /**
     * Updates and returns its value, based on the current value of its fields
     */
    default String getText() {
        return "[" + getToDos().stream().map(ReadOnlyToDo::toString).collect(Collectors.joining(", ")) + "]";
    }
}
```
###### \java\seedu\commando\model\todo\Recurrence.java
``` java
public enum Recurrence {
    Daily, Weekly, Monthly, Yearly, None
}
```
###### \java\seedu\commando\model\todo\ToDoList.java
``` java
/**
 * Represents a list of to-dos
 */
public class ToDoList implements ReadOnlyToDoList {

    private final ObservableList<ReadOnlyToDo> list;
    private final UnmodifiableObservableList<ReadOnlyToDo> protectedList;
    {
        list = FXCollections.observableArrayList(toDo -> new Observable[] {
            toDo.getObservableValue() // track value of to-do as well
        });
        protectedList = new UnmodifiableObservableList<>(list);
    }

    public ToDoList() {
    }

    /**
     * Copy constructor
     */
    public ToDoList(ReadOnlyToDoList listToBeCopied) {
        reset(listToBeCopied.getToDos());
    }

    //================================================================================
    // List operations
    //================================================================================

    /**
     * @see #add(ReadOnlyToDoList)
     */
    public ToDoList add(ReadOnlyToDo toDo) throws IllegalValueException {
        if (contains(toDo)) {
            throw new IllegalValueException(Messages.TODO_ALREADY_EXISTS);
        }

        list.add(toDo);

        return this;
    }
    /**
     * @see #remove(ReadOnlyToDoList)
     */
    public ToDoList remove(ReadOnlyToDo toDo) throws IllegalValueException {
        if (!contains(toDo)) {
            throw new IllegalValueException(Messages.TODO_NOT_FOUND);
        }

        list.remove(toDo);

        return this;
    }

    /**
     * Add all to-dos in {@param toDoList}
     * @throws IllegalValueException if any to-do in {@param toDoList} was not found for deletion
     */
    public ToDoList add(ReadOnlyToDoList toDoList) throws IllegalValueException {
        assert toDoList != null;

        for (ReadOnlyToDo toDo : toDoList.getToDos()) {
            if (contains(toDo)) {
                throw new IllegalValueException(Messages.TODO_ALREADY_EXISTS);
            }
        }

        list.addAll(toDoList.getToDos());

        return this;
    }

    /**
     * Removes all to-dos in {@param toDoList}
     * @throws IllegalValueException if any to-do in {@param toDoList} was not found for deletion
     */
    public ToDoList remove(ReadOnlyToDoList toDoList) throws IllegalValueException {
        assert toDoList != null;

        for (ReadOnlyToDo toDoToRemove : toDoList.getToDos()) {
            if (!contains(toDoToRemove)) {
                throw new IllegalValueException(Messages.TODO_NOT_FOUND);
            }
        }

        list.removeAll(toDoList.getToDos());

        return this;
    }

    /**
     * Clears the list and sets it to a deep copy of {@param newToDos}
     */
    public void reset(List<ReadOnlyToDo> newToDos) {
        List<ToDo> toDos = new LinkedList<>();
        newToDos.forEach(toDo -> toDos.add(new ToDo(toDo)));
        list.setAll(toDos);
    }

    //================================================================================
    // Utility methods
    //================================================================================

    @Override
    public String toString() {
        return getText();
    }

    public UnmodifiableObservableList<ReadOnlyToDo> getToDos() {
        return protectedList;
    }

    /**
     *  Checks if the list contains a to-do that is similar to the given
     *  @see ReadOnlyToDo#isSimilar(ReadOnlyToDo)
     */
    @Override
    public boolean contains(ReadOnlyToDo toDo) {
        return list.filtered(x -> x.isSimilar(toDo)).size() > 0;
    }

    /**
     *  Checks if to do list is is similar to the given {@param toDoList}
     *  @see ReadOnlyToDo#isSimilar(ReadOnlyToDo)
     */
    @Override
    public boolean isSimilar(ReadOnlyToDoList toDoList) {
        return list.size() == toDoList.getToDos().size()
            && list.filtered(toDoList::contains).size() == list.size();
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof ToDoList // instanceof handles nulls
                && list.equals(((ToDoList) other).list));
    }

    @Override
    public int hashCode() {
        return Objects.hash(list);
    }

}
```
###### \java\seedu\commando\model\ToDoListChange.java
``` java
/**
 * An immutable representation of a change in a to-do list
 * Input to-do lists are copied
 */
public class ToDoListChange {

    private final ToDoList addedToDos;
    private final ToDoList deletedToDos;

    public ToDoListChange(ReadOnlyToDoList addedToDos, ReadOnlyToDoList deletedToDos) {
        this.addedToDos = new ToDoList(addedToDos);
        this.deletedToDos = new ToDoList(deletedToDos);
    }

    public ReadOnlyToDoList getAddedToDos() {
        return addedToDos;
    }

    public ReadOnlyToDoList getDeletedToDos() {
        return deletedToDos;
    }

    /**
     * Get the reverse of this change
        */
    public ToDoListChange getReverseChange() {
        return new ToDoListChange(deletedToDos, addedToDos);
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
            || (other instanceof ToDoListChange // instanceof handles nulls
            && addedToDos.equals(((ToDoListChange) other).addedToDos)
            && deletedToDos.equals(((ToDoListChange) other).deletedToDos));
    }

    @Override
    public int hashCode() {
        return Objects.hash(addedToDos, deletedToDos);
    }

    @Override
    public String toString(){
        return "Added " + addedToDos + " & deleted " + deletedToDos;
    }
}
```
###### \java\seedu\commando\model\ToDoListManager.java
``` java
/**
 * Manages a to-do list internally
 * Supports adding, removing, editing, undoing and redoing
 * based on {@link ToDoListChange}
 */
public class ToDoListManager {
    private final ToDoList toDoList;
    private final ArrayList<ToDoListChange> toDoListChanges; // changes that can be undone
    private final ArrayList<ToDoListChange> toDoListUndoChanges; // changes that can be redone
    private ToDoListChange lastToDoListChange;
    {
        toDoListChanges = new ArrayList<>();
        toDoListUndoChanges = new ArrayList<>();
    }

    /**
     * Initializes with the given to-do list
     * To-do list is copied
     */
    public ToDoListManager(ReadOnlyToDoList toDoList) {
        assert toDoList != null;

        this.toDoList = new ToDoList(toDoList);
    }

    public ToDoList getToDoList() {
        return toDoList;
    }

    public void changeToDoList(ToDoListChange change) throws IllegalValueException {
        applyToDoListChange(change);
        toDoListChanges.add(change);

        // Reset undo list
        toDoListUndoChanges.clear();
    }

    private void applyToDoListChange(ToDoListChange change) throws IllegalValueException {
        lastToDoListChange = change;

        toDoList.remove(change.getDeletedToDos());

        try {
            toDoList.add(change.getAddedToDos());
        } catch (IllegalValueException exception) {
            // there were duplicate to-dos
            // revert removal of to-dos
            toDoList.add(change.getDeletedToDos());
            lastToDoListChange = null;
            throw exception;
        }
    }

    public boolean undoToDoList() {
        if (toDoListChanges.isEmpty()) {
            return false; // Nothing else to undo
        }

        ToDoListChange change = toDoListChanges.get(toDoListChanges.size() - 1);

        try {
            applyToDoListChange(change.getReverseChange());
        } catch (IllegalValueException exception) {
            assert false; // Undo should always work
            return false; // Undo failed
        }

        // move changes to undo list
        toDoListUndoChanges.add(change);
        toDoListChanges.remove(toDoListChanges.size() - 1);

        return true;
    }

    public boolean redoToDoList() {
        if (toDoListUndoChanges.isEmpty()) {
            return false; // No undos to redo
        }

        ToDoListChange change = toDoListUndoChanges.get(toDoListUndoChanges.size() - 1);

        try {
            applyToDoListChange(change);
        } catch (IllegalValueException exception) {
            assert false; // Redo should always work
            return false; // Redo failed
        }

        // move changes from undo list
        toDoListChanges.add(change);
        toDoListUndoChanges.remove(toDoListUndoChanges.size() - 1);

        return true;
    }

    /**
     * Latest change on the to-do list, including undo/redo
     */
    public Optional<ToDoListChange> getLastToDoListChange() {
        return Optional.ofNullable(lastToDoListChange);
    }
}
```
###### \java\seedu\commando\model\ui\UiModel.java
``` java
/**
 * Handles any logic in displaying on the UI, eg, splitting/filtering the to-do list
 */
public class UiModel {
    private final Logger logger = LogsCenter.getLogger(LogicManager.class);

    private final ToDoListManager toDoListManager;
    private final FilteredList<ReadOnlyToDo> filteredToDoList;
    private final ObservableList<UiToDo> events;
    private final ObservableList<UiToDo> tasks;
    private final UnmodifiableObservableList<UiToDo> protectedEvents;
    private final UnmodifiableObservableList<UiToDo> protectedTasks;
    private final ArrayList<UiToDo> toDoAtIndices;
    private int runningIndex;
    {
        events = FXCollections.observableArrayList();
        tasks = FXCollections.observableArrayList();
        protectedEvents = new UnmodifiableObservableList<>(events);
        protectedTasks = new UnmodifiableObservableList<>(tasks);
        toDoAtIndices = new ArrayList<>();
    }

    public UiModel(ToDoListManager toDoListManager) {
        this.toDoListManager = toDoListManager;
        filteredToDoList = new FilteredList<>(toDoListManager.getToDoList().getToDos());

        setToDoListFilter(Collections.emptySet(), Collections.emptySet(), false);

        updateEventsAndTasks();
        filteredToDoList.addListener(new ListChangeListener<ReadOnlyToDo>() {
            @Override
            public void onChanged(Change<? extends ReadOnlyToDo> change) {
                updateEventsAndTasks();
            }
        });
    }

    /**
     * Get to-do item at index as displayed on the UI
     */
    public Optional<UiToDo> getToDoAtIndex(int index) {
        if (index - 1 < 0 || index - 1 >= toDoAtIndices.size()) {
            return Optional.empty();
        } else {
            return Optional.of(toDoAtIndices.get(index - 1));
        }
    }

    /**
     * Sets a filter on the to-do list
     * Asserts {@param keywords} and {@param tags} to be non-null
     * If {@param ifHistoryMode} is true, only filter finished to-dos, and sort in reverse chronological order
     * Else, only filter, sorted in chronological order, such that it is not finished or
     * its finished date is after/during the current day
     */
    public void setToDoListFilter(Set<String> keywords, Set<Tag> tags, boolean ifHistoryMode) {
        assert keywords != null;
        assert tags != null;

        filteredToDoList.setPredicate(toDo -> {
            if (!ifHistoryMode && toDo.isFinished()
                && toDo.getDateFinished().get().toLocalDate().isBefore(LocalDate.now())) {
                return false; // if normal mode but to-do is finished before the current day
            } else if (ifHistoryMode && !toDo.isFinished()) {
                return false; // if history mode but to-do is unfinished
            }

            return ifMatchesFilter(toDo, keywords, tags);
        });
    }

    /**
     * Clears the filter on the to-do list
     */
    public void clearToDoListFilter(boolean ifHistoryMode) {
        setToDoListFilter(Collections.emptySet(), Collections.emptySet(), ifHistoryMode);
    }

    public UnmodifiableObservableList<UiToDo> getEvents() {
        return protectedEvents;
    }

    public UnmodifiableObservableList<UiToDo> getTasks() {
        return protectedTasks;
    }

    /**
     * Called to update the to-do list when it changes
     */
    private void updateEventsAndTasks() {
        // Sort and filter observableEvents and observableTasks for UI
        List<ReadOnlyToDo> events = processEvents(filteredToDoList);
        List<ReadOnlyToDo> tasks = processTasks(filteredToDoList);

        toDoAtIndices.clear();

        // Add indices to events first and set to observable events
        // Also check if the events are new with respect to last change
        runningIndex = 0;

        Optional<ToDoListChange> change = toDoListManager.getLastToDoListChange();

        ReadOnlyToDoList newToDos = change.isPresent()
            ? change.get().getAddedToDos() : new ToDoList();

        this.events.setAll(events.stream().map(
            toDo -> new UiToDo(toDo, ++ runningIndex, newToDos.contains(toDo))
        ).collect(Collectors.toList()));
        toDoAtIndices.addAll(this.events);

        // Then do the same for tasks
        this.tasks.setAll(tasks.stream().map(
            toDo -> new UiToDo(toDo, ++ runningIndex, newToDos.contains(toDo))
        ).collect(Collectors.toList()));
        toDoAtIndices.addAll(this.tasks);

        // running index should be incremented by no. of to-dos
        assert runningIndex == toDoAtIndices.size();

        // log events and tasks shown
        logger.info("Events: " + this.events.stream().map(uiToDo -> uiToDo.getIndex() + ") " + uiToDo.getTitle())
            .collect(Collectors.joining(",")));

        logger.info("Tasks: " + this.tasks.stream().map(uiToDo -> uiToDo.getIndex() + ") " + uiToDo.getTitle())
            .collect(Collectors.joining(",")));
    }

    private List<ReadOnlyToDo> processTasks(List<ReadOnlyToDo> toDos) {
        List<ReadOnlyToDo> tasks = toDos.stream().filter(UiToDo::isTask).collect(Collectors.toList());

        // For observableTasks, sort by whether they are done,
        // then whether have due dates, then chronological order
        tasks.sort((task1, task2) -> {
            if (!task1.isFinished() && task2.isFinished()) {
                return -1; // task1 first
            }

            if (task1.isFinished() && !task2.isFinished()) {
                return 1; // task2 first
            }

            if (task1.isFinished() && task2.isFinished()) {

                // If finished dates are the same, put the task which was finished earlier in front
                int dateComparison = task1.getDateFinished().get()
                    .compareTo(task2.getDateFinished().get());
                if (dateComparison == 0) {
                    return task1.getDateCreated().compareTo(task2.getDateCreated());
                } else {
                    return dateComparison;
                }

            } else {
                assert !task1.isFinished();
                assert !task2.isFinished();

                if (task1.getDueDate().isPresent() && !task2.getDueDate().isPresent()) {
                    return -1; // taskl first
                }

                if (task2.getDueDate().isPresent() && !task1.getDueDate().isPresent()) {
                    return 1; // task2 first
                }

                // If both don't have dates, put the older created task in front
                if (!task1.getDueDate().isPresent() && !task2.getDueDate().isPresent()) {
                    return task1.getDateCreated().compareTo(task2.getDateCreated());
                } else {
                    assert task1.getDueDate().isPresent();
                    assert task2.getDueDate().isPresent();

                    // If even due dates are the same, put the task which was finished earlier in front
                    int dateComparison = task1.getDueDate().get().value
                        .compareTo(task2.getDueDate().get().value);
                    if (dateComparison == 0) {
                        return task1.getDateCreated().compareTo(task2.getDateCreated());
                    } else {
                        return dateComparison;
                    }
                }
            }
        });

        return tasks;
    }

    private List<ReadOnlyToDo> processEvents(List<ReadOnlyToDo> toDos) {
        List<ReadOnlyToDo> events = toDos.stream()
            .filter(UiToDo::isEvent)
            .collect(Collectors.toList());

        // For observableEvents, sort by chronological order
        events.sort((event1, event2) -> {
            if (!event1.isFinished() && event2.isFinished()) {
                return -1; // event1 first
            }

            if (event1.isFinished() && !event2.isFinished()) {
                return 1; // event2 first
            }

            // Must have date ranges because they are events
            assert event2.getDateRange().isPresent();
            assert event2.getDateRange().isPresent();

            int rangeComparison = event1.getDateRange().get().startDate.compareTo(event2.getDateRange().get().startDate);

            // If start dates are the same, put the older created event in front
            if (rangeComparison == 0) {
                return event1.getDateCreated().compareTo(event2.getDateCreated());
            } else {
                return rangeComparison;
            }
        });

        return events;
    }

    //================================================================================
    //  Private methods for filtering
    //================================================================================

    private boolean ifMatchesFilter(ReadOnlyToDo toDo, Set<String> keywords, Set<Tag> tags) {
        return (keywords.stream()
            .allMatch(keyword -> checkForKeyword(toDo, keyword))) // contains all keywords
            && (tags.stream()
            .allMatch(tag -> checkForTag(toDo, tag))); // and has all the tags
    }

    private boolean checkForKeyword(ReadOnlyToDo toDo, String keyword) {
        return StringUtil.substringIgnoreCase(toDo.getTitle().value, keyword) ||
            toDo.getTags().stream().anyMatch(toDoTag -> StringUtil.substringIgnoreCase(toDoTag.value, keyword));
    }

    private boolean checkForTag(ReadOnlyToDo toDo, Tag tag) {
        return toDo.getTags().stream().anyMatch(toDoTag -> toDoTag.value.equalsIgnoreCase(tag.value));
    }
}
```
###### \java\seedu\commando\model\ui\UiToDo.java
``` java
/**
 * Represents a to-do on the UI
 */
public class UiToDo implements ReadOnlyToDo {

    private final ReadOnlyToDo toDo;
    private final int index;
    private final boolean isNew;

    public UiToDo(ReadOnlyToDo toDo, int index, boolean isNew) {
        this.toDo = toDo;
        this.isNew = isNew;
        this.index = index;
    }

    /**
     * Returns whether a to-do item is an event
     */
    public static boolean isEvent(ReadOnlyToDo todo) {
        return todo.getDateRange().isPresent();
    }

    /**
     * Returns whether a to-do item is a task
     */
    public static boolean isTask(ReadOnlyToDo todo) {
        return !todo.getDateRange().isPresent();
    }


    @Override
    public Title getTitle() {
        return toDo.getTitle();
    }

    @Override
    public Optional<DateRange> getDateRange() {
        return toDo.getDateRange();
    }

    @Override
    public Optional<DueDate> getDueDate() {
        return toDo.getDueDate();
    }

    @Override
    public Set<Tag> getTags() {
        return toDo.getTags();
    }

    @Override
    public boolean isFinished() {
        return toDo.isFinished();
    }

    @Override
    public Optional<LocalDateTime> getDateFinished() {
        return toDo.getDateFinished();
    }

    @Override
    public LocalDateTime getDateCreated() {
        return toDo.getDateCreated();
    }

    @Override
    public ObservableValue getObservableValue() {
        return toDo.getObservableValue();
    }

    public int getIndex() {
        return index;
    }

    public boolean isNew() { return isNew; }

    public boolean isEvent() {
        return isEvent(this);
    }

    public boolean isTask() {
        return isTask(this);
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
            || (other instanceof UiToDo // instanceof handles nulls
            && this.isSameStateAs((UiToDo) other)
            && index == ((UiToDo) other).index);
    }

    @Override
    public int hashCode() {
        return Objects.hash(toDo, index);
    }

    @Override
    public String toString() {
        return toDo + " with index of " + index;
    }
}
```
###### \java\seedu\commando\model\UserPrefs.java
``` java
/**
 * Represents the user's preferences.
 */
public class UserPrefs {
    private GuiSettings guiSettings = new GuiSettings();
    private StringProperty toDoListFilePath = new SimpleStringProperty(Config.DefaultToDoListFilePath);

    public UserPrefs() {}

    public GuiSettings getGuiSettings() {
        return guiSettings;
    }

    public ObservableValue<String> getToDoListFilePath() {
        return toDoListFilePath;
    }

    public void setToDoListFilePath(String filePath) {
        toDoListFilePath.setValue(filePath);
    }

    public void setGuiSettings(GuiSettings guiSettings) {
        this.guiSettings = guiSettings;
    }

    public void setGuiSettings(double width, double height, int x, int y, boolean isMaximized) {
        guiSettings = new GuiSettings(width, height, x, y, isMaximized);
    }

    @Override
    public boolean equals(Object other) {
        if (other == this) {
            return true;
        }
        if (!(other instanceof UserPrefs)) { // this handles null as well.
            return false;
        }

        return (guiSettings.equals(((UserPrefs) other).guiSettings)
            && toDoListFilePath.getValue().equals(((UserPrefs) other).toDoListFilePath.getValue()));
    }

    @Override
    public int hashCode() {
        return Objects.hash(guiSettings, toDoListFilePath);
    }

    @Override
    public String toString() {
        return String.join(",",
            "GuiSettings: " + guiSettings,
            "To-do List File Path: " + toDoListFilePath.getValue()
        );
    }

    public JsonObject getJsonObject() {
        JsonObject jsonObject = new JsonObject();
        jsonObject.guiSettings = guiSettings;
        jsonObject.toDoListFilePath = toDoListFilePath.getValue();
        return jsonObject;
    }

    /**
     * Sets fields of user prefs to that of the json object's
     * If any of the json object's fields are null, the default of user prefs are used
     */
    public void setJsonObject(JsonObject jsonObject) {
        if (jsonObject.guiSettings != null) {
            guiSettings = jsonObject.guiSettings;
        }

        if (jsonObject.toDoListFilePath != null) {
            toDoListFilePath.setValue(jsonObject.toDoListFilePath);
        }
    }

    public static class JsonObject {
        public GuiSettings guiSettings;
        public String toDoListFilePath;
    }
}
```
