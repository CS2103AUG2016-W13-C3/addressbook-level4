# A0139697H
###### \java\seedu\commando\commons\core\Messages.java
``` java
/**
 * Container for user visible messages.
 */
public class Messages {
    public static final String HELP_TOPICS = "add | edit | delete | find | list | clear | finish | unfinish | recall | undo | redo | faq | datetime | cheatsheet";
    public static final String DATE_FORMAT = "Date Time Formats: 9 jan 2018 23:59 | Jan 9 2019 1900h | coming friday morning | today 23:59";
    public static final String HELP_COMMAND_FORMAT = ">> help\n"
        + ">> help <topic>\n"
        + "Available topics: " + HELP_TOPICS;

```
###### \java\seedu\commando\logic\commands\AddCommand.java
``` java

/**
 * Adds a to-do to the to-do list.
 */
public class AddCommand extends Command {
    public static final String COMMAND_WORD = "add";

    // To-do that is going to be added
    private final ToDo toDo;

    /**
     * Initializes an add command.
     *
     * @param title title of to-do to add, non-null
     */
    public AddCommand(Title title) {
        assert title != null;

        toDo = new ToDo(title);
    }

    @Override
    public CommandResult execute() throws NoModelException {
        Model model = getModel();

        try {
            ensureOnlyDueDateOrDateRangePresent();

            model.changeToDoList(new ToDoListChange(
                new ToDoList().add(toDo),
                new ToDoList()
            ));

            return new CommandResult(getFeedback());

        } catch (IllegalValueException exception) {
            return new CommandResult(exception.getMessage(), true);
        }
    }

    private String getFeedback() {
        String feedback = String.format(Messages.ADD_COMMAND, toDo.getTitle().toString());

        // If event already over, warn user
        if (toDo.getDateRange().isPresent()
            && toDo.getDateRange().get().endDate.isBefore(LocalDateTime.now())) {
            feedback += "\n" + Messages.ADD_COMMAND_EVENT_OVER_WARNING;
        }

        return feedback;
    }

    private void ensureOnlyDueDateOrDateRangePresent() throws IllegalValueException {
        // Ensure to-do doesn't have both duedate and daterange
        if (toDo.getDateRange().isPresent() && toDo.getDueDate().isPresent()) {
            throw new IllegalValueException(Messages.TODO_CANNOT_HAVE_DUEDATE_AND_DATERANGE);
        }
    }

    /**
     * Sets the date range of the to-do to be added, must be non-null.
     *
     * @param dateRange date range to set
     */
    public void setDateRange(DateRange dateRange) {
        assert dateRange != null;

        toDo.setDateRange(dateRange);
    }

    /**
     * Sets the due date of the to-do to be added, must be non-null.
     *
     * @param dueDate due date to set
     */
    public void setDueDate(DueDate dueDate) {
        assert dueDate != null;

        toDo.setDueDate(dueDate);
    }

    /**
     * Gets the title of the to-do to be added.
     *
     * @return optional of title of to-do to be added, empty if none
     */
    public Title getTitle() {
        return toDo.getTitle();
    }

    /**
     * Sets the tags of the to-do to be added, must be non-null.
     *
     * @param tags set of tags to set
     */
    public void setTags(Set<Tag> tags) {
        assert tags != null;

        toDo.setTags(tags);
    }
}
```
###### \java\seedu\commando\logic\commands\ClearCommand.java
``` java
/**
 * Clears the to-do list
 */
public class ClearCommand extends Command {

    public static final String COMMAND_WORD = "clear";

    public ClearCommand() {}

    @Override
    public CommandResult execute() throws NoModelException {
        Model model = getModel();

        try {
            // Delete all to-dos
            model.changeToDoList(new ToDoListChange(
                new ToDoList(),
                model.getToDoList()
            ));

            return new CommandResult(Messages.CLEAR_COMMAND);
        } catch (IllegalValueException exception) {
            return new CommandResult(exception.getMessage(), true);
        }
    }
}
```
###### \java\seedu\commando\logic\commands\Command.java
``` java

/**
 * Represents a command with hidden internal logic and the ability to be executed.
 */
public abstract class Command {

    private EventsCenter eventsCenter;
    private Model model;

    /**
     * Sets the EventsCenter for the command.
     * {@param eventsCenter} must be non-null.
     */
    public void setEventsCenter(EventsCenter eventsCenter) {
        assert eventsCenter != null;

        this.eventsCenter = eventsCenter;
    }

    /**
     * Sets the Model for the command.
     * {@param model} must be non-null.
     */
    public void setModel(Model model) {
        assert model != null;

        this.model = model;
    }

    public static class NoEventsCenterException extends Exception {
    }

    public static class NoModelException extends Exception {
    }

    /**
     * Gets the events center set by {@link #setEventsCenter(EventsCenter)}.
     *
     * @return events center of this command
     * @throws NoEventsCenterException if {@link #setEventsCenter(EventsCenter)} hasn't been called
     */
    protected EventsCenter getEventsCenter() throws NoEventsCenterException {
        if (eventsCenter == null) {
            throw new NoEventsCenterException();
        }

        return eventsCenter;
    }

    /**
     * Gets the model set by {@link #setModel(Model)}}.
     *
     * @return model of this command
     * @throws NoModelException if {@link #setModel(Model)} hasn't been called
     */
    protected Model getModel() throws NoModelException {
        if (model == null) {
            throw new NoModelException();
        }

        return model;
    }

    /**
     * Executes the command.
     *
     * @return result of the command packaged in {@link CommandResult}
     */
    public abstract CommandResult execute() throws NoModelException, NoEventsCenterException;
}
```
###### \java\seedu\commando\logic\commands\CommandFactory.java
``` java

/**
 * Maps and builds commands from input strings, using {@link CommandParser}.
 * In charge of splitting up input strings to required parts for commands.
 */
public class CommandFactory {
    private static final String KEYWORD_DELETE_TIME = "time";
    private static final String KEYWORD_DELETE_TAG = "tag";
    private static final String KEYWORD_DELETE_RECURRENCE = "recurrence";

    private CommandParser commandParser = new CommandParser();

    public static class InvalidCommandFormatException extends Exception {
        public final String command;

        private InvalidCommandFormatException(String message, String command) {
            super(message);
            this.command = command;
        }
    }

    public static class UnknownCommandWordException extends Exception {
        public final String commandWord;

        private UnknownCommandWordException(String commandWord) {
            this.commandWord = commandWord;
        }
    }

    public static class MissingCommandWordException extends Exception {
        private MissingCommandWordException() {}
    }

    /**
     * Interprets an input string as a command, initializes it, and returns it.
     *
     * @return instance of a command
     * @throws InvalidCommandFormatException if command format is invalid
     * @throws UnknownCommandWordException if command word is unknown
     * @throws MissingCommandWordException if command word is missing
     */
    public Command build(String inputString) throws InvalidCommandFormatException,
        UnknownCommandWordException, MissingCommandWordException {
        commandParser.setInput(inputString);

        // Check if command word exists
        Optional<String> commandWord = commandParser.extractWord();

        if (!commandWord.isPresent()) {
            throw new MissingCommandWordException();
        }

        String processedCommandWord = commandWord.get().toLowerCase();
        try {
            switch (processedCommandWord) {
                case AddCommand.COMMAND_WORD: return buildAddCommand();
                case DeleteCommand.COMMAND_WORD: return buildDeleteCommand();
                case FinishCommand.COMMAND_WORD: return buildFinishCommand();
                case UnfinishCommand.COMMAND_WORD: return buildUnfinishCommand();
                case FindCommand.COMMAND_WORD: return buildFindCommand();
                case ExitCommand.COMMAND_WORD: return buildExitCommand();
                case ClearCommand.COMMAND_WORD: return buildClearCommand();
                case HelpCommand.COMMAND_WORD: return buildHelpCommand();
                case EditCommand.COMMAND_WORD: return buildEditCommand();
                case UndoCommand.COMMAND_WORD: return buildUndoCommand();
                case RedoCommand.COMMAND_WORD: return buildRedoCommand();
                case StoreCommand.COMMAND_WORD: return buildStoreCommand();
                case ExportCommand.COMMAND_WORD: return buildExportCommand();
                case ImportCommand.COMMAND_WORD: return buildImportCommand();
                case RecallCommand.COMMAND_WORD: return buildRecallCommand();
                case ListCommand.COMMAND_WORD: return buildListCommand();
                default: throw new UnknownCommandWordException(processedCommandWord);
            }
        } catch (IllegalValueException e) {
            throw new InvalidCommandFormatException(e.getMessage(), processedCommandWord);
        }
    }

    private Command buildRecallCommand() {
        RecallCommand command = new RecallCommand();

        // Extract tags
        Set<Tag> tags = commandParser.extractTrailingTags();
        if (!tags.isEmpty()) {
            command.setTags(tags);
        }

        // Try to find keywords
        Set<String> keywords = commandParser.extractWords().stream().collect(Collectors.toSet());
        command.setKeywords(keywords);

        return command;
    }


    private Command buildExitCommand() throws IllegalValueException {
        ensureInputIsEmpty(ExitCommand.COMMAND_WORD);

        return new ExitCommand();
    }

```
###### \java\seedu\commando\logic\commands\CommandFactory.java
``` java
    private Command buildAddCommand() throws IllegalValueException {
        // Check if quoted title exists
        Optional<String> quotedTitle = commandParser.extractQuotedTitle();

        // Extract tags
        Set<Tag> tags = commandParser.extractTrailingTags();

        // Extract date range, if exists
        Optional<DateRange> dateRange = extractToDoDateRange();

        // Extract due date, if exists
        Optional<DueDate> dueDate = commandParser.extractTrailingDueDate();

        // Initialize command
        // Extract title, if there was no quoted title
        // Otherwise, use the quoted title
        AddCommand command;
        if (quotedTitle.isPresent()) {
            command = new AddCommand(new Title(quotedTitle.get()));
        } else {
            String title = commandParser.extractText().orElseThrow(() -> new IllegalValueException(Messages.MISSING_TODO_TITLE));
            command = new AddCommand(new Title(title));
        }

        // Put in fields
        if (!tags.isEmpty()) {
            command.setTags(tags);
        }

        dueDate.ifPresent(command::setDueDate);
        dateRange.ifPresent(command::setDateRange);

        ensureInputIsEmpty(AddCommand.COMMAND_WORD);

        return command;
    }

    private Command buildDeleteCommand() throws IllegalValueException {
        List<Integer> indices = extractIndices();

        DeleteCommand deleteCommand = new DeleteCommand(indices);

        // check for fields
        List<String> words = commandParser.extractWords();

        int fieldsCount = 0;

        if (words.contains(KEYWORD_DELETE_TAG)) {
            deleteCommand.deletesTags();
            fieldsCount++;
        }

        if (words.contains(KEYWORD_DELETE_TIME)) {
            deleteCommand.deletesTime();
            fieldsCount++;
        }

        if (words.contains(KEYWORD_DELETE_RECURRENCE)) {
            deleteCommand.deletesRecurrence();
            fieldsCount++;
        }

        // If there were extra words besides the fields, invalid command format
        if (fieldsCount != words.size()) {
            throw new IllegalValueException(String.format(Messages.INVALID_COMMAND_FORMAT, DeleteCommand.COMMAND_WORD));
        }

        return deleteCommand;
    }

    private Command buildFinishCommand() throws IllegalValueException {
        List<Integer> indices = extractIndices();
        ensureInputIsEmpty(FinishCommand.COMMAND_WORD);

        return new FinishCommand(indices);
    }

    private Command buildUnfinishCommand() throws IllegalValueException {
        List<Integer> indices = extractIndices();
        ensureInputIsEmpty(UnfinishCommand.COMMAND_WORD);

        return new UnfinishCommand(indices);
    }

    private Command buildFindCommand() {
        FindCommand command = new FindCommand();

        // Extract tags
        Set<Tag> tags = commandParser.extractTrailingTags();
        if (!tags.isEmpty()) {
            command.setTags(tags);
        }

        // Try to find keywords
        Set<String> keywords = commandParser.extractWords().stream().collect(Collectors.toSet());
        command.setKeywords(keywords);

        return command;
    }

    private Command buildClearCommand() throws IllegalValueException {
        ensureInputIsEmpty(ClearCommand.COMMAND_WORD);

        return new ClearCommand();
    }

    private Command buildHelpCommand() {
        // Try to find command word
        Optional<String> word = commandParser.extractText();

        if (word.isPresent()) {
            return new HelpCommand(word.get());
        } else {
            return new HelpCommand();
        }
    }

    private Command buildEditCommand() throws IllegalValueException {
        int index = commandParser.extractInteger().orElseThrow(
            () -> new IllegalValueException(Messages.MISSING_TODO_ITEM_INDEX)
        );

        Optional<String> quotedTitle = commandParser.extractQuotedTitle();

        EditCommand command = new EditCommand(index);

        // Extract tags
        Set<Tag> tags = commandParser.extractTrailingTags();

        // Put in fields
        if (!tags.isEmpty()) {
            command.setTags(tags);
        }
        extractToDoDateRange().ifPresent(command::setDateRange);
        commandParser.extractTrailingDueDate().ifPresent(command::setDueDate);

        // Try to extract title, if there was no quoted title
        // Otherwise, use the quoted title
        if (quotedTitle.isPresent()) {
            command.setTitle(new Title(quotedTitle.get()));
        } else {
            commandParser.extractText().ifPresent(
                title -> command.setTitle(new Title(title))
            );
        }

        ensureInputIsEmpty(EditCommand.COMMAND_WORD);

        return command;
    }

```
###### \java\seedu\commando\logic\commands\CommandResult.java
``` java

/**
 * Represents the result of a command execution.
 */
public class CommandResult {
    private final String feedback;
    private boolean hasError;

    /**
     * Initializes the result of a command.
     *
     * @param feedback feedback to be shown to user
     * @param hasError if there was an error and command failed
     */
    public CommandResult(String feedback, boolean hasError) {
        assert feedback != null;

        this.feedback = feedback;
        this.hasError = hasError;
    }

    /**
     * Initializes the result of successful command.
     */
    public CommandResult(String feedback) {
        this(feedback, false);
    }

    public String getFeedback() {
        return feedback;
    }

    public boolean hasError() {
        return hasError;
    }
}
```
###### \java\seedu\commando\logic\commands\DeleteCommand.java
``` java

/**
 * Deletes to-do(s), or their fields.
 */
public class DeleteCommand extends Command {

    public static final String COMMAND_WORD = "delete";

    private final List<Integer> toDoIndices;
    private boolean ifDeleteTime = false;
    private boolean ifDeleteTags = false;
    private boolean ifDeleteRecurrence = false;

    /**
     * Initializes a delete command.
     *
     * @param toDoIndices list of indices of UI to-dos to target, non-null
     */
    public DeleteCommand(List<Integer> toDoIndices) {
        assert toDoIndices != null;

        this.toDoIndices = toDoIndices;
    }

```
###### \java\seedu\commando\logic\commands\EditCommand.java
``` java

/**
 * Edits a to-do in the current to-do list.
 */
public class EditCommand extends Command {
    public static final String COMMAND_WORD = "edit";

    private final int toDoIndex;
    private Title title = null;
    private DateRange dateRange = null;
    private DueDate dueDate = null;
    private Set<Tag> tags = null;

    /**
     * Initializes an edit command.
     *
     * @param toDoIndex index of UI to-do to edit
     */
    public EditCommand(int toDoIndex) {
        this.toDoIndex = toDoIndex;
    }

    public CommandResult execute() throws NoModelException {
        Model model = getModel();

        try {
            ReadOnlyToDo toDoToEdit = getToDoAtIndex(model, toDoIndex);
            ToDo editedToDo = getEditedToDo(toDoToEdit);
            ensureToDoEdited(toDoToEdit, editedToDo);
            ensureOnlyDueDateOrDateRangePresent(editedToDo);

            model.changeToDoList(new ToDoListChange(
                new ToDoList().add(editedToDo),
                new ToDoList().add(toDoToEdit)
            ));

            return new CommandResult(getFeedback(editedToDo));

        } catch (IllegalValueException exception) {
            return new CommandResult(exception.getMessage(), true);
        }
    }

    private String getFeedback(ToDo editedToDo) {
        String feedback = String.format(Messages.EDIT_COMMAND, editedToDo.getTitle().toString());

        // If event already over, warn user
        if (editedToDo.getDateRange().isPresent()
            && editedToDo.getDateRange().get().endDate.isBefore(LocalDateTime.now())) {
            feedback += "\n" + Messages.EDIT_COMMAND_EVENT_OVER_WARNING;
        }
        return feedback;
    }

    private void ensureToDoEdited(ReadOnlyToDo toDoToEdit, ToDo editedToDo) throws IllegalValueException {
        // Check if to-do has changed
        if (editedToDo.isSameStateAs(toDoToEdit)) {
            throw new IllegalValueException(Messages.EDIT_COMMAND_NO_EDITS);
        }
    }

    private ToDo getEditedToDo(ReadOnlyToDo toDoToEdit) {
        // Copy original to-do
        ToDo newToDo = new ToDo(toDoToEdit);

        // Set fields if exist
        if (title != null) {
            newToDo.setTitle(title);
        }

        if (dueDate != null) {
            newToDo.setDueDate(dueDate);
        }

        if (dateRange != null) {
            newToDo.setDateRange(dateRange);
        }

        if (tags != null) {
            newToDo.setTags(tags);
        }

        return newToDo;
    }

    private void ensureOnlyDueDateOrDateRangePresent(ReadOnlyToDo toDo) throws IllegalValueException {
        // Ensure to-do doesn't have both duedate and daterange
        if (toDo.getDateRange().isPresent() && toDo.getDueDate().isPresent()) {
            throw new IllegalValueException(Messages.TODO_CANNOT_HAVE_DUEDATE_AND_DATERANGE);
        }
    }

    private ReadOnlyToDo getToDoAtIndex(Model model, int toDoIndex) throws IllegalValueException {
        Optional<UiToDo> toDoToEdit = model.getUiToDoAtIndex(toDoIndex);

        if (!toDoToEdit.isPresent()) {
            throw new IllegalValueException(String.format(Messages.TODO_ITEM_INDEX_INVALID, toDoIndex));
        }

        return toDoToEdit.get();
    }

    /**
     * Sets the title for the target to-do, must be non-null.
     *
     * @param title title to set
     */
    public void setTitle(Title title) {
        assert title != null;

        this.title = title;
    }

    /**
     * Sets the date range for the target to-do, must be non-null.
     *
     * @param dateRange date range to set
     */
    public void setDateRange(DateRange dateRange) {
        assert dateRange != null;

        this.dateRange = dateRange;
    }

    /**
     * Sets the due date for the target to-do, must be non-null.
     *
     * @param dueDate due date to set
     */
    public void setDueDate(DueDate dueDate) {
        assert dueDate != null;

        this.dueDate = dueDate;
    }

    /**
     * Sets the tags to replace for the target to-do, must be non-null.
     *
     * @param tags tags to set
     */
    public void setTags(Set<Tag> tags) {
        assert tags != null;

        this.tags = tags;
    }
}
```
###### \java\seedu\commando\logic\commands\ExitCommand.java
``` java
/**
 * Terminates the program.
 */
public class ExitCommand extends Command {

    public static final String COMMAND_WORD = "exit";

    /**
     * Initializes an exit command.
     */
    public ExitCommand() {}

    @Override
    public CommandResult execute() throws NoEventsCenterException {
        EventsCenter eventsCenter = getEventsCenter();

        eventsCenter.post(new ExitAppRequestEvent());
        return new CommandResult(Messages.EXIT_COMMAND);
    }
}
```
###### \java\seedu\commando\logic\commands\FindCommand.java
``` java

/**
 * Shows all unfinished to-dos, optionally filtering by keywords and tags.
 */
public class FindCommand extends Command {
    public static final String COMMAND_WORD = "find";

    private Set<String> keywords = Collections.emptySet();
    private Set<Tag> tags = Collections.emptySet();

    /**
     * Initializes a find command.
     */
    public FindCommand() {}

    /**
     * Asserts that {@code uiLogic} is non-null
     */
    @Override
    public CommandResult execute() throws NoModelException {
        Model model = getModel();

        if (keywords.isEmpty() && tags.isEmpty()) {
            // if no keywords or tags are provided, show all unfinished to-dos
            model.clearUiToDoListFilter(Model.FILTER_MODE.UNFINISHED);
            return new CommandResult(Messages.FIND_COMMAND_CLEAR);
        }

        model.setUiToDoListFilter(keywords, tags, Model.FILTER_MODE.UNFINISHED);

        // If no to-dos found in search
        if (model.getUiEvents().isEmpty() && model.getUiTasks().isEmpty()) {
            return new CommandResult(String.format(Messages.FIND_COMMAND_NO_TODOS, getSearchString()));
        }

        return new CommandResult(String.format(Messages.FIND_COMMAND, getSearchString()));
    }

    private String getSearchString() {
        Stream<String> keywordsStream = new TreeSet<>(keywords).stream();
        Stream<String> tagsStream = new TreeSet<>(tags).stream().map(Tag::toString);

        return "[" + Stream.concat(keywordsStream, tagsStream).collect(Collectors.joining(", ")) + "]";
    }

    /**
     * Sets the keywords for the command, must be non-null.
     *
     * @param keywords set of keywords to set
     */
    public void setKeywords(Set<String> keywords) {
        assert keywords != null;

        this.keywords = keywords;
    }

    /**
     * Sets the tags for the command, must be non-null.
     *
     * @param tags set of tags to set
     */
    public void setTags(Set<Tag> tags) {
        assert tags != null;

        this.tags = tags;
    }
}
```
###### \java\seedu\commando\logic\commands\HelpCommand.java
``` java

/**
 * Show the user guide in a new window, jumping to the appropriate
 * section of the user guide if necessary.
 */
public class HelpCommand extends Command {
    public static final String COMMAND_WORD = "help";

    private final String commandWord;

    /**
     * Shows general help.
     */
    public HelpCommand() {
        commandWord = "";
    }

    /**
     * Shows help for specific command word {@param commandWord}.
     */
    public HelpCommand(String commandWord) {
        this.commandWord = commandWord;
    }

    @Override
    public CommandResult execute() throws NoEventsCenterException {
        EventsCenter eventsCenter = getEventsCenter();

        if (commandWord.isEmpty()) {
            eventsCenter.post(new ShowHelpRequestEvent(""));

            return new CommandResult(Messages.HELP_COMMAND);
        } else {
            Optional<String> anchor = Config.getUserGuideAnchorForCommandWord(commandWord);

            // Check if the command word is recognized
            if (!anchor.isPresent()) {
                return new CommandResult(Messages.HELP_COMMAND_INVALID_TOPIC, true);
            }

            eventsCenter.post(new ShowHelpRequestEvent(anchor.get()));
            return new CommandResult(String.format(Messages.HELP_COMMAND_TOPIC, commandWord));
        }
    }
}
```
###### \java\seedu\commando\logic\commands\RecallCommand.java
``` java
/**
 * Shows all finished to-dos, optionally filtering by keywords and tags.
 */
public class RecallCommand extends Command {
    public static final String COMMAND_WORD = "recall";

    private Set<String> keywords = Collections.emptySet();
    private Set<Tag> tags = Collections.emptySet();

    /**
     * Initializes a recall command.
     */
    public RecallCommand() {}

    @Override
    public CommandResult execute() throws NoModelException {
        Model model = getModel();

        if (keywords.isEmpty() && tags.isEmpty()) {
            // if no keywords or tags are provided, show all finished to-dos
            model.clearUiToDoListFilter(Model.FILTER_MODE.FINISHED);
            return new CommandResult(Messages.RECALL_COMMAND_CLEAR);
        }

        model.setUiToDoListFilter(keywords, tags, Model.FILTER_MODE.FINISHED);

        // If no to-dos found in search
        if (model.getUiEvents().isEmpty() && model.getUiTasks().isEmpty()) {
            return new CommandResult(String.format(Messages.RECALL_COMMAND_NO_TODOS, getSearchString()));
        }

        return new CommandResult(String.format(Messages.RECALL_COMMAND, getSearchString()));
    }

    private String getSearchString() {
        Stream<String> keywordsStream = new TreeSet<>(keywords).stream();
        Stream<String> tagsStream = new TreeSet<>(tags).stream().map(Tag::toString);

        return "[" + Stream.concat(keywordsStream, tagsStream).collect(Collectors.joining(", ")) + "]";
    }


    /**
     * Sets the keywords for the command, must be non-null.
     *
     * @param keywords set of keywords to set
     */
    public void setKeywords(Set<String> keywords) {
        assert keywords != null;

        this.keywords = keywords;
    }

    /**
     * Sets the tags for the command, must be non-null.
     *
     * @param tags set of tags to set
     */
    public void setTags(Set<Tag> tags) {
        assert tags != null;

        this.tags = tags;
    }
}
```
###### \java\seedu\commando\logic\Logic.java
``` java

/**
 * API of the Logic component.
 */
public interface Logic {

    /**
     * Executes an input string as a command and returns the result.
     *
     * @param commandText input string as entered by the user to be parsed as a command
     * @return result of the command packaged in {@link CommandResult}
     */
    CommandResult execute(String commandText);

    /**
     * Returns observable read-only list of UI to-dos considered as events by {@link UiToDo#isEvent()}
     * to be displayed on the UI.
     * The ordering of the list is to be respected.
     *
     * @return an observable read-only list of {@link UiToDo} that are events
     */
    UnmodifiableObservableList<UiToDo> getUiEvents();

    /**
     * Returns observable read-only list of UI to-dos considered as tasks by {@link UiToDo#isTask()}
     * to be displayed on the UI.
     * The ordering of the list is to be respected.
     *
     * @return an observable read-only list of {@link UiToDo} that are tasks
     */
    UnmodifiableObservableList<UiToDo> getUiTasks();

    /**
     * Gets the full list of to-dos, read-only.
     *
     * @return the full list of to-dos, read-only
     */
    ReadOnlyToDoList getToDoList();
}
```
###### \java\seedu\commando\logic\LogicManager.java
``` java

/**
 * Concrete implementation of {@link Logic} for the Logic component.
 * Executes commands from the UI, using the API provided by Model and Storage.
 */
public class LogicManager extends ComponentManager implements Logic {
    private final Logger logger = LogsCenter.getLogger(LogicManager.class);

    private final Model model;
    private final Storage storage;
    private final UserPrefs userPrefs;
    private final CommandFactory commandFactory = new CommandFactory();

    public LogicManager(Model model, Storage storage, UserPrefs userPrefs) {
        this.model = model;
        this.storage = storage;
        this.userPrefs = userPrefs;

        saveToDoListToStorage(model.getToDoList());
    }

    @Override
    public CommandResult execute(String commandText) {
        logger.info("User command: " + commandText + "");

        try {
            return executeCommand(commandText);
        } catch (CommandFactory.InvalidCommandFormatException e) {
            return getCommandResultForInvalidFormat(e);
        } catch (CommandFactory.UnknownCommandWordException e) {
            return new CommandResult(String.format(Messages.UNKNOWN_COMMAND, e.commandWord), true);
        } catch (CommandFactory.MissingCommandWordException e) {
            return new CommandResult(Messages.MISSING_COMMAND_WORD, true);
        }
    }

    @Override
    public UnmodifiableObservableList<UiToDo> getUiEvents() {
        return model.getUiEvents();
    }

    @Override
    public UnmodifiableObservableList<UiToDo> getUiTasks() {
        return model.getUiTasks();
    }

    @Override
    public ReadOnlyToDoList getToDoList() {
        return model.getToDoList();
    }

    /**
     * Saves the to-do list to the file system with Storage.
     * Raises {@link DataSavingExceptionEvent} if there was an error during saving.
     *
     * @param toDoList to-do list to save
     */
    public void saveToDoListToStorage(ReadOnlyToDoList toDoList) {
        try {
            storage.saveToDoList(toDoList);
        } catch (IOException e) {
            raise(new DataSavingExceptionEvent(e));
        }
    }

    /**
     * Called upon an event that the Model's to-do list has changed.
     *
     * In a separate thread, it saves the current version of the to-do list to the hard disk
     * at the default to-do list filepath with Storage.
     */
    @Subscribe
    public void handleToDoListChangedEvent(ToDoListChangedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event, "Local data changed, saving to file"));

        // Try to run on JavaFX UI thread to prevent lag. If not, just run on current thread.
        try {
            Platform.runLater(() -> saveToDoListToStorage(event.toDoList));
        } catch (IllegalStateException e) {
           saveToDoListToStorage(event.toDoList);
        }
    }

    /**
     * Called upon an event that the to-do list file path change has been requested.
     *
     * It changes to-do list file path in user prefs and storage.
     * Then, in a separate thread, it saves the to-do data to that new file path with Storage.
     */
    @Subscribe
    public void handleToDoListFilePathRequestEvent(ToDoListFilePathChangeRequestEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));

        storage.setToDoListFilePath(event.path);
        userPrefs.setToDoListFilePath(event.path);

        // Try to run on JavaFX UI thread to prevent lag. If not, just run on current thread.
        try {
            Platform.runLater(() -> saveToDoListToStorage(model.getToDoList()));
        } catch (IllegalStateException e) {
            saveToDoListToStorage(model.getToDoList());
        }
    }

    private CommandResult getCommandResultForInvalidFormat(CommandFactory.InvalidCommandFormatException e) {
        // If invalid command format, check if Messages has sample commands for that command
        // Append to exception message if there is
        Optional<String> commandFormatMessage = Messages.getCommandFormatMessage(e.command);
        if (commandFormatMessage.isPresent()) {
            return new CommandResult(e.getMessage() + "\n" + commandFormatMessage.get(), true);
        } else {
            return new CommandResult(e.getMessage(), true);
        }
    }

    private CommandResult executeCommand(String commandText)
        throws CommandFactory.InvalidCommandFormatException,
        CommandFactory.UnknownCommandWordException,
        CommandFactory.MissingCommandWordException {

        Command command = commandFactory.build(commandText);

        command.setEventsCenter(eventsCenter);
        command.setModel(model);

        try {
            return command.execute();
        } catch (Command.NoEventsCenterException | Command.NoModelException exception) {
            assert false : "there should always be EventsCenter or Model";
            return new CommandResult(exception.getMessage(), true);
        }
    }
}
```
###### \java\seedu\commando\logic\parser\CommandParser.java
``` java

/**
 * In charge of parsing an input command string, piece-wise, with the help of
 * {@link DateTimeParser}.
 * <p>
 * Methods modify the input string by extracting appropriate parts of it,
 * and input is always kept trimmed.
 */
public class CommandParser {
    public static final String KEYWORD_DATERANGE_START = "from";
    public static final String KEYWORD_DATERANGE_END = "to";
    public static final String KEYWORD_DATERANGE_DATE = "on";
    public static final String KEYWORD_DUEDATE = "by";
    public static final String RECURRENCE_REGEX = "daily|weekly|monthly|yearly";
    public static final String TAG_PREFIX = "#";
    public static final String QUOTE_CHARACTER = "`";
    public static final String KEYWORD_OVERRIDE = "override";

    // Pattern for "from ... to ... (recurrence)?"
    private static final Pattern DATERANGE_TWO_SIDED_PATTERN = Pattern.compile(
        "(?<left>.*)"
            + "((^|\\s)" + KEYWORD_DATERANGE_START + "\\s+" + "(?<start>(.+\\s+)?)" + KEYWORD_DATERANGE_END + "(?<end>(\\s+.+?)?))"
            + "(?<recurrence>(\\s+" + RECURRENCE_REGEX + ")?)$",
        Pattern.CASE_INSENSITIVE
    );

    // Pattern for "on ... (recurrence)?"
    private static final Pattern DATERANGE_SINGLE_DATE_PATTERN = Pattern.compile(
        "(?<left>.*)"
            + "((^|\\s)" + KEYWORD_DATERANGE_DATE + "\\s+(?<date>(.+?)?))"
            + "(?<recurrence>(\\s+" + RECURRENCE_REGEX + ")?)$",
        Pattern.CASE_INSENSITIVE
    );

    // Pattern for "from ... (recurrence)?"
    private static final Pattern DATERANGE_START_DATE_PATTERN = Pattern.compile(
        "(?<left>.*)((^|\\s)" + KEYWORD_DATERANGE_START + "\\s+(?<start>(.+?)))"
            + "(?<recurrence>(\\s+" + RECURRENCE_REGEX + ")?)$",
        Pattern.CASE_INSENSITIVE
    );

    // Pattern for "to ... (recurrence)?"
    private static final Pattern DATERANGE_END_DATE_PATTERN = Pattern.compile(
        "(?<left>.*)((^|\\s)" + KEYWORD_DATERANGE_END + "\\s+(?<end>(.+?)))"
            + "(?<recurrence>(\\s+" + RECURRENCE_REGEX + ")?)$",
        Pattern.CASE_INSENSITIVE
    );
    
    // Pattern for "path (override)?"
    private static final Pattern OVERRIDE_PATTERN = Pattern.compile(
        "^(?<path>.*)\\s("+ KEYWORD_OVERRIDE + ")$",
        Pattern.CASE_INSENSITIVE
    );

    private static final Pattern DUEDATE_PATTERN = Pattern.compile(
        "(?<left>.*)(^|\\s)" + KEYWORD_DUEDATE + "\\s+" + "(?<date>.+?)"
            + "(?<recurrence>(\\s+" + RECURRENCE_REGEX + ")?)$",
        Pattern.CASE_INSENSITIVE
    );

    private static final Pattern FIRST_WORD_PATTERN = Pattern.compile("^(?<word>\\S+)(?<left>.*?)$");
    private static final Pattern FIRST_QUOTED_TEXT_PATTERN = Pattern.compile("^" + QUOTE_CHARACTER + "(?<text>.*)" + QUOTE_CHARACTER + "(?<left>.*?)$");
    private static final Pattern FIRST_INTEGER_PATTERN = Pattern.compile("^(?<integer>-?\\d+)(?<left>.*?)$");

    private static final Pattern TAGS_PATTERN = Pattern.compile(
        "(?<left>.*?)(?<tags>((\\s+|^)" + TAG_PREFIX + "\\S*)+)$",
        Pattern.CASE_INSENSITIVE
    );
    private static final Pattern INDEXRANGE_PATTERN = Pattern.compile(
        "^(?<firstInt>-?\\d+)" + "\\s*" + "((to)|-)" + "\\s*" + "(?<secondInt>-?\\d+)(?<left>.*?)$",
        Pattern.CASE_INSENSITIVE
    );

    private String input;
    private DateTimeParser dateTimeParser = new DateTimeParser();

    /**
     * Set the current input the parser is working on, and resets
     * any contextual info from the last input.
     *
     * @param input input to set
     */
    public void setInput(String input) {
        this.input = input;
        dateTimeParser.resetContext();
    }

    /**
     * Gets current input the parser is working on.
     *
     * @return current input
     */
    public String getInput() {
        return input.trim();
    }

    /**
     * Checks whether current input trimmed is an empty string.
     *
     * @return return whether the input is empty
     */
    public boolean isInputEmpty() {
        return input.trim().isEmpty();
    }

    /**
     * Extract a trailing due date from the input.
     * <p>
     * Date range is defined by: "by (valid_datetime)" + optional " (valid_recurrence)",
     * and must be at the end of the string to be considered.
     *
     * @return optional of a due date if found, empty otherwise
     */
    public Optional<DueDate> extractTrailingDueDate() {
        final Matcher matcher = DUEDATE_PATTERN.matcher(input);

        if (matcher.find()) {
            String dateString = matcher.group("date");
            String recurrenceString = matcher.group("recurrence");

            // Parse datetime and recurrence
            Optional<DueDate> dueDate = parseDueDate(dateString, recurrenceString);

            // If legit date, extract from input and return due date
            if (dueDate.isPresent()) {
                input = matcher.group("left").trim();
                return dueDate;
            }
        }

        // Didn't find any matches
        return Optional.empty();
    }

    /**
     * Extract a trailing date range from the input of the form:
     * - "from (valid_datetime) to (valid_datetime)" + an optional "(valid_recurrence)"
     * and must be at the end of the string to be considered.
     *
     * @return optional of date range, empty if not found
     * @throws IllegalValueException if a trailing date range pattern is found but either one of the datetime is valid,
     *                               other invalid, or parsed DateRange is not invalid
     */
    public Optional<DateRange> extractTrailingTwoSidedDateRange() throws IllegalValueException {
        final Matcher matcher = DATERANGE_TWO_SIDED_PATTERN.matcher(input);

        // Find "from ... to ..."
        if (matcher.find()) {
            String recurrenceString = matcher.group("recurrence");
            String startString = matcher.group("start");
            String endString = matcher.group("end");

            Optional<DateRange> dateRange = parseDateRangeWithStartAndEnd(startString, endString, recurrenceString);

            // If legit date range, extract from input and return it
            if (dateRange.isPresent()) {
                input = matcher.group("left").trim();
                return dateRange;
            }
        }

        return Optional.empty();
    }

    /**
     * Extract a trailing date range from the input of the form:
     * - "on (valid_datetime)" + an optional "(valid_recurrence)"
     * and must be at the end of the string to be considered.
     *
     * @return optional of date range, empty if not found
     */
    public Optional<DateRange> extractTrailingSingleDateDateRange() {
        final Matcher matcher = DATERANGE_SINGLE_DATE_PATTERN.matcher(input);

        // Find "on ..."
        if (matcher.find()) {
            String recurrenceString = matcher.group("recurrence");
            String dateString = matcher.group("date");

            Optional<DateRange> dateRange = parseDateRangeWithSingleDate(dateString, recurrenceString);

            // If legit date range, extract from input and return it
            if (dateRange.isPresent()) {
                input = matcher.group("left").trim();
                return dateRange;
            }
        }

        return Optional.empty();
    }

    /**
     * Extract a trailing date range from the input of the form:
     * - "to (valid_datetime)" + an optional "(valid_recurrence)"
     * and must be at the end of the string to be considered.
     *
     * @return optional of date range, empty if not found
     */
    public Optional<DateRange> extractTrailingEndDateDateRange() {
        final Matcher matcher = DATERANGE_END_DATE_PATTERN.matcher(input);

        // Find "to ..."
        if (matcher.find()) {
            String recurrenceString = matcher.group("recurrence");
            String dateString = matcher.group("end");

            Optional<DateRange> dateRange = parseDateRangeWithEnd(dateString, recurrenceString);

            // If legit date range, extract from input and return it
            if (dateRange.isPresent()) {
                input = matcher.group("left").trim();
                return dateRange;
            }
        }

        return Optional.empty();
    }

    /**
     * Extract a trailing date range from the input of the form:
     * - "from (valid_datetime)" + an optional "(valid_recurrence)"
     * and must be at the end of the string to be considered.
     *
     * @return optional of date range, empty if not found
     */
    public Optional<DateRange> extractTrailingStartDateDateRange() {
        final Matcher matcher = DATERANGE_START_DATE_PATTERN.matcher(input);

        // Find "from ..."
        if (matcher.find()) {
            String recurrenceString = matcher.group("recurrence");
            String dateString = matcher.group("start");

            Optional<DateRange> dateRange = parseDateRangeWithStart(dateString, recurrenceString);

            // If legit date range, extract from input and return it
            if (dateRange.isPresent()) {
                input = matcher.group("left").trim();
                return dateRange;
            }
        }

        return Optional.empty();
    }

    /**
     * Extracts all text in input. Input of parser will be empty after this call.
     *
     * @return text extracted
     */
    public Optional<String> extractText() {
        String text = input.trim();
        input = "";

        return text.isEmpty() ? Optional.empty() : Optional.of(text);
    }


    /**
     * From start, extracts a quoted title in input, if found.
     * e.g. "`quoted` text" returns "quoted" and retains input "text".
     *
     * @return quoted text with quotes removed and trimmed if found,
     * empty if no quotes found
     * @throws IllegalValueException if quoted title found is empty
     */
    public Optional<String> extractQuotedTitle() throws IllegalValueException {
        final Matcher matcher = FIRST_QUOTED_TEXT_PATTERN.matcher(input);

        if (matcher.find()) {
            String text = matcher.group("text").trim();

            if (text.isEmpty()) {
                throw new IllegalValueException(Messages.MISSING_TODO_TITLE);
            }

            input = matcher.group("left").trim();
            return Optional.of(text);
        }

        return Optional.empty();
    }

    /**
     * From start, extracts all trailing tags from the current input.
     * Extraction ends when the next word is not a tag.
     * Tags which are empty strings are removed.
     *
     * @return a set of tags, with the tag prefix removed
     */
    public Set<Tag> extractTrailingTags() {
        final Matcher matcher = TAGS_PATTERN.matcher(input);

        if (matcher.find()) {
            input = matcher.group("left").trim();

            // Split to words to get tags
            // trim any leading spaces and filter out empty tags
            return Arrays.stream(matcher.group("tags").trim()
                .split("\\s+"))
                .map(word -> {
                    word = word.trim();

                    // pattern should have ensured this
                    assert word.indexOf(TAG_PREFIX) == 0;

                    return new Tag(word.substring(TAG_PREFIX.length()).trim());

                }).filter(x -> !x.value.isEmpty())
                .collect(Collectors.toSet());
        }

        return Collections.emptySet();
    }

    /**
     * From start, extracts a single word in input, if found.
     *
     * @return optional of word extracted from input, empty if not found
     */
    public Optional<String> extractWord() {
        final Matcher matcher = FIRST_WORD_PATTERN.matcher(input.trim());
        if (matcher.find()) {
            // Remove extracted first word
            input = matcher.group("left").trim();
            return Optional.of(matcher.group("word"));
        }

        return Optional.empty();
    }

    /**
     * Extracts all words in input (space-separated).
     *
     * @return list of words found, an empty list if input is empty
     */
    public List<String> extractWords() {
        return Arrays.stream(extractText().orElse("").split("\\s+"))
            .filter(x -> !x.trim().isEmpty())
            .collect(Collectors.toList());
    }

    /**
     * From start, extracts an integer in input, if found.
     *
     * @return optional of found integer extracted from input, empty if not found
     */
    public Optional<Integer> extractInteger() {
        final Matcher matcher = FIRST_INTEGER_PATTERN.matcher(input.trim());

        if (matcher.find()) {
            // Remove extracted first integer
            String integerString = matcher.group("integer");
            input = matcher.group("left").trim();

            try {
                return Optional.of(Integer.parseInt(integerString));
            } catch (NumberFormatException exception) {
                assert false : "Shouldn't be able to fail parsing of integer based on pattern";
            }

        }

        return Optional.empty();
    }
```
###### \java\seedu\commando\logic\parser\CommandParser.java
``` java

    /**
     * Parses a recurrence string to a {@link Recurrence}
     * Asserts {@param recurrence} matches {@link #RECURRENCE_REGEX} or an empty string
     *
     * @return recurrence if valid, null if invalid, Recurrence.None if empty string
     */
    private Recurrence parseRecurrence(String recurrence) {
        switch (recurrence.trim()) {
            case "daily":
                return Recurrence.Daily;
            case "weekly":
                return Recurrence.Weekly;
            case "monthly":
                return Recurrence.Monthly;
            case "yearly":
                return Recurrence.Yearly;
            case "":
                return Recurrence.None;
            default:
                assert false;
        }

        return Recurrence.None;
    }

    private void throwIfEmptyString(String value, String message)
        throws IllegalValueException {
        if (value.trim().isEmpty()) {
            throw new IllegalValueException(message);
        }
    }

    private Optional<DateRange> parseDateRangeWithStartAndEnd(String startDateString, String endDateString, String recurrenceString)
        throws IllegalValueException {

        // Check both "from" and "to" fields are not empty
        throwIfEmptyString(startDateString, Messages.MISSING_TODO_DATERANGE_START + "\n" + Messages.DATE_FORMAT);
        throwIfEmptyString(endDateString, Messages.MISSING_TODO_DATERANGE_END + "\n" + Messages.DATE_FORMAT);

        // Parse start datetime with default time of midnight, end datetime with default time of 2359h
        Optional<LocalDateTime> startDateTime = dateTimeParser.parseDateTime(startDateString, LocalTime.MIDNIGHT);
        Optional<LocalDateTime> endDateTime = dateTimeParser.parseDateTime(endDateString, LocalTime.of(23, 59));

        if (!startDateTime.isPresent() && !endDateTime.isPresent()) {
            // Both start and end dates invalid, maybe its not a date range
            return Optional.empty();
        } else if (startDateTime.isPresent() && !endDateTime.isPresent()) {
            throw new IllegalValueException(Messages.INVALID_TODO_DATERANGE_END + "\n" + Messages.DATE_FORMAT);
        } else if (endDateTime.isPresent() && !startDateTime.isPresent()) {
            throw new IllegalValueException(Messages.INVALID_TODO_DATERANGE_START + "\n" + Messages.DATE_FORMAT);
        } else {
            assert startDateTime.isPresent() && endDateTime.isPresent();

            Recurrence recurrence = parseRecurrence(recurrenceString);
            return Optional.of(new DateRange(startDateTime.get(), endDateTime.get(), recurrence));
        }
    }

    private Optional<DateRange> parseDateRangeWithEnd(String endDateString, String recurrenceString) {
        if (endDateString.isEmpty()) {
            return Optional.empty();
        }

        Optional<LocalDateTime> endDateTime
            = dateTimeParser.parseEndDateTime(endDateString);

        // Invalid datetime
        if (!endDateTime.isPresent()) {
            return Optional.empty();
        }

        Recurrence recurrence = parseRecurrence(recurrenceString);

        try {
            // Return from now to the date end
            DateRange dateRange = new DateRange(LocalDateTime.now(), endDateTime.get(), recurrence);
            return Optional.of(dateRange);
        } catch (IllegalValueException e) {
            // Date range was invalid - should not treat it as date range then
            return Optional.empty();
        }
    }

    private Optional<DateRange> parseDateRangeWithStart(String startDateString, String recurrenceString) {
        if (startDateString.isEmpty()) {
            return Optional.empty();
        }

        Optional<LocalDateTime> date = dateTimeParser.parseDateTime(startDateString);

        // Invalid datetime
        if (!date.isPresent()) {
            return Optional.empty();
        }

        Recurrence recurrence = parseRecurrence(recurrenceString);

        try {
            // Return from date start onwards
            DateRange dateRange = new DateRange(date.get(), LocalDateTime.MAX, recurrence);
            return Optional.of(dateRange);
        } catch (IllegalValueException e) {
            // Date range was invalid - should not treat it as date range then
            return Optional.empty();
        }
    }

    private Optional<DateRange> parseDateRangeWithSingleDate(String dateString, String recurrenceString) {
        if (dateString.isEmpty()) {
            return Optional.empty();
        }

        Optional<Pair<LocalDateTime, LocalDateTime>> period
            = dateTimeParser.parseDateTimePeriod(dateString);

        // Invalid datetime
        if (!period.isPresent()) {
            return Optional.empty();
        }

        Recurrence recurrence = parseRecurrence(recurrenceString);

        try {
            DateRange dateRange = new DateRange(period.get().getKey(), period.get().getValue(), recurrence);
            return Optional.of(dateRange);
        } catch (IllegalValueException e) {
            // Date range was invalid - should not treat it as date range then
            return Optional.empty();
        }
    }

    private Optional<DueDate> parseDueDate(String dateString, String recurrenceString) {
        // Parse datetime and recurrence
        Optional<LocalDateTime> datetime
            = dateTimeParser.parseEndDateTime(dateString);
        Recurrence recurrence = parseRecurrence(recurrenceString);

        if (datetime.isPresent()) {
            return Optional.of(new DueDate(datetime.get(), recurrence));
        } else {
            return Optional.empty();
        }
    }
}
```
###### \java\seedu\commando\logic\parser\DateTimeParser.java
``` java

/**
 * Parses datetimes with help of {@link com.joestelmach.natty.Parser}
 */
public class DateTimeParser {
    public static final LocalTime MorningLocalTime = LocalTime.of(8, 0);
    public static final LocalTime AfternoonLocalTime = LocalTime.of(12, 0);
    public static final LocalTime EveningLocalTime = LocalTime.of(19, 0);
    public static final LocalTime NightLocalTime = LocalTime.of(21, 0);

    private static final String MonthWordRegexString = "January|Feburary|March|April|June|July|August|September|October|November|December|" +
        "Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Sept|Oct|Nov|Dec";
    private static final String DayWordRegexString = "Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday|Mon|Tue|Tues|Wed|Thu|Thur|Thurs|Fri|Sat|Sun";
    private static final String FullYearRegexString = "\\d{4}";
    private static final String TwoDigitYearRegexString = "\\d{2}";
    private static final String MonthRegexString = "(0?[1-9])|10|11|12";
    private static final String DayOfMonthRegexString = "([12]\\d)|([3][01])|(0?[1-9])";
    private static final String Hours24RegexString = "(1\\d)|20|21|22|23|(0?\\d)";
    private static final String Hours12RegexString = "10|11|12|(0?[1-9])";
    private static final String MinutesRegexString = "([1234]\\d)|(5[0-9])|(0\\d)";

    private static final String YearRegexString = "(?<year>(" + FullYearRegexString + ")|(" + TwoDigitYearRegexString + "))";

    private static final String DateWithSlashesRegexString = "(?<day>" + DayOfMonthRegexString + ")\\/(?<month>" + MonthRegexString + ")(\\/" + YearRegexString + ")?";
    private static final String DateWithMonthWordAndDayRegexString = "((" + DayOfMonthRegexString + ")(th|rd|st|nd)?)\\s+" +
        "(" + MonthWordRegexString + ")(\\s+" + YearRegexString + ")?";
    private static final String DateWithMonthWordReversedRegexString = "(" + MonthWordRegexString + ")\\s+" +
        "(" + DayOfMonthRegexString + ")(th|rd|st|nd)?(\\s+" + YearRegexString + ")?";
    private static final String DateWithDayWordRegexString = "((this|last|coming|next)\\s+)?(" + DayWordRegexString + ")";
    private static final String DateWithMonthWordAndYearRegexString = "(" + MonthWordRegexString + ")\\s+(" + FullYearRegexString + ")";
    private static final String DateWithMonthWordRegexString = "((this|last|coming||next)\\s+)?(" + MonthWordRegexString + ")";
    private static final String DateWithLaterAgoRegexString = "((\\d+\\d)|([2-9]))\\s+(days|weeks|months|years)\\s+(later|ago)";
    private static final String DateWithLastNextRegexString = "(this|last|this|next)\\s+(week|month|year)";
    private static final String DatePresetsRegexString = "today|tomorrow|tmr|yesterday";

    private static final String Time24HourRegexString = "(" + Hours24RegexString + ")(\\.|:)(" + MinutesRegexString + ")";
    private static final String Time12HourRegexString = "(" + Hours12RegexString + ")(\\.|:)?(" + MinutesRegexString + ")?(am|pm)";
    private static final String TimePresetsNightRegexString = "(this\\s+)?(night|tonight)";
    private static final String TimePresetsRegexString = "(this\\s+)?(morning|afternoon|noon|evening|midnight)";
    private static final String TimeHourNotationRegexString = "(?<hours>" + Hours24RegexString + ")(?<minutes>" + MinutesRegexString + ")h";

    private static final String[] supportedDateRegexStrings = new String[]{
        DateWithSlashesRegexString,
        DateWithMonthWordAndDayRegexString,
        DateWithMonthWordReversedRegexString,
        DateWithMonthWordAndYearRegexString,
        DateWithDayWordRegexString,
        DateWithMonthWordRegexString,
        DateWithLaterAgoRegexString,
        DateWithLastNextRegexString,
        DatePresetsRegexString
    };

    private static final String[] supportedTimeRegexStrings = new String[]{
        Time24HourRegexString,
        TimeHourNotationRegexString,
        Time12HourRegexString,
        TimePresetsRegexString,
        TimePresetsNightRegexString
    };

    private static final String InitializationDateString = "today";

    private Parser parser = new Parser();
    private LocalDate lastLocalDate; // Date of last parsed datetime

    public DateTimeParser() {
        parseDateTime(InitializationDateString, LocalTime.MIDNIGHT);
    }

    /**
     * Resets any contextual info used based on history of parsing.
     */
    public void resetContext() {
        lastLocalDate = null;
    }

    /**
     * Parses an input string as a datetime period.
     *
     * @param input input string to be parsed
     * @return optional of pair of (start datetime, end datetime), empty if invalid datetime
     * @see #parseDateTime(String, LocalTime)
     */
    public Optional<Pair<LocalDateTime, LocalDateTime>> parseDateTimePeriod(String input) {
        // Get the datetime the input string represents
        Optional<LocalDateTime> localDateTime = parseDateTime(input);

        // If input string doesn't represent a datetime, return empty
        if (!localDateTime.isPresent()) {
            return Optional.empty();
        }

        String trimmedInput = input.trim();

        // Check if the input is trying to represent a period of > 1 day
        if (ifInputMatchesWeekPeriod(trimmedInput)) {
            // Return from monday to sunday of that week 2359h
            return Optional.of(new Pair<>(
                getWeekStartDateTime(localDateTime.get()),
                getWeekEndDateTime(localDateTime.get())
            ));
        } else if (ifInputMatchesMonthPeriod(trimmedInput)) {
            // Return from 1st to last day of month 2359h
            return Optional.of(new Pair<>(
                getMonthStartDateTime(localDateTime.get()),
                getMonthEndDateTime(localDateTime.get())
            ));
        } else if (ifInputMatchesYearPeriod(trimmedInput)) {
            // Return from 1st to last day of year 2359h
            return Optional.of(new Pair<>(
                getYearStartDateTime(localDateTime.get()),
                getYearEndDateTime(localDateTime.get())
            ));
        }

        // Return a single day until 2359h
        return Optional.of(new Pair<>(
            localDateTime.get(),
            getDayEndDateTime(localDateTime.get())
        ));
    }

    /**
     * Parses an input string as an end datetime.
     *
     * @param input input string to be parsed
     * @return optional of datetime, empty if invalid datetime
     * @see #parseDateTime(String, LocalTime)
     */
    public Optional<LocalDateTime> parseEndDateTime(String input) {
        // Get the datetime the input string represents
        Optional<LocalDateTime> localDateTime = parseDateTime(input, LocalTime.of(23, 59));

        // If input string doesn't represent a datetime, return empty
        if (!localDateTime.isPresent()) {
            return Optional.empty();
        }

        String trimmedInput = input.trim();

        // Check if the input is trying to represent a period of > 1 day
        if (ifInputMatchesWeekPeriod(trimmedInput)) {
            // Return sunday of that week 2359h
            return Optional.of(getWeekEndDateTime(localDateTime.get()));
        } else if (ifInputMatchesMonthPeriod(trimmedInput)) {
            // Return from last day of month 2359h
            return Optional.of(getMonthEndDateTime(localDateTime.get()));
        } else if (ifInputMatchesYearPeriod(trimmedInput)) {
            // Return from 1st to last day of year 2359h
            return Optional.of(getYearEndDateTime(localDateTime.get()));
        }

        // Return that datetime
        return Optional.of(localDateTime.get());
    }

    /**
     * {@link #parseDateTime(String, LocalTime)}, but with a default time of midnight
     */
    public Optional<LocalDateTime> parseDateTime(String input) {
        return parseDateTime(input, LocalTime.MIDNIGHT);
    }

    /**
     * Parses an input string as a datetime.
     * <p>
     * Works like {@link com.joestelmach.natty.Parser#parse(String)}, but:
     * - First passed through a stricter filter that regulates what is a valid datetime format.
     * - Converted to LocalDateTime
     * - If time is deemed as "inferred" (in natty), time = {@param defaultTime}
     * - If date is "inferred" and there were previous parses, date is set as that of last parsed datetime
     * - Seconds and nano-seconds field is always set to 0 (ignored)
     *
     * @param input       input string to parse
     * @param defaultTime default time to set if time is not explicit in {@param input}
     * @return optional of datetime, empty if invalid datetime
     */
    public Optional<LocalDateTime> parseDateTime(String input, LocalTime defaultTime) {
        Optional<String> preprocessedInput = preprocessInput(input.trim());

        // If pre-processing fails, return empty
        if (!preprocessedInput.isPresent()) {
            return Optional.empty();
        }

        // Let natty parse pre-processed input
        List<DateGroup> dateGroups = parser.parse(preprocessedInput.get());

        // Returns empty if natty didn't manage to parse it
        if (dateGroups.isEmpty()) {
           return Optional.empty();
        }

        DateGroup dateGroup = dateGroups.get(0);
        List<Date> dates = dateGroup.getDates();
        if (dates.isEmpty()) {
            return Optional.empty();
        }

        // Returns the first datetime parsed by natty
        return Optional.of(toLocalDateTime(dateGroup, dates.get(0), defaultTime));
    }

    /**
     * Converts natty's output {@code DateGroup} and {@code Date} to a {@code LocalDateTime}.
     */
    private LocalDateTime toLocalDateTime(DateGroup dateGroup, Date date, LocalTime defaultTime) {
        Instant instant = Instant.ofEpochMilli(date.getTime());
        ZoneId zoneId = ZoneOffset.systemDefault();
        LocalDateTime localDateTime = LocalDateTime.ofInstant(instant, zoneId);

        localDateTime = handleInferredDate(dateGroup, localDateTime);
        localDateTime = handleInferredTime(dateGroup, defaultTime, localDateTime);
        localDateTime = resetSeconds(localDateTime);

        // Remember last date parsed
        lastLocalDate = localDateTime.toLocalDate();

        return localDateTime;
    }

    private LocalDateTime resetSeconds(LocalDateTime localDateTime) {
        // Reset seconds
        localDateTime = localDateTime.withSecond(0).withNano(0);
        return localDateTime;
    }

    private LocalDateTime handleInferredTime(DateGroup dateGroup, LocalTime defaultTime, LocalDateTime localDateTime) {
        // Check if time is inferred
        if (dateGroup.isTimeInferred()) {
            localDateTime = LocalDateTime.of(localDateTime.toLocalDate(), defaultTime);
        }
        return localDateTime;
    }

    private LocalDateTime handleInferredDate(DateGroup dateGroup, LocalDateTime localDateTime) {
        // Check if date is inferred
        if (dateGroup.isDateInferred() && lastLocalDate != null) {
            localDateTime = LocalDateTime.of(lastLocalDate, localDateTime.toLocalTime());
        }

        return localDateTime;
    }

    /**
     * Determines with regex whether {@param input} is a supported datetime.
     * Pre-processes it to before being parsed in natty
     *
     * @param input input string to pre-process, must be trimmed
     * @return optional of the datetime string after validation and pre-processing, empty if
     * deemed as a datetime format not supported by this class
     */
    private Optional<String> preprocessInput(String input) {
        if (input.isEmpty()) {
            return Optional.empty();
        }

        // Try to match a date
        Optional<Matcher> dateMatcher = findDateRegexMatch(input);

        String dateString = "";
        if (dateMatcher.isPresent()) {
            dateString = getDateFromMatcher(dateMatcher.get());

            // Extract out date string from text
            input = input.substring(dateMatcher.get().end()).trim();
        }

        // Try to match a time
        Optional<Matcher> timeMatcher = findTimeRegexMatch(input);

        String timeString = "";
        if (timeMatcher.isPresent()) {
            timeString = getTimeFromMatcher(timeMatcher.get());

            // Extract out date string from text
            input = input.substring(timeMatcher.get().end()).trim();
        }

        // If there is any characters left in text, invalid datetime
        if (!input.trim().isEmpty()) {
            return Optional.empty();
        } else {
            String dateTimeString = getCombinedDateTimeString(dateString, timeString);
            return Optional.of(dateTimeString);
        }
    }

    private String getCombinedDateTimeString(String dateString, String timeString) {
        String dateTimeString = dateString + " " + timeString;
        dateTimeString = handleDateTimeWithLaterAgo(dateString, timeString, dateTimeString);
        return dateTimeString;
    }

    private String getTimeFromMatcher(Matcher timeMatcher) {
        String timeString = timeMatcher.group().trim();
        timeString = handleTimeFormatHour(timeString, timeMatcher);
        timeString = handleTimeNight(timeString, timeMatcher);
        return timeString;
    }

    private String getDateFromMatcher(Matcher dateMatcher) {
        String dateString = dateMatcher.group().trim();
        dateString = handleDateWithSlashes(dateString, dateMatcher);
        dateString = handleDateTwoDigitYear(dateString, dateMatcher);
        dateString = handleDateWithMonthWord(dateString, dateMatcher);
        return dateString;
    }

    private String handleDateWithMonthWord(String dateString, Matcher dateMatcher) {
        // Special case: for DateWithMonthWordRegexString format,
        // If its just plain month, add an "coming"
        if (ifMatcherUsesRegex(dateMatcher, DateWithMonthWordRegexString)) {
            if (ifMatches(dateString.trim(), MonthWordRegexString)) {
                return "coming " + dateString;
            }
        }

        return dateString;
    }

    private String handleDateTimeWithLaterAgo(String dateString, String timeString, String dateTimeString) {
        // Special case: if DateWithLaterRegexString is used,
        // swap date and time (for parsing in natty)
        if (ifMatches(dateString, DateWithLaterAgoRegexString)) {
            return timeString + " " + dateString;
        } else {
            return dateTimeString;
        }
    }

    private String handleTimeNight(String timeString, Matcher matcher) {
        // Special case: for TimePresetsNightRegexString format,
        // Set time to 9pm
        if (ifMatcherUsesRegex(matcher, TimePresetsNightRegexString)) {
            return NightLocalTime.toString();
        } else {
            return timeString;
        }
    }

    private String handleTimeFormatHour(String timeString, Matcher matcher) {
        // Special case: for TimeHourNotationRegexString format,
        // Change to colon format (natty parses it wrongly when there is no year in the date)
        if (ifMatcherUsesRegex(matcher, TimeHourNotationRegexString)) {
            return matcher.group("hours") + ":" + matcher.group("minutes");
        } else {
            return timeString;
        }
    }

    private String handleDateTwoDigitYear(String dateString, Matcher matcher) {
        // Tweak for year: if it is a 2 digit year, change it to 4
        // Check if year string exists in datetime
        try {
            if (matcher.group("year") != null && matcher.group("year").length() == 2) {
                // Get string version of today's year
                String thisFullYear = String.valueOf(LocalDateTime.now().getYear());
                // If today's year is more than 2 digits, append the front (size - 2) digits
                if (thisFullYear.length() > 2) {
                    String fullYear = thisFullYear.substring(0, thisFullYear.length() - 2)
                        + matcher.group("year");
                    return dateString.replaceFirst(TwoDigitYearRegexString + "$", fullYear);
                }
            }
        } catch (IllegalArgumentException exception) {
            // no group with "year", it's okay
        }

        return dateString;
    }

    private String handleDateWithSlashes(String dateString, Matcher matcher) {
        // Special case: for DateWithSlashesRegexString format,
        // Swap month and day
        if (ifMatcherUsesRegex(matcher, DateWithSlashesRegexString)) {
            return matcher.group("month") + "/" + matcher.group("day")
                + (matcher.group("year") != null ? ("/" + matcher.group("year")) : "");
        } else {
            return dateString;
        }
    }


    private LocalDateTime getDayEndDateTime(LocalDateTime localDateTime) {
        return localDateTime.withHour(23).withMinute(59);
    }

    private LocalDateTime getYearStartDateTime(LocalDateTime localDateTime) {
        return localDateTime.withDayOfYear(1);
    }

    private LocalDateTime getYearEndDateTime(LocalDateTime localDateTime) {
        return localDateTime.plusYears(1).withDayOfYear(1).minusDays(1)
            .withHour(23).withMinute(59);
    }

    private LocalDateTime getMonthStartDateTime(LocalDateTime localDateTime) {
        return localDateTime.withDayOfMonth(1);
    }

    private LocalDateTime getMonthEndDateTime(LocalDateTime localDateTime) {
        return localDateTime.plusMonths(1).withDayOfMonth(1).minusDays(1)
            .withHour(23).withMinute(59);
    }

    private LocalDateTime getWeekStartDateTime(LocalDateTime localDateTime) {
        return localDateTime.with(DayOfWeek.MONDAY);
    }

    private LocalDateTime getWeekEndDateTime(LocalDateTime localDateTime) {
        return localDateTime.with(DayOfWeek.SUNDAY).withHour(23).withMinute(59);
    }

    private boolean ifInputMatchesWeekPeriod(String input) {
        return (ifMatches(input, DateWithLaterAgoRegexString)
            || ifMatches(input, DateWithLastNextRegexString))
            && input.toLowerCase().contains("week");
    }

    private boolean ifInputMatchesMonthPeriod(String input) {
        // last/next month or x months ago/later
        if ((ifMatches(input, DateWithLaterAgoRegexString)
            || ifMatches(input, DateWithLastNextRegexString))
            && input.toLowerCase().contains("month")) {
            return true;
        }

        // month word only or month word + year
        if (ifMatches(input, DateWithMonthWordRegexString)
            || ifMatches(input, DateWithMonthWordAndYearRegexString)) {
            return true;
        }

        return false;
    }

    private boolean ifInputMatchesYearPeriod(String input) {
        return (ifMatches(input, DateWithLaterAgoRegexString)
            || ifMatches(input, DateWithLastNextRegexString))
            && input.toLowerCase().contains("year");
    }



    private Optional<Matcher> findDateRegexMatch(String input) {
        for (String regexString : supportedDateRegexStrings) {
            Matcher matcher = preparePattern(prepareRegexString(regexString)).matcher(input);

            // If matched from the start
            if (matcher.find() && matcher.start() == 0) {
                return Optional.of(matcher);
            }
        }

        return Optional.empty();
    }

    private Optional<Matcher> findTimeRegexMatch(String input) {
        for (String regexString : supportedTimeRegexStrings) {
            Matcher matcher = preparePattern(prepareRegexString(regexString)).matcher(input);

            // If matched from the start
            if (matcher.find() && matcher.start() == 0) {
                return Optional.of(matcher);
            }
        }

        return Optional.empty();
    }

    private boolean ifMatches(String input, String regexString) {
        return preparePattern("^" + regexString + "$").matcher(input).find();
    }

    private Pattern preparePattern(String regexString) {
        return Pattern.compile(regexString, Pattern.CASE_INSENSITIVE);
    }

    private String prepareRegexString(String regexString) {
        // regex + (space or end of string)
        return regexString + "(\\s+|$)";
    }

    private boolean ifMatcherUsesRegex(Matcher matcher, String regexString) {
        return matcher.pattern().pattern().equals(prepareRegexString(regexString));
    }
}
```
###### \java\seedu\commando\model\Model.java
``` java

/**
 * The API of the Model component.
 */
public interface Model {
    /**
     * Gets the internal to-do list, read-only. Call {@link #changeToDoList(ToDoListChange)}
     * to modify the list.
     *
     * @return its to-do list, read-only
     */
    ReadOnlyToDoList getToDoList();

    /**
     * Applies a change to its to-do list.
     *
     * @throws IllegalValueException if the change was invalid
     */
    void changeToDoList(ToDoListChange change) throws IllegalValueException;

    /**
     * Undos the last successful change to its to-do list.
     *
     * @return true if there was a change that was undone
     */
    boolean undoToDoList();

    /**
     * Redos the last successful undo to its to-do list.
     *
     * @return true if there was an undo that was redone
     */
    boolean redoToDoList();

    /**
     * Returns observable read-only list of UI to-dos considered as events by {@link UiToDo#isEvent()}.
     * This changes with the filter on the UI to-dos and the to-do list of model.
     * The ordering of the list is to be respected.
     *
     * @return an observable read-only list of {@link UiToDo} that are events
     */
    UnmodifiableObservableList<UiToDo> getUiEvents();

    /**
     * Return observable read-only list of UI to-dos considered as tasks by {@link UiToDo#isTask()}.
     * This changes with the filter on the UI to-dos and the to-do list of model.
     * The ordering of the list is to be respected.
     *
     * @return an observable read-only list of {@link UiToDo} that are tasks
     */
    UnmodifiableObservableList<UiToDo> getUiTasks();

    /**
     * Returns the {@link UiToDo} in {@link #getUiEvents()} and {@link #getUiTasks()}
     * that have the {@link UiToDo#getIndex()} of {@param toDoIndex}, in constant time.
     *
     * @return the UI to-do with the given index, if exists
     */
    Optional<UiToDo> getUiToDoAtIndex(int index);

    /**
     * Clears any keywords, tags or daterange filters on the UI to-dos
     * and sets the filter mode.
     * Asserts parameters to be non-null.
     */
    void clearUiToDoListFilter(FILTER_MODE filterMode);

    /**
     * Sets a filter mode, keywords filter, and tags filter on the UI to-dos.
     * Asserts parameters to be non-null.
     * <p>
     * If {@param filterMode} ==
     * - ALL: all to-dos that match keywords and tags are shown.
     * - FINISHED: finished to-dos that match keywords and tags are shown
     * - UNFINISHED: unfinished to-dos or finished to-dos that are finished on the
     * the current day, that match keywords and tags, are shown.
     */
    void setUiToDoListFilter(Set<String> keywords, Set<Tag> tags, FILTER_MODE filterMode);

```
###### \java\seedu\commando\model\todo\ReadOnlyToDoList.java
``` java

/**
 * Unmodifiable view of a to-do list.
 */
public interface ReadOnlyToDoList {

    /**
     * Gets a read-only list of read-only to-dos it contains.
     *
     * @return an observable read-only list of read-only to-dos it contains
     */
    UnmodifiableObservableList<ReadOnlyToDo> getToDos();

    /**
     * Checks if the list contains a to-do that is considered as similar
     * as the given to-do.
     * See {@link ReadOnlyToDo#isSimilar(ReadOnlyToDo)}.
     *
     * @param toDo a to-do to check
     * @return whether {@param toDo} exists in the list
     */
    boolean contains(ReadOnlyToDo toDo);

    /**
     * Checks if the list is considered similar as the given to-do list,
     * which means both their to-dos must be considered similar.
     * See {@link ReadOnlyToDo#isSimilar(ReadOnlyToDo)}.
     *
     * @param toDoList a to-do list to check
     * @return whether this to-do list is considered similar to {@param toDoList}
     */
    boolean isSimilar(ReadOnlyToDoList toDoList);

    /**
     * Returns a complete textual representation of the to-do list as a string, displaying
     * all to-dos.
     *
     * @return a string that represents the to-do list
     */
    default String getText() {
        return "[" + getToDos().stream().map(ReadOnlyToDo::toString).collect(Collectors.joining(", ")) + "]";
    }
}
```
###### \java\seedu\commando\model\todo\Recurrence.java
``` java

/**
 * Represents a recurrence in a to-do.
 */
public enum Recurrence {
    Daily,
    Weekly,
    Monthly,
    Yearly,
    None;

    /**
     * Gets the next datetime for this recurrence, based on a starting datetime.
     *
     * @param date starting datetime for the recurrence
     * @return the next datetime based on this recurrence
     */
    public LocalDateTime getNextDate(LocalDateTime date) {
        switch (this) {
            case Daily:
                return date.plusDays(1);
            case Weekly:
                return date.plusWeeks(1);
            case Monthly:
                return date.plusMonths(1);
            case Yearly:
                return date.plusYears(1);
            case None:
                return date;
        }

        return date;
    }
}
```
###### \java\seedu\commando\model\todo\ToDo.java
``` java

    /**
     * Called when a to-do is to advance its date range to after {@param dateUntil}
     * based on its recurrence.
     * Will only have an effect if to-do has a date range with a recurrence.
     */
    private void advanceDateRange(LocalDateTime dateUntil) {
        if (dateRange == null
            || dateUntil.isBefore(dateRange.endDate)
            || dateRange.recurrence == Recurrence.None) {
            return;
        }

        // The initial if-else should cover this
        assert dateRange != null && dateRange.recurrence != Recurrence.None;

        // Keep moving date forward based on recurrence interval
        // until it is not before the current date
        LocalDateTime startDate = dateRange.startDate;
        LocalDateTime endDate = dateRange.endDate;
        while (!endDate.isAfter(dateUntil)) {
            startDate = dateRange.recurrence.getNextDate(startDate);
            endDate = dateRange.recurrence.getNextDate(endDate);
        }
        try {
            dateRange = new DateRange(startDate, endDate, dateRange.recurrence);
        } catch (IllegalValueException exception) {
            assert false : "new date range should be valid";
        }

        updateValue();
    }

    /**
     * Called when a to-do is to advance its due date to after {@param dateUntil}
     * based on its recurrence.
     * Will only have an effect if to-do has a due date with a recurrence.
     */
    private void advanceDueDate(LocalDateTime dateUntil) {
        if (dueDate == null
            || dateUntil.isBefore(dueDate.value)
            || dueDate.recurrence == Recurrence.None) {
            return;
        }

        // The initial if-else should cover this
        assert dueDate != null && dueDate.recurrence != Recurrence.None;

        // Keep moving date forward based on recurrence interval
        // until it is not before the current date
        LocalDateTime date = dueDate.value;
        while (!date.isAfter(dateUntil)) {
            date = dueDate.recurrence.getNextDate(date);
        }
        dueDate = new DueDate(date, dueDate.recurrence);

        updateValue();
    }
}
```
###### \java\seedu\commando\model\todo\ToDoListChange.java
``` java
/**
 * An immutable representation of a change in {@link ReadOnlyToDoList}
 */
public class ToDoListChange {
    private final ReadOnlyToDoList addedToDos;
    private final ReadOnlyToDoList deletedToDos;

    /**
     * Constructor for a to-do list change.
     *
     * @param addedToDos   list of to-dos to be added, which is deep copied
     * @param deletedToDos list of to-dos to be deleted, which is deep copied
     */
    public ToDoListChange(ReadOnlyToDoList addedToDos, ReadOnlyToDoList deletedToDos) {
        this.addedToDos = new ToDoList(addedToDos);
        this.deletedToDos = new ToDoList(deletedToDos);
    }

    /**
     * Gets a read-only list of read-only to-dos to be added in this change
     *
     * @return list of to-dos to add
     */
    public ReadOnlyToDoList getAddedToDos() {
        return addedToDos;
    }

    /**
     * Gets a read-only list of read-only to-dos to be deleted in this change
     *
     * @return list of to-dos to delete
     */
    public ReadOnlyToDoList getDeletedToDos() {
        return deletedToDos;
    }

    /**
     * Gets the reverse of the current change.
     *
     * @return reverse of this change
     */
    public ToDoListChange getReverseChange() {
        return new ToDoListChange(deletedToDos, addedToDos);
    }

    @Override
    public boolean equals(Object other) {
        // short circuit if same object
        // instanceof handles nulls
        return other == this
            || (other instanceof ToDoListChange
            && addedToDos.equals(((ToDoListChange) other).addedToDos)
            && deletedToDos.equals(((ToDoListChange) other).deletedToDos));
    }

    @Override
    public int hashCode() {
        return Objects.hash(addedToDos, deletedToDos);
    }

    @Override
    public String toString() {
        return "To add " + addedToDos + ",a to delete " + deletedToDos;
    }
}
```
###### \java\seedu\commando\model\ToDoListManager.java
``` java
/**
 * In charge of supporting the editing, undoing and redoing of the to-do list,
 *   hinging on the {@link ToDoListChange} class.
 */
public class ToDoListManager {
    private final ToDoList toDoList;

    // changes that can be undone
    private final ArrayList<ToDoListChange> toDoListChanges = new ArrayList<>();

    // changes that can be redone
    private final ArrayList<ToDoListChange> toDoListUndoChanges = new ArrayList<>();

    private ToDoListChange lastToDoListChange;

    /**
     * Initializes with the given to-do list, which is managed internally.
     * Asserts parameters are non-null.
     *
     * @param toDoList the internal to-do list will be a deep copy of this
     */
    public ToDoListManager(ReadOnlyToDoList toDoList) {
        assert toDoList != null;

        this.toDoList = new ToDoList(toDoList);
    }

    /**
     * @see Model#getToDoList()
     */
    public ReadOnlyToDoList getToDoList() {
        return toDoList;
    }

    /**
     * @see Model#changeToDoList(ToDoListChange)
     */
    public void changeToDoList(ToDoListChange change) throws IllegalValueException {
        applyToDoListChange(change);
        toDoListChanges.add(change);

        // Reset undo list upon a change
        toDoListUndoChanges.clear();
    }

    /**
     * @see Model#undoToDoList()
     */
    public boolean undoToDoList() {
        // Nothing else to undo if the list of changes is empty
        if (toDoListChanges.isEmpty()) {
            return false;
        }

        ToDoListChange change = toDoListChanges.get(toDoListChanges.size() - 1);

        try {
            applyToDoListChange(change.getReverseChange());
        } catch (IllegalValueException exception) {
            // undo should always work
            assert false;
            return false;
        }

        // move changes from change list to to undo change list
        toDoListUndoChanges.add(change);
        toDoListChanges.remove(toDoListChanges.size() - 1);

        return true;
    }

    /**
     * @see Model#redoToDoList()
     */
    public boolean redoToDoList() {
        // Check if there are any undos to redo
        if (toDoListUndoChanges.isEmpty()) {
            return false;
        }

        ToDoListChange change = toDoListUndoChanges.get(toDoListUndoChanges.size() - 1);

        try {
            applyToDoListChange(change);
        } catch (IllegalValueException exception) {
            // Redo should always work
            assert false;
            return false;
        }

        // move changes from undo change list to change list
        toDoListChanges.add(change);
        toDoListUndoChanges.remove(toDoListUndoChanges.size() - 1);

        return true;
    }

    /**
     * Tries to apply a change to the to-do list.
     * @throws IllegalValueException if there were duplicate to-dos added or
     *   there were non-existent to-dos deleted.
     */
    private void applyToDoListChange(ToDoListChange change) throws IllegalValueException {
        lastToDoListChange = change;

        toDoList.remove(change.getDeletedToDos());

        try {
            toDoList.add(change.getAddedToDos());
        } catch (IllegalValueException exception) {
            // there were duplicate to-dos
            // revert removal of to-dos
            toDoList.add(change.getDeletedToDos());
            lastToDoListChange = null;
            throw exception;
        }
    }

    /**
     * Gets the last successful change to the to-do list, considering undos and redos
     *
     * @return an optional of the last change, empty if there was none
     */
    public Optional<ToDoListChange> getLastToDoListChange() {
        return Optional.ofNullable(lastToDoListChange);
    }
}
```
###### \java\seedu\commando\model\ui\UiModel.java
``` java

/**
 * In charge of processing and filtering the list of to-dos for the UI.
 */
public class UiModel {
    private final ToDoListManager toDoListManager;
    private final ObservableList<UiToDo> events = FXCollections.observableArrayList();
    private final ObservableList<UiToDo> tasks = FXCollections.observableArrayList();
    private final UnmodifiableObservableList<UiToDo> protectedEvents = new UnmodifiableObservableList<>(events);
    private final UnmodifiableObservableList<UiToDo> protectedTasks = new UnmodifiableObservableList<>(tasks);
    private final ArrayList<UiToDo> toDoAtIndices = new ArrayList<>();
    private int runningIndex;

    // Parameters for filtering
    private Model.FILTER_MODE filterMode = Model.FILTER_MODE.ALL;

    /**
     * Predicate that filters to-dos based on filter mode.
     */
    private Predicate<ReadOnlyToDo> toDoFilterModePredicate = toDo -> {
        switch (filterMode) {
            case ALL:
                return true;
            case UNFINISHED:
                // if unfinished mode but to-do is finished before the current day
                return !toDo.isFinished()
                    || (toDo.isFinished() && toDo.getDateFinished().get().toLocalDate().isEqual(LocalDate.now()));
            case FINISHED:
                // if finished mode but to-do is unfinished
                return toDo.isFinished();
            default:
                assert false : "Should have covered all filter modes";
                return false;
        }
    };

    /**
     * Initializes with the given to-do list manager, setting its filter mode to UNFINISHED.
     *
     * @param toDoListManager the to-do list manager it tracks and grabs the list of to-dos from
     */
    public UiModel(ToDoListManager toDoListManager) {
        this.toDoListManager = toDoListManager;

        // Initialize the filter to show unfinished to-dos
        clearToDoListFilter(Model.FILTER_MODE.UNFINISHED);

        // Start tracking changes to-do list, and update UI to-dos when a change happens
        toDoListManager.getToDoList().getToDos().addListener(new ListChangeListener<ReadOnlyToDo>() {
            @Override
            public void onChanged(Change<? extends ReadOnlyToDo> change) {
                clearToDoListFilter(filterMode);
            }
        });
    }

    /**
     * @see Model#getUiToDoAtIndex(int)
     */
    public Optional<UiToDo> getToDoAtIndex(int index) {
        if (index - 1 < 0 || index - 1 >= toDoAtIndices.size()) {
            return Optional.empty();
        } else {
            return Optional.of(toDoAtIndices.get(index - 1));
        }
    }

    /**
     * @see Model#clearUiToDoListFilter(Model.FILTER_MODE)
     */
    public void clearToDoListFilter(Model.FILTER_MODE filterMode) {
        assert !CollectionUtil.isAnyNull(filterMode);
        setToDoListFilter(Collections.emptySet(), Collections.emptySet(), filterMode);
    }

    /**
     * @see Model#setUiToDoListFilter(Set, Set, Model.FILTER_MODE)
     */
    public void setToDoListFilter(Set<String> keywords, Set<Tag> tags, Model.FILTER_MODE filterMode) {
        assert !CollectionUtil.isAnyNull(keywords, tags, filterMode);

        this.filterMode = filterMode;

        updateEventsAndTasks(keywords, tags);
    }

```
###### \java\seedu\commando\model\ui\UiModel.java
``` java

    /**
     * @see Model#getUiEvents()
     */
    public UnmodifiableObservableList<UiToDo> getEvents() {
        return protectedEvents;
    }

    /**
     * @see Model#getUiTasks()
     */
    public UnmodifiableObservableList<UiToDo> getTasks() {
        return protectedTasks;
    }

    /**
     * Update the UI to-dos based on {@link #toDoListManager}'s to-do list and
     * the keywords and tags filter.
     */
    private void updateEventsAndTasks(Set<String> keywords, Set<Tag> tags) {
        // Sort and filter events and tasks for UI
        List<ReadOnlyToDo> events = filterAndSortEvents(toDoListManager.getToDoList().getToDos(), keywords, tags);
        List<ReadOnlyToDo> tasks = filterAndSortTasks(toDoListManager.getToDoList().getToDos(), keywords, tags);

        // Update its own lists of UI to-dos
        updateUiToDos(events, tasks);
    }

```
###### \java\seedu\commando\model\ui\UiModel.java
``` java

    /**
     * Populate its lists of UI to-dos based on supplied to-dos.
     */
    private void updateUiToDos(List<ReadOnlyToDo> events, List<ReadOnlyToDo> tasks) {
        toDoAtIndices.clear();
        runningIndex = 0;

        Optional<ToDoListChange> lastChange = toDoListManager.getLastToDoListChange();

        ReadOnlyToDoList newToDos = lastChange.isPresent()
            ? lastChange.get().getAddedToDos() : new ToDoList();

        // Map each event to a UI to-do and add an index to each
        // Also check if the events are new with respect to last change
        this.events.setAll(events.stream().map(
            toDo -> new UiToDo(toDo, ++runningIndex, newToDos.contains(toDo))
        ).collect(Collectors.toList()));
        toDoAtIndices.addAll(this.events);

        // Then do the same for tasks
        this.tasks.setAll(tasks.stream().map(
            toDo -> new UiToDo(toDo, ++runningIndex, newToDos.contains(toDo))
        ).collect(Collectors.toList()));
        toDoAtIndices.addAll(this.tasks);

        // running index should be incremented by no. of to-dos
        assert runningIndex == toDoAtIndices.size();
    }
```
###### \java\seedu\commando\model\ui\UiModel.java
``` java
    private List<ReadOnlyToDo> filterAndSortTasks(List<ReadOnlyToDo> toDos,
                                                  Set<String> keywords, Set<Tag> tags) {
        List<ReadOnlyToDo> tasks = toDos.stream()
            .filter(toDoFilterModePredicate)
            .filter(toDo -> ifMatchesKeywordsAndTags(toDo, keywords, tags))
            .filter(UiToDo::isTask)
            .collect(Collectors.toList());

        // For tasks, sort by created date first (latest first)
        tasks.sort((task1, task2) -> task2.getDateCreated().compareTo(task1.getDateCreated()));

        // Then, by whether they have due date and that date (latest first)
        tasks.sort((task1, task2) -> compareDueDates(task1, task2));

        // Then, by whether they are finished and finished date (latest first)
        tasks.sort((task1, task2) -> compareDateFinished(task2, task1));

        return tasks;
    }

    private List<ReadOnlyToDo> filterAndSortEvents(List<ReadOnlyToDo> toDos,
                                                   Set<String> keywords, Set<Tag> tags) {
        List<ReadOnlyToDo> events = toDos.stream()
            .filter(toDoFilterModePredicate)
            .filter(toDo -> ifMatchesKeywordsAndTags(toDo, keywords, tags))
            .filter(UiToDo::isEvent)
            .collect(Collectors.toList());

        // For events, sort by created date first (latest first)
        events.sort((event1, event2) -> event2.getDateCreated().compareTo(event1.getDateCreated()));

        // Then, by start dates (earlier first)
        events.sort((event1, event2) -> compareDateRangeStarts(event1, event2));

        // Then, by whether they are finished and finished date (latest first)
        events.sort((event1, event2) -> compareDateFinished(event2, event1));

        return events;
    }

    //================================================================================
    //  Utility methods for sorting and filtering
    //================================================================================

    private int compareDateFinished(ReadOnlyToDo toDo1, ReadOnlyToDo toDo2) {
        LocalDateTime date1 = toDo1.getDateFinished().orElse(LocalDateTime.MAX);
        LocalDateTime date2 = toDo2.getDateFinished().orElse(LocalDateTime.MAX);

        return date1.compareTo(date2);
    }

    private int compareDueDates(ReadOnlyToDo toDo1, ReadOnlyToDo toDo2) {
        LocalDateTime date1 = toDo1.getDueDate().isPresent() ?
            toDo1.getDueDate().get().value : LocalDateTime.MAX;
        LocalDateTime date2 = toDo2.getDueDate().isPresent() ?
            toDo2.getDueDate().get().value : LocalDateTime.MAX;

        return date1.compareTo(date2);
    }

    private int compareDateRangeStarts(ReadOnlyToDo toDo1, ReadOnlyToDo toDo2) {
        LocalDateTime date1 = toDo1.getDateRange().isPresent() ?
            toDo1.getDateRange().get().startDate : LocalDateTime.MAX;
        LocalDateTime date2 = toDo2.getDateRange().isPresent() ?
            toDo2.getDateRange().get().startDate : LocalDateTime.MAX;

        return date1.compareTo(date2);
    }

    private boolean checkForKeyword(ReadOnlyToDo toDo, String keyword) {
        return StringUtil.substringIgnoreCase(toDo.getTitle().value, keyword) ||
            toDo.getTags().stream().anyMatch(toDoTag -> StringUtil.substringIgnoreCase(toDoTag.value, keyword));
    }

    private boolean checkForTag(ReadOnlyToDo toDo, Tag tag) {
        return toDo.getTags().stream().anyMatch(toDoTag -> toDoTag.value.equalsIgnoreCase(tag.value));
    }

    /**
     * Returns whether a to-do matches a set of keywords and tags.
     */
    private boolean ifMatchesKeywordsAndTags(ReadOnlyToDo toDo, Set<String> keywords, Set<Tag> tags) {
        return (keywords.stream()
            .allMatch(keyword -> checkForKeyword(toDo, keyword)))
            && (tags.stream()
            .allMatch(tag -> checkForTag(toDo, tag)));
    }
}
```
###### \java\seedu\commando\model\ui\UiToDo.java
``` java

/**
 * Represents a to-do on the UI.
 */
public class UiToDo implements ReadOnlyToDo {

    private final ReadOnlyToDo toDo;
    private final int index;
    private final boolean isNew;

    public UiToDo(ReadOnlyToDo toDo, int index, boolean isNew) {
        this.toDo = toDo;
        this.isNew = isNew;
        this.index = index;
    }

    /**
     * Returns whether a to-do item is an event
     */
    public static boolean isEvent(ReadOnlyToDo todo) {
        return todo.getDateRange().isPresent();
    }

    /**
     * Returns whether a to-do item is a task
     */
    public static boolean isTask(ReadOnlyToDo todo) {
        return !todo.getDateRange().isPresent();
    }

    @Override
    public Title getTitle() {
        return toDo.getTitle();
    }

    @Override
    public Optional<DateRange> getDateRange() {
        return toDo.getDateRange();
    }

    @Override
    public Optional<DueDate> getDueDate() {
        return toDo.getDueDate();
    }

    @Override
    public Set<Tag> getTags() {
        return toDo.getTags();
    }

    @Override
    public boolean isFinished() {
        return toDo.isFinished();
    }

    @Override
    public Optional<LocalDateTime> getDateFinished() {
        return toDo.getDateFinished();
    }

    @Override
    public LocalDateTime getDateCreated() {
        return toDo.getDateCreated();
    }

    @Override
    public ObservableValue getObservableValue() {
        return toDo.getObservableValue();
    }

    /**
     * @return index of the to-do on the UI.
     */
    public int getIndex() {
        return index;
    }

    /**
     * @return whether the to-do is newly added or edited.
     */
    public boolean isNew() {
        return isNew;
    }

    public boolean isEvent() {
        return isEvent(this);
    }

    public boolean isTask() {
        return isTask(this);
    }

    @Override
    public boolean equals(Object other) {
        // short circuit if same object
        // instanceof handles nulls
        return other == this
            || (other instanceof UiToDo
            && this.isSameStateAs((UiToDo) other)
            && index == ((UiToDo) other).index
            && isNew == ((UiToDo) other).isNew);
    }

    @Override
    public int hashCode() {
        return Objects.hash(toDo, index, isNew);
    }

    @Override
    public String toString() {
        return toDo + " with index of " + index
            + (isNew ? "(new)" : "");
    }
}
```
###### \java\seedu\commando\model\UserPrefs.java
``` java

/**
 * Represents the user's preferences.
 */
public class UserPrefs {
    private GuiSettings guiSettings = new GuiSettings();
    private StringProperty toDoListFilePath = new SimpleStringProperty(Config.DefaultToDoListFilePath);

    public UserPrefs() {
    }

    public GuiSettings getGuiSettings() {
        return guiSettings;
    }

    /**
     * Gets its to-do list file path,
     *
     * @return an observable string value of its to-do list file path.
     */
    public ObservableValue<String> getToDoListFilePath() {
        return toDoListFilePath;
    }

    /**
     * Sets its to-do list file path and triggers change listeners of {@link #getToDoListFilePath()}
     */
    public void setToDoListFilePath(String filePath) {
        toDoListFilePath.setValue(filePath);
    }


    /**
     * Sets its GUI settings to that given.
     * Does a deep copy of {@param guiSettings}.
     */
    public void setGuiSettings(GuiSettings guiSettings) {
        this.guiSettings = new GuiSettings(guiSettings);
    }

    /**
     * @see #setGuiSettings(GuiSettings)
     */
    public void setGuiSettings(double width, double height, int x, int y, boolean isMaximized) {
        guiSettings = new GuiSettings(width, height, x, y, isMaximized);
    }

    @Override
    public boolean equals(Object other) {
        // short circuit if same object
        // instanceof handles nulls
        return other == this
            || (other instanceof UserPrefs
            && (guiSettings.equals(((UserPrefs) other).guiSettings)
            && toDoListFilePath.getValue().equals(((UserPrefs) other).toDoListFilePath.getValue())));
    }

    @Override
    public int hashCode() {
        return Objects.hash(guiSettings, toDoListFilePath);
    }

    @Override
    public String toString() {
        return String.join(",",
            "Gui Settings: " + guiSettings,
            "To-do List File Path: " + toDoListFilePath.getValue()
        );
    }

    /**
     * Gets a {@link JsonObject} that fully defines its current state.
     *
     * @return a json object that fully defines its state.
     */
    public JsonObject getJsonObject() {
        JsonObject jsonObject = new JsonObject();
        jsonObject.guiSettings = guiSettings;
        jsonObject.toDoListFilePath = toDoListFilePath.getValue();
        return jsonObject;
    }

    /**
     * Sets fields of user prefs to that of {@param jsonObject}.
     * If any of the fields are null, the default of user prefs are used.
     */
    public void setJsonObject(JsonObject jsonObject) {
        if (jsonObject.guiSettings != null) {
            guiSettings = jsonObject.guiSettings;
        }

        if (jsonObject.toDoListFilePath != null) {
            toDoListFilePath.setValue(jsonObject.toDoListFilePath);
        }
    }

    public static class JsonObject {
        public GuiSettings guiSettings;
        public String toDoListFilePath;
    }
}
```
###### \resources\userguide\stylesheets\custom.css
``` css

kbd.light {
    display: inline-block;
    vertical-align: middle;
    background-color: #fcfcfc;
    border: solid 1px #ccc;
    border-bottom-color: #bbb;
    border-radius: 3px;
    box-shadow: inset 0 -1px 0 #bbb;
}

.command-format {
    background: #440000;
    position: relative;
}

.datagrid.class table {
    width: auto;
}

    .datagrid.class table th {
        text-align: center;
    }

ul.use-case li {
    list-style: none;
}

span.comment {
    font-size: 14px;
    color: #644;
    padding: 0;
    margin: 0;
    display: block;
    margin-top: -10px;
}
```
