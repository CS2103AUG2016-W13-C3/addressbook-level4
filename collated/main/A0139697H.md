# A0139697H
###### \java\seedu\commando\commons\core\Messages.java
``` java
    public static final String UNKNOWN_COMMAND = "Unknown command: '%1$s'. Input 'help' for instructions on how to use this application.";
    public static final String UNKNOWN_COMMAND_FOR_HELP = "Unknown topic for help: '%1$s'.";
                                                          
    public static final String MISSING_COMMAND_WORD = "Missing command word.";
    public static final String INVALID_COMMAND_FORMAT = "Invalid format for '%1$s' command!";
    public static final String MISSING_TODO_TITLE = "Missing title for to-do.";
    
    public static final String MISSING_TODO_DATERANGE_START = "Missing start date for date range of to-do.";
    public static final String MISSING_TODO_DATERANGE_END = "Missing end date for date range of to-do.";
    public static final String INVALID_TODO_DATERANGE_START = "Invalid start date for date range of to-do.";
    public static final String INVALID_TODO_DATERANGE_END = "Invalid end date for date range of to-do.";
    public static final String TODO_DATERANGE_END_MUST_AFTER_START = "The end date of the date range must be after start date.";
    public static final String TODO_DATERANGE_RECURRENCE_INVALID = "The recurrence for the given date range is not valid.";
    public static final String TODO_ALREADY_EXISTS = "To-do already exists!";
    public static final String TODO_NOT_FOUND = "To-do not found: %1$s";
    public static final String TODO_ITEM_INDEX_INVALID = "Invalid to-do index: %1$d.";
    public static final String TODO_CANNOT_HAVE_DUEDATE_AND_DATERANGE = "To-do cannot have both due date and date range!";

    public static final String MISSING_TODO_ITEM_INDEX = "Missing to-do item index.";
    
    public static final String INDEXRANGE_CONSTRAINTS = "The end index must be equal or larger than the start index.";
    
    public static final String MISSING_STORE_PATH = "Missing the path to store.";
    public static final String MISSING_IMPORT_PATH = "Missing the path to import.";
    public static final String MISSING_EXPORT_PATH = "Missing the path to export.";
    public static final String MISSING_STORE_FILE = "Missing the file name to store.";
    public static final String MISSING_EXPORT_FILE = "Missing the file name to export.";
    public static final String MISSING_IMPORT_FILE = "Missing the file name to import.";

    public static final String EXIT_APPLICATION = "Exiting application...";
    public static final String TODO_LIST_CLEARED = "Boom. Cleared to-do list!";
    public static final String HELP_WINDOW_SHOWN = "Opened help window.";
    public static final String FINISH_COMMAND = "Task marked as done: %1$s.";
    public static final String FINISH_COMMAND_ALREADY_FINISHED = "Task already marked done: %1$s";
    public static final String FINISH_COMMAND_CANNOT_FINISH_EVENT = "To-do must be a task to be marked done: %1$s.";
    public static final String UNFINISHED_COMMAND = "Task marked as undone: %1$s.";
    public static final String UNFINISH_COMMAND_ALREADY_ONGOING = "Task already marked undone: %1$s.";
    public static final String UNFINISH_COMMAND_CANNOT_UNFINISH_EVENT = "To-do must be a task to be marked undone: %1$s.";
    public static final String UNDO_COMMAND = "Undid the last command.";
    public static final String UNDO_COMMAND_FAIL = "Nothing more to undo!";
    public static final String REDO_COMMAND = "Redid the last undo command.";
    public static final String REDO_COMMAND_FAIL = "Nothing more to redo!";
    public static final String STORE_COMMAND = "Changed the storage path to: %1$s.";
    public static final String STORE_COMMAND_FILE_EXIST = "Failed to store the storage file to %1$s: destination file exists";
    public static final String EXPORT_COMMAND = "Export the storage file to: %1$s.";
    public static final String EXPORT_COMMAND_FILE_EXIST = "Failed to export the storage file to %1$s: destination file exists";
    public static final String IMPORT_COMMAND = "Import the storage file from: %1$s.";
    public static final String IMPORT_COMMAND_FILE_NOT_EXIST = "Invalid import file: the file does not exist.";
    public static final String IMPORT_COMMAND_INVALID_DATA = "Invalid import file: the file is of an invalid format.";
    public static final String ADD_COMMAND = "To-do added: %1$s.";
    public static final String ADD_COMMAND_EVENT_OVER = "Warning: event added is already over!";
    public static final String EDIT_COMMAND = "To-do edited: %1$s.";
    public static final String EDIT_COMMAND_NO_EDITS = "But nothing happened.";
    public static final String EDIT_COMMAND_EVENT_OVER = "Warning: event edited is already over!";
    public static final String DELETE_COMMAND = "To-do deleted: %1$s.";
    public static final String DELETE_COMMAND_NO_TAGS = "To-do with index '%1$s' has no tags to delete!";
    public static final String DELETE_COMMAND_NO_TIME_CONSTRAINTS = "To-do with index '%1$s' has no time constraints to delete!";
    public static final String DELETE_COMMAND_NO_RECURRENCE = "To-do with index '%1$s' has no recurrence to delete!";
    public static final String FIND_COMMAND = "Found unfinished to-dos matching keywords %1$s and tags %2$s.";
    public static final String FIND_COMMAND_CLEAR = "Listed all unfinished to-dos.";
    public static final String LIST_COMMAND_CLEAR = "Listed all to-dos.";
    public static final String LIST_COMMAND = "Listed all to-dos in date range of %1$s";
    public static final String RECALL_COMMAND = "Found finished to-dos matching keywords %1$s and tags %2$s.";
    public static final String RECALL_COMMAND_CLEAR = "Listed all finished to-dos.";

```
###### \java\seedu\commando\logic\commands\AddCommand.java
``` java
public class AddCommand extends Command {

    public static final String COMMAND_WORD = "add";

    private final Title title;
    public DateRange dateRange;
    public DueDate dueDate;
    public Set<Tag> tags = Collections.emptySet();

    public AddCommand(Title title) {
        assert title != null;

        this.title = title;
    }

    @Override
    public CommandResult execute() throws NoModelException {
        Model model = getModel();

        // Create the to-do to add
        ToDo toDo = new ToDo(title);

        // Set fields if exist
        if (dueDate != null) {
            toDo.setDueDate(dueDate);
        }

        if (dateRange != null) {
            toDo.setDateRange(dateRange);
        }

        if (tags != null) {
            toDo.setTags(tags);
        }

        // Ensure to-do doesn't have both duedate and daterange
        if (toDo.getDateRange().isPresent() && toDo.getDueDate().isPresent()) {
            return new CommandResult(Messages.TODO_CANNOT_HAVE_DUEDATE_AND_DATERANGE, true);
        }

        try {
            model.changeToDoList(new ToDoListChange(
                new ToDoList().add(toDo),
                new ToDoList()
            ));
        } catch (IllegalValueException exception) {
            return new CommandResult(exception.getMessage(), true);
        }

        String feedback = String.format(Messages.ADD_COMMAND, toDo.getTitle().toString());

        // If event already over, warn user
        if (toDo.getDateRange().isPresent()
            && toDo.getDateRange().get().endDate.isBefore(LocalDateTime.now())) {
            feedback += "\n" + Messages.ADD_COMMAND_EVENT_OVER;
        }

        return new CommandResult(feedback);
    }
}
```
###### \java\seedu\commando\logic\commands\ClearCommand.java
``` java
/**
 * Clears the to-do list
 */
public class ClearCommand extends Command {

    public static final String COMMAND_WORD = "clear";

    public ClearCommand() {}

    @Override
    public CommandResult execute() throws NoModelException {
        Model model = getModel();

        try {
            // Delete all to-dos
            model.changeToDoList(new ToDoListChange(
                new ToDoList(),
                model.getToDoList()
            ));
        } catch (IllegalValueException exception) {
            return new CommandResult(exception.getMessage(), true);
        }

        return new CommandResult(Messages.TODO_LIST_CLEARED);
    }
}
```
###### \java\seedu\commando\logic\commands\Command.java
``` java
/**
 * Represents a command with hidden internal logic and the ability to be executed
 */
public abstract class Command {

    private EventsCenter eventsCenter;
    private Model model;

    /**
     * Sets the EventsCenter for the command
     * {@param eventsCenter} must be non-null
     */
    public void setEventsCenter(EventsCenter eventsCenter) {
        assert eventsCenter != null;

        this.eventsCenter = eventsCenter;
    }

    /**
     * Sets the Model for the command
     * {@param model} must be non-null
     */
    public void setModel(Model model) {
        assert model != null;

        this.model = model;
    }

    public static class NoEventsCenterException extends Exception {}

    public static class NoModelException extends Exception {}

    protected EventsCenter getEventsCenter() throws NoEventsCenterException {
        if (eventsCenter == null) {
            throw new NoEventsCenterException();
        }

        return eventsCenter;
    }

    protected Model getModel() throws NoModelException {
        if (model == null) {
            throw new NoModelException();
        }

        return model;
    }

    /**
     * Executes the command
     * @return result of the command
     */
    public abstract CommandResult execute() throws NoModelException, NoEventsCenterException;
}
```
###### \java\seedu\commando\logic\commands\CommandFactory.java
``` java

/**
 * Maps and builds commands from input strings, using {@link CommandParser}
 * In charge of splitting up input strings to required parts for commands
 */
public class CommandFactory {
    private static final String KEYWORD_DELETE_TIME = "time";
    private static final String KEYWORD_DELETE_TAG = "tag";
    private static final String KEYWORD_DELETE_RECURRENCE = "recurrence";

    private CommandParser commandParser = new CommandParser();

    public static class InvalidCommandFormatException extends Exception {
        public final String command;

        public InvalidCommandFormatException(String message, String command) {
            super(message);
            this.command = command;
        }
    }

    public static class UnknownCommandWordException extends Exception {
        public final String commandWord;

        UnknownCommandWordException(String commandWord) {
            this.commandWord = commandWord;
        }
    }

    public static class MissingCommandWordException extends Exception {
    }

    /**
     * Interprets an input string as a command, initializes it, and returns it
     *
     * @return instance of a command
     */
    public Command build(String inputString) throws InvalidCommandFormatException,
        UnknownCommandWordException, MissingCommandWordException {
        commandParser.setInput(inputString);

        // Check if command word exists
        Optional<String> commandWord = commandParser.extractWord();

        if (!commandWord.isPresent()) {
            throw new MissingCommandWordException();
        }

        String processedCommandWord = commandWord.get().toLowerCase();
        try {
            switch (processedCommandWord) {
                case AddCommand.COMMAND_WORD:
                    return buildAddCommand();
                case DeleteCommand.COMMAND_WORD:
                    return buildDeleteCommand();
                case FinishCommand.COMMAND_WORD:
                    return buildFinishCommand();
                case UnfinishCommand.COMMAND_WORD:
                    return buildUnfinishCommand();
                case FindCommand.COMMAND_WORD:
                    return buildFindCommand();
                case ExitCommand.COMMAND_WORD:
                    return buildExitCommand();
                case ClearCommand.COMMAND_WORD:
                    return buildClearCommand();
                case HelpCommand.COMMAND_WORD:
                    return buildHelpCommand();
                case EditCommand.COMMAND_WORD:
                    return buildEditCommand();
                case UndoCommand.COMMAND_WORD:
                    return buildUndoCommand();
                case RedoCommand.COMMAND_WORD:
                    return buildRedoCommand();
                case StoreCommand.COMMAND_WORD:
                    return buildStoreCommand();
                case ExportCommand.COMMAND_WORD:
                    return buildExportCommand();
                case ImportCommand.COMMAND_WORD:
                    return buildImportCommand();
                case RecallCommand.COMMAND_WORD:
                    return buildRecallCommand();
                case ListCommand.COMMAND_WORD:
                    return buildListCommand();
                default:
                    throw new UnknownCommandWordException(processedCommandWord);
            }
        } catch (IllegalValueException e) {
            throw new InvalidCommandFormatException(e.getMessage(), processedCommandWord);
        }
    }

    private Command buildRecallCommand() {
        RecallCommand command = new RecallCommand();

        // Extract tags
        Set<Tag> tags = commandParser.extractTrailingTags();
        if (!tags.isEmpty()) {
            command.tags = tags;
        }

        // Try to find keywords
        command.keywords = commandParser.extractWords().stream().collect(Collectors.toSet());

        return command;
    }


    private Command buildExitCommand() throws IllegalValueException {
        if (!commandParser.isInputEmpty()) {
            throw new IllegalValueException(String.format(Messages.INVALID_COMMAND_FORMAT, ExitCommand.COMMAND_WORD));
        }

        return new ExitCommand();
    }

```
###### \java\seedu\commando\logic\commands\CommandResult.java
``` java
/**
 * Represents the result of a command execution.
 */
public class CommandResult {

    private final String feedback;
    private boolean hasError;

    /**
     * Result of a command
     * @param feedback feedback to be shown to user
     * @param hasError if there was an error and command failed
     */
    public CommandResult(String feedback, boolean hasError) {
        assert feedback != null;

        this.feedback = feedback;
        this.hasError = hasError;
    }

    /**
     * Result of successful command
     */
    public CommandResult(String feedback) {
       this(feedback, false);
    }

    public String getFeedback() {
        return feedback;
    }

    public boolean hasError() {
        return hasError;
    }
}
```
###### \java\seedu\commando\logic\commands\DeleteCommand.java
``` java

/**
 * Deletes to-do(s), or their fields.
 */
public class DeleteCommand extends Command {

    public static final String COMMAND_WORD = "delete";

    public final List<Integer> toDoIndices;
    public boolean ifDeleteTime = false;
    public boolean ifDeleteTag = false;
    public boolean ifDeleteRecurrence = false;

    public DeleteCommand(List<Integer> toDoIndices) {
        this.toDoIndices = toDoIndices;
    }

```
###### \java\seedu\commando\logic\commands\EditCommand.java
``` java
/**
 * Edits a to-do in the current to-do list
 * Public fields are initially null and are optional parameters for the command
 */
public class EditCommand extends Command {

    public static final String COMMAND_WORD = "edit";

    private final int toDoIndex;
    public Title title;
    public DateRange dateRange;
    public DueDate dueDate;
    public Set<Tag> tags;

    public EditCommand(int toDoIndex) {
        this.toDoIndex = toDoIndex;
    }

    public CommandResult execute() throws NoModelException {
        Model model = getModel();

        Optional<UiToDo> toDoToEdit = model.getUiToDoAtIndex(toDoIndex);

        if (!toDoToEdit.isPresent()) {
            return new CommandResult(String.format(Messages.TODO_ITEM_INDEX_INVALID, toDoIndex), true);
        }

        // Copy original to-do
        ToDo newToDo = new ToDo(toDoToEdit.get());

        // Set fields if exist
        if (title != null) {
            newToDo.setTitle(title);
        }

        if (dueDate != null) {
            newToDo.setDueDate(dueDate);
        }

        if (dateRange != null) {
            newToDo.setDateRange(dateRange);
        }

        if (tags != null) {
            newToDo.setTags(tags);
        }

        // Check if to-do has changed
        if (newToDo.isSameStateAs(toDoToEdit.get())) {
            return new CommandResult(Messages.EDIT_COMMAND_NO_EDITS, true);
        }

        // Ensure to-do doesn't have both duedate and daterange
        if (newToDo.getDateRange().isPresent() && newToDo.getDueDate().isPresent()) {
            return new CommandResult(Messages.TODO_CANNOT_HAVE_DUEDATE_AND_DATERANGE, true);
        }

        try {
            model.changeToDoList(new ToDoListChange(
                new ToDoList().add(newToDo),
                new ToDoList().add(toDoToEdit.get())
            ));
        } catch (IllegalValueException exception) {
            return new CommandResult(exception.getMessage(), true);
        }

        String feedback = String.format(Messages.EDIT_COMMAND, newToDo.getTitle().toString());

        // If event already over, warn user
        if (newToDo.getDateRange().isPresent()
            && newToDo.getDateRange().get().endDate.isBefore(LocalDateTime.now())) {
            feedback += "\n" + Messages.EDIT_COMMAND_EVENT_OVER;
        }

        return new CommandResult(feedback);
    }
}
```
###### \java\seedu\commando\logic\commands\ExitCommand.java
``` java
/**
 * Terminates the program
 */
public class ExitCommand extends Command {

    public static final String COMMAND_WORD = "exit";

    public ExitCommand() {}

    @Override
    public CommandResult execute() throws NoEventsCenterException {
        EventsCenter eventsCenter = getEventsCenter();

        eventsCenter.post(new ExitAppRequestEvent());
        return new CommandResult(Messages.EXIT_APPLICATION);
    }
}
```
###### \java\seedu\commando\logic\commands\FindCommand.java
``` java
/**
 * Updates the filter for to-do list to show only to-do items containing all
 * of the keywords and tags (case insensitive)
 */
public class FindCommand extends Command {
    public static final String COMMAND_WORD = "find";

    public Set<String> keywords = Collections.emptySet();
    public Set<Tag> tags = Collections.emptySet();

    /**
     * Asserts that {@code uiLogic} is non-null
     */
    @Override
    public CommandResult execute() throws NoModelException {
        Model model = getModel();

        if (keywords.isEmpty() && tags.isEmpty()) {
            // if no keywords or tags are provided, show all unfinished to-dos
            model.clearUiToDoListFilter(Model.FILTER_MODE.UNFINISHED);
            return new CommandResult(Messages.FIND_COMMAND_CLEAR);
        } else {
            model.setUiToDoListFilter(keywords, tags, Model.FILTER_MODE.UNFINISHED);
            return new CommandResult(String.format(Messages.FIND_COMMAND, new TreeSet<>(keywords), new TreeSet<>(tags)));
        }
    }
}
```
###### \java\seedu\commando\logic\commands\HelpCommand.java
``` java
/**
 * Format full help instructions for every command for display.
 */
public class HelpCommand extends Command {

    public static final String COMMAND_WORD = "help";

    private final String commandWord;

    /**
     * Shows general help
     */
    public HelpCommand() {
        commandWord = "";
    }

    /**
     * Shows help for specific command word {@param commandWord}
     */
    public HelpCommand(String commandWord) {
        this.commandWord = commandWord;
    }

    @Override
    public CommandResult execute() throws NoEventsCenterException {
        EventsCenter eventsCenter = getEventsCenter();

        if (commandWord.isEmpty()) {
            eventsCenter.post(new ShowHelpRequestEvent(""));
        } else {
            Optional<String> anchor = Config.getUserGuideAnchorForCommandWord(commandWord);

            // If the command word is recognized
            if (anchor.isPresent()) {
                eventsCenter.post(new ShowHelpRequestEvent(anchor.get()));
            } else {
                return new CommandResult(String.format(Messages.UNKNOWN_COMMAND_FOR_HELP, commandWord), true);
            }
        }

        return new CommandResult(Messages.HELP_WINDOW_SHOWN);
    }
}
```
###### \java\seedu\commando\logic\commands\RecallCommand.java
``` java
/**
 * Changes to history mode, and updates the filter for to-do list
 * to show only to-do items containing all of the keywords and tags (case insensitive)
 */
public class RecallCommand extends Command {
    public static final String COMMAND_WORD = "recall";

    public Set<String> keywords = Collections.emptySet();
    public Set<Tag> tags = Collections.emptySet();

    /**
     * Asserts that {@code uiLogic} is non-null
     */
    @Override
    public CommandResult execute() throws NoModelException {
        Model model = getModel();

        if (keywords.isEmpty() && tags.isEmpty()) {
            // if no keywords or tags are provided, show all finished to-dos
            model.clearUiToDoListFilter(Model.FILTER_MODE.FINISHED);
            return new CommandResult(Messages.RECALL_COMMAND_CLEAR);
        } else {
            model.setUiToDoListFilter(keywords, tags, Model.FILTER_MODE.FINISHED);
            return new CommandResult(String.format(Messages.RECALL_COMMAND, new TreeSet<>(keywords), new TreeSet<>(tags)));
        }
    }
}
```
###### \java\seedu\commando\logic\Logic.java
``` java
/**
 * API of the Logic component
 */
public interface Logic {
    /**
     * Executes the command and returns the result
     * @param commandText The command as entered by the user
     * @return the result of the command execution
     */
    CommandResult execute(String commandText);

    /**
     * @see Model#getUiEvents()
     * */
    UnmodifiableObservableList<UiToDo> getUiEvents();

    /**
     * @see Model#getUiTasks()
     * */
    UnmodifiableObservableList<UiToDo> getUiTasks();

    /**
     * @see Model#getToDoList()
     * */
    ReadOnlyToDoList getToDoList();
}
```
###### \java\seedu\commando\logic\LogicManager.java
``` java
/**
 * Underlying logic in application
 */
public class LogicManager extends ComponentManager implements Logic {
    private final Logger logger = LogsCenter.getLogger(LogicManager.class);

    private final Model model;
    private final Storage storage;
    private final UserPrefs userPrefs;
    private final CommandFactory commandFactory = new CommandFactory();

    public LogicManager(Model model, Storage storage, UserPrefs userPrefs) {
        this.model = model;
        this.storage = storage;
        this.userPrefs = userPrefs;
    }

    @Override
    public CommandResult execute(String commandText) {
        logger.info("User command: " + commandText + "");

        try {
            Command command = commandFactory.build(commandText);

            command.setEventsCenter(eventsCenter);
            command.setModel(model);

            return command.execute();
        } catch (Command.NoEventsCenterException | Command.NoModelException exception) {
            assert false; // There should always be EventsCenter or Model
            return new CommandResult(exception.getMessage(), true);
        } catch (CommandFactory.InvalidCommandFormatException e) {

            // If invalid command format, check if Messages has sample commands for that command
            // Append to exception message if there is
            Optional<String> commandFormatMessage = Messages.getCommandFormatMessage(e.command);
            if (commandFormatMessage.isPresent()) {
                return new CommandResult(e.getMessage() + "\n" + commandFormatMessage.get(), true);
            } else {
                return new CommandResult(e.getMessage(), true);
            }

        } catch (CommandFactory.UnknownCommandWordException e) {
            return new CommandResult(String.format(Messages.UNKNOWN_COMMAND, e.commandWord), true);
        } catch (CommandFactory.MissingCommandWordException e) {
            return new CommandResult(Messages.MISSING_COMMAND_WORD, true);
        }
    }

    @Override
    public UnmodifiableObservableList<UiToDo> getUiEvents() {
        return model.getUiEvents();
    }

    @Override
    public UnmodifiableObservableList<UiToDo> getUiTasks() {
        return model.getUiTasks();
    }

    @Override
    public ReadOnlyToDoList getToDoList() {
        return model.getToDoList();
    }

    /**
     * Saves the current version of the to-do list to the hard disk
     * at the default filepath
     * Creates the data file if it is missing.
     * Raises {@link DataSavingExceptionEvent} if there was an error during saving.
     */
    @Subscribe
    public void handleToDoListChangedEvent(ToDoListChangedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event, "Local data changed, saving to file"));

        try {
            storage.saveToDoList(event.toDoList);
        } catch (IOException e) {
            raise(new DataSavingExceptionEvent(e));
        }
    }

    /**
     * Changes to-do list file path in user prefs and storage and saves the
     * to-do data to that new file path with storage
     */
    @Subscribe
    public void handleToDoListFilePathRequestEvent(ToDoListFilePathChangeRequestEvent event){
        logger.info(LogsCenter.getEventHandlingLogMessage(event));

        storage.setToDoListFilePath(event.path);

        try {
            storage.saveToDoList(model.getToDoList());
        } catch (IOException exception) {
            logger.warning("Failed to save to-do list data file: " + StringUtil.getDetails(exception));
        }

        userPrefs.setToDoListFilePath(event.path);
    }
}
```
###### \java\seedu\commando\logic\parser\CommandParser.java
``` java

/**
 * In charge of parsing an input command string, piece-wise, with the help of
 * {@link DateTimeParser}.
 * Methods modify the input string by extracting appropriate parts of it,
 * and input is always kept trimmed.
 */
public class CommandParser {
    public static final String KEYWORD_DATERANGE_START = "from";
    public static final String KEYWORD_DATERANGE_END = "to";
    public static final String KEYWORD_DATERANGE_DATE = "on";
    public static final String KEYWORD_DUEDATE = "by";
    public static final String RECURRENCE_REGEX = "daily|weekly|monthly|yearly";
    public static final String TAG_PREFIX = "#";
    public static final String QUOTE_CHARACTER = "`";

    private static final Pattern FIRST_WORD_PATTERN = Pattern.compile("^(?<word>\\S+)(?<left>.*?)$");
    private static final Pattern FIRST_QUOTED_TEXT_PATTERN = Pattern.compile("^" + QUOTE_CHARACTER + "(?<text>.*)" + QUOTE_CHARACTER + "(?<left>.*?)$");
    private static final Pattern FIRST_INTEGER_PATTERN = Pattern.compile("^(?<integer>-?\\d+)(?<left>.*?)$");
    private static final Pattern DATERANGE_PATTERN = Pattern.compile(
        "(?<left>.*)((" + KEYWORD_DATERANGE_START + "\\s+" + "(?<start>(.+\\s+)?)"
            + KEYWORD_DATERANGE_END + "(?<end>(\\s+.+?)?))|"
            + "(" + KEYWORD_DATERANGE_DATE + "\\s+(?<date>(.+?)?)))"
            + "(?<recurrence>(\\s+" + RECURRENCE_REGEX + ")?)$",
        Pattern.CASE_INSENSITIVE
    );
    private static final Pattern DUEDATE_PATTERN = Pattern.compile(
        "(?<left>.*)" + KEYWORD_DUEDATE + "\\s+" + "(?<date>.+?)"
            + "(?<recurrence>(\\s+" + RECURRENCE_REGEX + ")?)$",
        Pattern.CASE_INSENSITIVE
    );
    private static final Pattern TAGS_PATTERN = Pattern.compile(
        "(?<left>.*?)(?<tags>((\\s+|^)" + TAG_PREFIX + "\\S*)+)$",
        Pattern.CASE_INSENSITIVE
    );
    private static final Pattern INDEXRANGE_PATTERN = Pattern.compile(
        "^(?<firstInt>-?\\d+)" + "\\s*" + "((to)|-)" + "\\s*" + "(?<secondInt>-?\\d+)(?<left>.*?)$",
        Pattern.CASE_INSENSITIVE
    );

    private String input;
    private DateTimeParser dateTimeParser = new DateTimeParser();

    /**
     * Set the current input the parser is working on, and resets
     * any contextual info from the last input.
     */
    public void setInput(String input) {
        this.input = input;
        dateTimeParser.resetContext();
    }

    /**
     * Gets current input the parser is working on.
     */
    public String getInput() {
        return input.trim();
    }

    /**
     * Checks whether current input is empty.
     */
    public boolean isInputEmpty() {
        return input.trim().isEmpty();
    }

    /**
     * Extract a trailing due date from the input.
     * Date range is defined by: "by (valid_datetime)" + optional " (valid_recurrence)",
     * and must be at the end of the string to be considered.
     *
     * @return a due date if found, empty otherwise
     */
    public Optional<DueDate> extractTrailingDueDate() {
        final Matcher matcher = DUEDATE_PATTERN.matcher(input);

        if (matcher.find()) {
            String dateString = matcher.group("date");
            String recurrenceString = matcher.group("recurrence");

            // Parse datetime and recurrence
            Optional<DueDate> dueDate = parseDueDate(dateString, recurrenceString);

            // If legit date, extract from input and return due date
            if (dueDate.isPresent()) {
                input = matcher.group("left").trim();
                return dueDate;
            }
        }

        // Didn't find any matches
        return Optional.empty();
    }

    /**
     * Extract a trailing date range from the input.
     * Date range is defined by:
     *   - "from (valid_datetime) to (valid_datetime)" + an optional "(valid_recurrence)"
     *   - "on (valid_datetime)" + an optional "(valid_recurrence)",
     * and must be at the end of the string to be considered.
     *
     * @throws IllegalValueException if a trailing date range pattern is found but either one of the datetime is valid,
     *  other invalid, or parsed DateRange is not invalid
     */
    public Optional<DateRange> extractTrailingDateRange() throws IllegalValueException {
        final Matcher matcher = DATERANGE_PATTERN.matcher(input);

        if (matcher.find()) {
            String recurrenceString = matcher.group("recurrence");

            String startString = matcher.group("start");
            String endString = matcher.group("end");

            Optional<DateRange> dateRange;

            // if both "from" and "to" fields not specified, check "on"
            if (startString == null && endString == null) {
                String dateString = matcher.group("date");

                // Regex should ensure that "on" date is non-empty
                assert !dateString.isEmpty();

                dateRange = parseDateRange(dateString, recurrenceString);
            } else {
                dateRange = parseDateRange(startString, endString, recurrenceString);
            }

            // If legit date range, extract from input and return it
            if (dateRange.isPresent()) {
                input = matcher.group("left").trim();
                return dateRange;
            }
        }

        // Didn't find any matches
        return Optional.empty();
    }

    /**
     * Extracts all text in input
     */
    public Optional<String> extractText() {
        String text = input.trim();
        input = "";

        return text.isEmpty() ? Optional.empty() : Optional.of(text);
    }


    /**
     * From start, extracts a quoted title in input, if found
     * e.g. "`quoted` text" returns "quoted" and retains input "text"
     *
     * @return quoted text with quotes removed and trimmed if found,
     * empty if no quotes found
     * @throws IllegalValueException if quoted title found is empty
     */
    public Optional<String> extractQuotedTitle() throws IllegalValueException {
        final Matcher matcher = FIRST_QUOTED_TEXT_PATTERN.matcher(input);

        if (matcher.find()) {
            String text = matcher.group("text").trim();

            if (text.isEmpty()) {
                throw new IllegalValueException(Messages.MISSING_TODO_TITLE);
            }

            input = matcher.group("left").trim();
            return Optional.of(text);
        }

        return Optional.empty();
    }

    /**
     * From start, extracts all trailing tags from the current input.
     * Extraction ends when the next word is not a tag.
     * Tags which are empty strings are removed.
     *
     * @return a set of tags, with the tag prefix removed.
     */
    public Set<Tag> extractTrailingTags() {
        final Matcher matcher = TAGS_PATTERN.matcher(input);

        if (matcher.find()) {
            input = matcher.group("left").trim();

            // Split to words to get tags
            return Arrays.stream(matcher.group("tags").trim()
                .split("\\s+"))
                .map(word -> {
                    word = word.trim(); // trim any leading spaces
                    assert word.indexOf(TAG_PREFIX) == 0; // pattern should have ensured this
                    return new Tag(word.substring(TAG_PREFIX.length()).trim());
                }).filter(x -> !x.value.isEmpty())
                .collect(Collectors.toSet());
        }

        return Collections.emptySet();
    }

    /**
     * From start, extracts a single word in input, if found
     *
     * @return optional of word extracted from input, empty if not found
     */
    public Optional<String> extractWord() {
        final Matcher matcher = FIRST_WORD_PATTERN.matcher(input.trim());
        if (matcher.find()) {
            // Remove extracted first word
            input = matcher.group("left").trim();
            return Optional.of(matcher.group("word"));
        }

        return Optional.empty();
    }

    /**
     * Extracts all words in input
     * If input is empty, returns empty list
     */
    public List<String> extractWords() {
        return Arrays.stream(extractText().orElse("").split("\\s+"))
            .filter(x -> !x.trim().isEmpty())
            .collect(Collectors.toList());
    }

    /**
     * From start, extracts an integer in input, if found
     *
     * @return optional of found integer extracted from input, empty if not found
     */
    public Optional<Integer> extractInteger() {
        final Matcher matcher = FIRST_INTEGER_PATTERN.matcher(input.trim());

        if (matcher.find()) {
            // Remove extracted first integer
            String integerString = matcher.group("integer");
            input = matcher.group("left").trim();

            try {
                return Optional.of(Integer.parseInt(integerString));
            } catch (NumberFormatException exception) {
                assert false : "Shouldn't be able to fail parsing of integer based on pattern";
            }

        }

        return Optional.empty();
    }
```
###### \java\seedu\commando\logic\parser\CommandParser.java
``` java

    /**
     * Parses a recurrence string to a {@link Recurrence}
     * Asserts {@param recurrence} matches {@link #RECURRENCE_REGEX} or an empty string
     *
     * @return recurrence if valid, null if invalid, Recurrence.None if empty string
     */
    private Recurrence parseRecurrence(String recurrence) {
        switch (recurrence.trim()) {
            case "daily":
                return Recurrence.Daily;
            case "weekly":
                return Recurrence.Weekly;
            case "monthly":
                return Recurrence.Monthly;
            case "yearly":
                return Recurrence.Yearly;
            case "":
                return Recurrence.None;
            default:
                assert false;
        }

        return Recurrence.None;
    }

    private void throwIfEmptyString(String value, String message)
        throws IllegalValueException {
        if (value.trim().isEmpty()) {
            throw new IllegalValueException(message);
        }
    }

    private Optional<DateRange> parseDateRange(String startDateString, String endDateString, String recurrenceString)
        throws IllegalValueException {

        // Check both "from" and "to" fields are not empty
        throwIfEmptyString(startDateString, Messages.MISSING_TODO_DATERANGE_START + "\n" + Messages.DATE_FORMAT);
        throwIfEmptyString(endDateString, Messages.MISSING_TODO_DATERANGE_END + "\n" + Messages.DATE_FORMAT);

        // Parse start datetime with default time of midnight, end datetime with default time of 2359h
        Optional<LocalDateTime> startDateTime = dateTimeParser.parseDateTime(startDateString, LocalTime.MIDNIGHT);
        Optional<LocalDateTime> endDateTime = dateTimeParser.parseDateTime(endDateString, LocalTime.of(23, 59));

        if (!startDateTime.isPresent() && !endDateTime.isPresent()) {
            // Both start and end dates invalid, maybe its not a date range
            return Optional.empty();
        } else if (startDateTime.isPresent() && !endDateTime.isPresent()) {
            throw new IllegalValueException(Messages.INVALID_TODO_DATERANGE_END + "\n" + Messages.DATE_FORMAT);
        } else if (endDateTime.isPresent() && !startDateTime.isPresent()) {
            throw new IllegalValueException(Messages.INVALID_TODO_DATERANGE_START + "\n" + Messages.DATE_FORMAT);
        } else {
            assert startDateTime.isPresent() && endDateTime.isPresent();

            Recurrence recurrence = parseRecurrence(recurrenceString);
            return Optional.of(new DateRange(startDateTime.get(), endDateTime.get(), recurrence));
        }
    }

    private Optional<DateRange> parseDateRange(String dateString, String recurrenceString)
        throws IllegalValueException {

        if (dateString.isEmpty()) {
            return Optional.empty();
        }

        Optional<Pair<LocalDateTime, LocalDateTime>> period = dateTimeParser.parseDateTimePeriod(dateString);

        // Invalid datetime
        if (!period.isPresent()) {
            return Optional.empty();
        }

        Recurrence recurrence = parseRecurrence(recurrenceString);

        return Optional.of(
            new DateRange(period.get().getKey(), period.get().getValue(), recurrence)
        );
    }

    private Optional<DueDate> parseDueDate(String dateString, String recurrenceString) {
        // Parse datetime and recurrence
        Optional<LocalDateTime> date = dateTimeParser.parseDateTime(dateString);
        Recurrence recurrence = parseRecurrence(recurrenceString);

        if (date.isPresent()) {
            return Optional.of(new DueDate(date.get(), recurrence));
        } else {
            return Optional.empty();
        }
    }
}
```
###### \java\seedu\commando\logic\parser\DateTimeParser.java
``` java
/**
 * Parses datetimes with help of {@link com.joestelmach.natty.Parser}
 */
public class DateTimeParser {
    public static final LocalTime MorningLocalTime = LocalTime.of(8, 0);
    public static final LocalTime AfternoonLocalTime = LocalTime.of(12, 0);
    public static final LocalTime EveningLocalTime = LocalTime.of(19, 0);
    public static final LocalTime NightLocalTime = LocalTime.of(21, 0);

    private static final String MonthWordRegexString = "January|Feburary|March|April|June|July|August|September|October|November|December|" +
        "Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Sept|Oct|Nov|Dec";
    private static final String DayWordRegexString = "Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday|Mon|Tue|Tues|Wed|Thu|Thur|Thurs|Fri|Sat|Sun";
    private static final String YearRegexString = "(?<year>\\d{4}|\\d{2})";
    private static final String TwoDigitYearRegexString = "\\d{2}$";
    private static final String MonthRegexString = "(0?[1-9])|10|11|12";
    private static final String DayOfMonthRegexString = "([12]\\d)|([3][01])|(0?[1-9])";
    private static final String Hours24RegexString = "(1\\d)|20|21|22|23|(0?\\d)";
    private static final String Hours12RegexString = "11|12|(0?[1-9])";
    private static final String MinutesRegexString = "([1234]\\d)|(5[0-9])|(0?\\d)";

    private static final String DateWithSlashesRegexString = "(?<day>" + DayOfMonthRegexString + ")\\/(?<month>" + MonthRegexString + ")(\\/" + YearRegexString + ")?";
    private static final String DateWithMonthWordRegexString = "((" + DayOfMonthRegexString + ")(th|rd|st|nd)?)\\s+" +
        "(" + MonthWordRegexString + ")(\\s+" + YearRegexString + ")?";
    private static final String DateWithMonthWordReversedRegexString = "(" + MonthWordRegexString + ")\\s+" +
        "(" + DayOfMonthRegexString + ")(th|rd|st|nd)?(\\s+" + YearRegexString + ")?";
    private static final String DateWithDayWordRegexString = "((coming|next)\\s+)?(" + DayWordRegexString + ")";
    private static final String DateWithLaterAgoRegexString = "((\\d+\\d)|([2-9]))\\s+(days|weeks|months|years)\\s+(later|ago)";
    private static final String DateWithLastNextRegexString = "(last|this|next)\\s+(week|month|year)";
    private static final String TimeNightRegexString = "(this\\s+)?(night|tonight)";
    private static final String TimeHourRegexString = "(?<hours>" + Hours24RegexString + ")(?<minutes>" + MinutesRegexString + ")h";

    private static final String[] supportedDateRegexStrings = new String[] {
        DateWithSlashesRegexString,
        DateWithMonthWordRegexString,
        DateWithMonthWordReversedRegexString,
        DateWithDayWordRegexString,
        DateWithLaterAgoRegexString,
        DateWithLastNextRegexString,
        "today", "tomorrow|tmr", "yesterday"
    };

    private static final String[] supportedTimeRegexStrings = new String[] {
        "(" + Hours24RegexString + ")(\\.|:)(" + MinutesRegexString + ")",
        TimeHourRegexString,
        "(" + Hours12RegexString + ")(\\.|:)?(" + MinutesRegexString + ")?(am|pm)",
        "(this\\s+)?(morning|afternoon|noon|evening|midnight)",
        TimeNightRegexString
    };
    private static final String InitializationDateString = "today";

    private Parser parser = new Parser();
    private LocalDate lastLocalDate; // Date of last parsed datetime

    public DateTimeParser() {
        parseDateTime(InitializationDateString, LocalTime.MIDNIGHT);
    }

    /**
     * Resets any contextual info used based on history of parsing
     */
    public void resetContext() {
        lastLocalDate = null;
    }

    /**
     * @see #parseDateTime(String, LocalTime), but additional processing to
     *   interpret the datetime as a period.
     * @return pair of (start datetime, end datetime)
     */
    public Optional<Pair<LocalDateTime, LocalDateTime>> parseDateTimePeriod(String input) {
        Optional<LocalDateTime> localDateTime = parseDateTime(input);

        if (!localDateTime.isPresent()) {
            return Optional.empty();
        }

        String trimmedInput = input.trim();

        // Check if the input is trying to represent a period of > 1 day
        if (trimmedInput.matches(DateWithLaterAgoRegexString)
            || trimmedInput.matches(DateWithLastNextRegexString)) {
            if (trimmedInput.contains("week")) {
                // Return from monday to sunday of that week 2359h
                return Optional.of(
                    new Pair<>(
                        localDateTime.get().with(DayOfWeek.MONDAY),
                        localDateTime.get().with(DayOfWeek.SUNDAY).withHour(23).withMinute(59)
                    )
                );
            } else if (trimmedInput.contains("month")) {
                // Return from 1st to last day of month 2359h
                return Optional.of(
                    new Pair<>(
                        localDateTime.get().withDayOfMonth(1),
                        localDateTime.get().plusMonths(1).withDayOfMonth(1).minusDays(1)
                            .withHour(23).withMinute(59)
                    )
                );
            } else if (trimmedInput.contains("year")) {
                // Return from 1st to last day of year 2359h
                return Optional.of(
                    new Pair<>(
                        localDateTime.get().withDayOfYear(1),
                        localDateTime.get().plusYears(1).withDayOfYear(1).minusDays(1)
                            .withHour(23).withMinute(59)
                    )
                );
            }
        }

        // If not, treat it as on a single day until 2359h
        return Optional.of(new Pair<>(localDateTime.get(), localDateTime.get().withHour(23).withMinute(59)));
    }

    /**
     * @see #parseDateTime(String, LocalTime), but with a default time of
     *   midnight
     */
    public Optional<LocalDateTime> parseDateTime(String input) {
        return parseDateTime(input, LocalTime.MIDNIGHT);
    }

    /**
     * Gets the first datetime encountered in text
     * Works based on {@link com.joestelmach.natty.Parser}, but:
     * - Converted to `LocalDateTime`
     * - If time is deemed as "inferred" (in natty), time = {@param defaultTime}
     * - If date is "inferred" and there were previous parses, date = {@link #lastLocalDate}
     * - Seconds and nano-seconds field is always set to 0 (ignored)
     */
    public Optional<LocalDateTime> parseDateTime(String input, LocalTime defaultTime) {
        Optional<String> preprocessedInput = preprocessInput(input.trim());

        // If preprocessing fails, return empty
        if (!preprocessedInput.isPresent()) {
            return Optional.empty();
        }

        List<DateGroup> dateGroups = parser.parse(preprocessedInput.get());

        // Return first date parsed
        if (!dateGroups.isEmpty()) {
            DateGroup dateGroup = dateGroups.get(0);
            List<Date> dates = dateGroup.getDates();
            if (!dates.isEmpty()) {
                return Optional.of(toLocalDateTime(dateGroup, dates.get(0), defaultTime));
            }
        }

        return Optional.empty();
    }

    private LocalDateTime toLocalDateTime(DateGroup dateGroup, Date date, LocalTime defaultTime) {
        Instant instant = Instant.ofEpochMilli(date.getTime());
        ZoneId zoneId = ZoneOffset.systemDefault();

        LocalDateTime localDateTime = LocalDateTime.ofInstant(instant, zoneId);

        // Check if date is inferred
        if (dateGroup.isDateInferred() && lastLocalDate != null) {
            localDateTime = LocalDateTime.of(
                lastLocalDate,
                localDateTime.toLocalTime()
            );
        }

        // Check if time is inferred
        if (dateGroup.isTimeInferred()) {
            localDateTime = LocalDateTime.of(
                localDateTime.toLocalDate(),
                defaultTime
            );
        }

        // Reset seconds
        localDateTime = localDateTime.withSecond(0);

        // Remember last date parsed
        lastLocalDate = localDateTime.toLocalDate();

        return localDateTime;
    }

    /**
     * Determines with regex whether this is a supported datetime
     * Preprocesses it to before being parsed in natty
     * Assumes input is trimmed.
     * Returns empty if not supported
     */
    private Optional<String> preprocessInput(String input) {
        if (input.isEmpty()) {
            return Optional.empty();
        }

        // Try to match a date
        String dateString = "";
        for (String regexString : supportedDateRegexStrings) {
            // Try to match regex + (space or end of string)
            Matcher matcher = Pattern.compile(regexString + "(\\s|$)", Pattern.CASE_INSENSITIVE).matcher(input);

            // If matched from the start
            if (matcher.find() && matcher.start() == 0) {
                dateString = matcher.group().trim();
                dateString = handleDateWithSlashes(dateString, regexString, matcher);
                dateString = handleDateTwoDigitYear(dateString, matcher);

                // Extract out date string from text
                input = input.substring(matcher.end()).trim();

                break;
            }
        }

        // Try to match a time
        String timeString = "";
        for (String regexString : supportedTimeRegexStrings) {
            // Try to match regex + (space or end of string)
            Matcher matcher = Pattern.compile(regexString + "(\\s|$)").matcher(input);

            // If matched from the start
            if (matcher.find() && matcher.start() == 0) {
                timeString = matcher.group().trim();
                timeString = handleTimeFormatHour(timeString, regexString, matcher);
                timeString = handleTimeNight(timeString, regexString);

                input = input.substring(matcher.end()).trim();
                break;
            }
        }

        // If there is any characters left in text, invalid datetime
        if (!input.trim().isEmpty()) {
            return Optional.empty();
        } else {
            String dateTimeString = dateString + " " + timeString;

            dateTimeString = handleDateTimeWithLaterAgo(dateString, timeString, dateTimeString);

            return Optional.of(dateTimeString);
        }
    }

    private String handleDateTimeWithLaterAgo(String dateString, String timeString, String dateTimeString) {
        // Special case: if DateWithLaterRegexString is used,
        // swap date and time (for parsing in natty)
        if (dateString.matches(DateWithLaterAgoRegexString)) {
            return timeString + " " + dateString;
        } else {
            return dateTimeString;
        }
    }

    private String handleTimeNight(String timeString, String regexString) {
        // Special case: for TimeNightRegexString format,
        // Set time to 9pm
        if (regexString.equals(TimeNightRegexString)) {
            return NightLocalTime.toString();
        } else {
            return timeString;
        }
    }

    private String handleTimeFormatHour(String timeString, String regexString, Matcher matcher) {
        // Special case: for TimeHourRegexString format,
        // Change to colon format (natty parses it wrongly when there is no year in the date)
        if (regexString.equals(TimeHourRegexString)) {
            return matcher.group("hours") + ":" + matcher.group("minutes");
        } else {
            return timeString;
        }
    }

    private String handleDateTwoDigitYear(String dateString, Matcher matcher) {
        // Tweak for year: if it is a 2 digit year, change it to 4
        // Check if year string exists in datetime
        try {
            if (matcher.group("year") != null && matcher.group("year").length() == 2) {
                // Get string version of today's year
                String thisFullYear = String.valueOf(LocalDateTime.now().getYear());
                // If today's year is more than 2 digits, append the front (size - 2) digits
                if (thisFullYear.length() > 2) {
                    String fullYear = thisFullYear.substring(0, thisFullYear.length() - 2)
                        + matcher.group("year");
                    return dateString.replaceFirst(TwoDigitYearRegexString, fullYear);
                }
            }
        } catch (IllegalArgumentException exception) { } // no group with "year"

        return dateString;
    }

    private String handleDateWithSlashes(String dateString, String regexString, Matcher matcher) {
        // Special case: for DateWithSlashesRegexString format,
        // Swap month and day
        if (regexString.equals(DateWithSlashesRegexString)) {
            return matcher.group("month") + "/" + matcher.group("day")
            +  (matcher.group("year") != null ? ("/" + matcher.group("year")) : "");
        } else {
            return dateString;
        }
    }
}
```
###### \java\seedu\commando\model\Model.java
``` java
/**
 * The API of the Model component.
 */
public interface Model {
    /**
     * @return its to-do list, read-only
     */
    ReadOnlyToDoList getToDoList();

    /**
     * Applies a change to its to-do list.
     * @throws IllegalValueException if the change was invalid
     */
    void changeToDoList(ToDoListChange change) throws IllegalValueException;

    /**
     * Undos the last successful change to the to-do list.
     * @return true if there was a change that was undone
     */
    boolean undoToDoList();

    /**
     * Redos the last undo to the to-do list.
     * @return true if there was an undo that was redone
     */
    boolean redoToDoList();

    /**
     * Returns observable list of UI to-dos considered as events by ({@link UiToDo#isEvent()}
     *   to be displayed on the UI.
     * This changes with the filter on the UI to-dos and the to-do list of model.
     */
    UnmodifiableObservableList<UiToDo> getUiEvents();

    /**
     * Return observable list of UI to-dos considered as tasks by ({@link UiToDo#isTask()}
     * This changes with the filter on the UI to-dos and the to-do list of model.
     */
    UnmodifiableObservableList<UiToDo> getUiTasks();

     /**
     * @return the UI to-do with {@link UiToDo#getIndex()} == {@param toDoIndex}, if exists
     */
    Optional<UiToDo> getUiToDoAtIndex(int index);

    /**
     * @see seedu.commando.model.ui.UiModel#clearToDoListFilter(Model.FILTER_MODE)
     */
    void clearUiToDoListFilter(Model.FILTER_MODE filterMode);

    /**
     * @see seedu.commando.model.ui.UiModel#setToDoListFilter(Set, Set, Model.FILTER_MODE)
     */
    void setUiToDoListFilter(Set<String> keywords, Set<Tag> tags, Model.FILTER_MODE filterMode);

```
###### \java\seedu\commando\model\ModelManager.java
``` java

/**
 * Represents the in-memory model of the application's data
 * All changes to model should be synchronized
 */
public class ModelManager extends ComponentManager implements Model {
    private static final Logger logger = LogsCenter.getLogger(ModelManager.class);

    private final ToDoListManager toDoListManager;
    private final UiModel uiModel;

    /**
     * Initializes a ModelManager with the given to-do list.
     * Asserts parameters to be non-null.
     *
     * @param toDoList is copied during initialization
     */
    public ModelManager(ReadOnlyToDoList toDoList) {
        super();
        assert toDoList != null;

        logger.fine("Initializing with to-do list: " + toDoList);

        toDoListManager = new ToDoListManager(toDoList);
        uiModel = new UiModel(toDoListManager);

        logUiToDoList();
    }

    /**
     * @see ModelManager(ReadOnlyToDoList), but with an empty to-do list
     */
    public ModelManager() {
        this(new ToDoList());
    }

    @Override
    public ReadOnlyToDoList getToDoList() {
        return toDoListManager.getToDoList();
    }

    @Override
    public synchronized void changeToDoList(ToDoListChange change) throws IllegalValueException {
        toDoListManager.changeToDoList(change);

        // if to-do list has changed, reset any find or history filter
        clearUiToDoListFilter(Model.FILTER_MODE.UNFINISHED);
        indicateToDoListChanged();
        logUiToDoList();
    }

    @Override
    public boolean undoToDoList() {
        boolean hasChanged = toDoListManager.undoToDoList();

        if (hasChanged) {
            clearUiToDoListFilter(Model.FILTER_MODE.UNFINISHED);
            indicateToDoListChanged();
            logUiToDoList();
        }

        return hasChanged;
    }

    @Override
    public boolean redoToDoList() {
        boolean hasChanged = toDoListManager.redoToDoList();

        if (hasChanged) {
            clearUiToDoListFilter(Model.FILTER_MODE.UNFINISHED);
            indicateToDoListChanged();
            logUiToDoList();
        }

        return hasChanged;
    }

    @Override
    public UnmodifiableObservableList<UiToDo> getUiEvents() {
        return uiModel.getEvents();
    }

    @Override
    public UnmodifiableObservableList<UiToDo> getUiTasks() {
        return uiModel.getTasks();
    }

    @Override
    public Optional<UiToDo> getUiToDoAtIndex(int index) {
        return uiModel.getToDoAtIndex(index);
    }

    @Override
    public void clearUiToDoListFilter(Model.FILTER_MODE filterMode) {
        logger.info("Clearing filter on UI to-dos with filter mode: " + filterMode);

        uiModel.clearToDoListFilter(filterMode);
        logUiToDoList();
    }

    @Override
    public void setUiToDoListFilter(Set<String> keywords, Set<Tag> tags, Model.FILTER_MODE filterMode) {
        logger.info("Filtering UI to-dos by keywords " + keywords + " and tags " + tags
            + " with filter mode: " + filterMode);

        uiModel.setToDoListFilter(keywords, tags, filterMode);

        logUiToDoList();
    }

    /**
     * Raises an event to indicate the model has changed.
     */
    private void indicateToDoListChanged() {
        raise(new ToDoListChangedEvent(toDoListManager.getToDoList()));
    }

    private void logUiToDoList() {
        // log events and tasks shown
        logger.info("Events: " + uiModel.getEvents().stream().map(uiToDo -> uiToDo.getIndex() + ") " + uiToDo.getTitle())
            .collect(Collectors.joining(",")));

        logger.info("Tasks: " + uiModel.getTasks().stream().map(uiToDo -> uiToDo.getIndex() + ") " + uiToDo.getTitle())
            .collect(Collectors.joining(",")));
    }

```
###### \java\seedu\commando\model\todo\DateRange.java
``` java
/**
 * Represents a date range of a to-do, immutable.
 * Ignores the seconds and nano-seconds field of its datetimes.
 */
public class DateRange {
    private static DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm");

    public final LocalDateTime startDate, endDate;
    public final Recurrence recurrence;

    /**
     * @see #DateRange(LocalDateTime, LocalDateTime, Recurrence), but with no recurrence.
     */
    public DateRange(LocalDateTime startDate, LocalDateTime endDate) throws IllegalValueException {
        this(startDate, endDate, Recurrence.None);
    }

    /**
     * Constructor for a date range.
     * Asserts parameters are non-null.
     * Conditions for validity:
     *   - {@param endDate} must not be before {@param startDate}
     *   - gap between {@param startDate} and {@param endDate} must not be more than the recurrence interval
     * @throws IllegalValueException if given set of arguments is invalid
     */
    public DateRange(LocalDateTime startDate, LocalDateTime endDate, Recurrence recurrence) 
            throws IllegalValueException {
        assert !CollectionUtil.isAnyNull(startDate,endDate, recurrence);

        checkIfValid(startDate, endDate, recurrence);

        this.startDate = startDate.withSecond(0).withNano(0);
        this.endDate = endDate.withSecond(0).withNano(0);
        this.recurrence = recurrence;
    }

    /**
     * Copy constructor
     */
    public DateRange(DateRange dateRange){
        this.startDate = dateRange.startDate;
        this.endDate = dateRange.endDate;
        this.recurrence = dateRange.recurrence;
    }

    private static void checkIfValid(LocalDateTime startDate, LocalDateTime endDate, Recurrence recurrence)
        throws IllegalValueException {

        // Checks if start date is before end date
        if (endDate.isBefore(startDate)) {
            throw new IllegalValueException(Messages.TODO_DATERANGE_END_MUST_AFTER_START + "\n" + Messages.DATE_FORMAT);
        }

        // Checks gap between dates must not be more than the recurrence interval
        if (recurrence != Recurrence.None
            && recurrence.getNextDate(startDate).isBefore(endDate)) {
            throw new IllegalValueException(Messages.TODO_DATERANGE_RECURRENCE_INVALID + "\n" + Messages.DATE_FORMAT);
        }
    }

    @Override
    public String toString() {
        return startDate.format(dateFormatter) + " - " + endDate.format(dateFormatter)
            + ((recurrence == Recurrence.None) ? "" : " " + recurrence.toString().toLowerCase());
    }

    @Override
    public boolean equals(Object other) {
        // short circuit if same object
        // instanceof handles nulls
        return other == this
                || (other instanceof DateRange
                && (startDate.equals(((DateRange) other).startDate) 
                && endDate.equals(((DateRange) other).endDate)
                && recurrence.equals(((DateRange) other).recurrence))); // state check
    }

    @Override
    public int hashCode() {
        return Objects.hash(startDate, endDate, recurrence);
    }

}
```
###### \java\seedu\commando\model\todo\ReadOnlyToDo.java
``` java
/**
 * A read-only immutable interface for a to-do.
 */
public interface ReadOnlyToDo {

    Title getTitle();

    Optional<DateRange> getDateRange();

    Optional<DueDate> getDueDate();

    Set<Tag> getTags();

    LocalDateTime getDateCreated();

    /**
     * @return if either to-do contains a date range or a due date
     */
    default boolean hasTimeConstraint() {
        return getDateRange().isPresent()
            || getDueDate().isPresent();
    }

    /**
     * Returns the date which the to-do is completed.
     */
    Optional<LocalDateTime> getDateFinished();

    /**
     * Returns true if date finished is set and it is before the current time.
     */
    default boolean isFinished() {
        return getDateFinished().isPresent() && LocalDateTime.now().isAfter(getDateFinished().get());
    }

    /**
     * An observable value that changes when any of its fields are updated.
     */
    ObservableValue getObservableValue();

    /**
     * Returns true if both have the same state.
     * All fields, except date created, must be equal.
     */
    default boolean isSameStateAs(ReadOnlyToDo other) {
        // short circuit if same object
        // other != null to avoid NPE below
        return other == this
            || (other != null
            && other.getTitle().equals(getTitle())
            && other.getDateRange().equals(getDateRange())
            && other.getDueDate().equals(getDueDate())
            && other.getTags().equals(getTags())
            && other.getDateFinished().equals(getDateFinished()));
    }

    /**
     * Returns true if both are considered "similar",
     *   which means these fields must be equal:
     *      - title
     *      - due date
     *      - date range
     *      - tags
     */
    default boolean isSimilar(ReadOnlyToDo other) {
        return other == this // short circuit if same object
            || (other != null // this is first to avoid NPE below
            && other.getTitle().equals(getTitle())
            && other.getDateRange().equals(getDateRange())
            && other.getDueDate().equals(getDueDate())
            && other.getTags().equals(getTags()));
    }

    /**
     * @return a complete textual representation of the to-do as a string
     */
    default String getText() {
        return String.join(", ",
            "Title: " + getTitle(),
            "Date Range: " + (getDateRange().isPresent() ? getDateRange().get() : "none"),
            "Due Date: " + (getDueDate().isPresent() ? getDueDate().get() : "none"),
            "Tags: " + getTags(),
            "Date Created: " + getDateCreated(),
            "Date Finished: " + (getDateFinished().isPresent() ? getDateFinished().get() : "none"));
    }
}
```
###### \java\seedu\commando\model\todo\ReadOnlyToDoList.java
``` java
/**
 * Unmodifiable view of a to-do list.
 */
public interface ReadOnlyToDoList {
    UnmodifiableObservableList<ReadOnlyToDo> getToDos();

    /**
     *  Checks if the list contains a to-do that is considered as similar
     *    as the given to-do. See {@link ReadOnlyToDo#isSimilar(ReadOnlyToDo)}.
     */
    boolean contains(ReadOnlyToDo toDo);

    /**
     *  Checks if the list is considered similar as the given to-do list,
     *    which means both their to-dos must be considered similar.
     *    See {@link ReadOnlyToDo#isSimilar(ReadOnlyToDo)}.
     */
    boolean isSimilar(ReadOnlyToDoList toDoList);

    /**
     * @return a complete textual representation of the to-do list as a string
     */
    default String getText() {
        return "[" + getToDos().stream().map(ReadOnlyToDo::toString).collect(Collectors.joining(", ")) + "]";
    }
}
```
###### \java\seedu\commando\model\todo\Recurrence.java
``` java
/**
 * Represents a recurrence in a to-do.
 */
public enum Recurrence {
    Daily,
    Weekly,
    Monthly,
    Yearly,
    None;

    /**
     * @param date starting datetime
     * @return the next datetime based on this recurrence
     */
    public LocalDateTime getNextDate(LocalDateTime date) {
        switch (this) {
            case Daily:
                return date.plusDays(1);
            case Weekly:
                return date.plusWeeks(1);
            case Monthly:
                return date.plusMonths(1);
            case Yearly:
                return date.plusYears(1);
            case None:
                return date;
        }

        return date;
    }
}
```
###### \java\seedu\commando\model\todo\ToDo.java
``` java
    /**
     * Called when a to-do is to advance its date range to after {@param dateUntil}
     *   based on its recurrence.
     * Will only have an effect if to-do has a date range with a recurrence,
     */
    private void advanceDateRange(LocalDateTime dateUntil) {
        if (dateRange == null
            || dateUntil.isBefore(dateRange.endDate)
            || dateRange.recurrence == Recurrence.None) {
            return;
        }

        // The initial if-else should cover this
        assert dateRange != null && dateRange.recurrence != Recurrence.None;

        // Keep moving date forward based on recurrence interval
        // until it is not before the current date
        LocalDateTime startDate = dateRange.startDate;
        LocalDateTime endDate = dateRange.endDate;
        while (!startDate.isAfter(dateUntil)) {
            startDate = dateRange.recurrence.getNextDate(startDate);
            endDate = dateRange.recurrence.getNextDate(endDate);
        }
        try {
            dateRange = new DateRange(startDate, endDate, dateRange.recurrence);
        } catch (IllegalValueException exception) {
            assert false : "new date range should be valid";
        }

        updateValue();
    }

    /**
     * Called when a to-do is to advance its due date to after {@param dateUntil}
     *   based on its recurrence.
     * Will only have an effect if to-do has a due date with a recurrence,
     */
    private void advanceDueDate(LocalDateTime dateUntil) {
        if (dueDate == null
            || dateUntil.isBefore(dueDate.value)
            || dueDate.recurrence == Recurrence.None) {
            return;
        }

        // The initial if-else should cover this
        assert dueDate != null && dueDate.recurrence != Recurrence.None;

        // Keep moving date forward based on recurrence interval
        // until it is not before the current date
        LocalDateTime date = dueDate.value;
        while (!date.isAfter(dateUntil)) {
            date = dueDate.recurrence.getNextDate(date);
        }
        dueDate = new DueDate(date, dueDate.recurrence);

        updateValue();
    }
}
```
###### \java\seedu\commando\model\todo\ToDoList.java
``` java
/**
 * Represents a list of to-dos.
 */
public class ToDoList implements ReadOnlyToDoList {
    private final ObservableList<ReadOnlyToDo> list;
    private final UnmodifiableObservableList<ReadOnlyToDo> protectedList;
    {
        // Initializes an observable list to store to-dos, which
        // calls its listeners when any of its to-dos change
        list = FXCollections.observableArrayList(toDo -> new Observable[] {
            toDo.getObservableValue()
        });

        // Initializes a read-only wrapper around the list of to-dos
        protectedList = new UnmodifiableObservableList<>(list);
    }

    public ToDoList() {}

    /**
     * Copy constructor
     */
    public ToDoList(ReadOnlyToDoList listToBeCopied) {
        reset(listToBeCopied.getToDos());
    }

    /**
     * @see #add(ReadOnlyToDoList)
     */
    public ToDoList add(ReadOnlyToDo toDo) throws IllegalValueException {
        if (contains(toDo)) {
            throw new IllegalValueException(Messages.TODO_ALREADY_EXISTS);
        }

        list.add(toDo);

        return this;
    }
    /**
     * @see #remove(ReadOnlyToDoList)
     */
    public ToDoList remove(ReadOnlyToDo toDo) throws IllegalValueException {
        if (!contains(toDo)) {
            throw new IllegalValueException(Messages.TODO_NOT_FOUND);
        }

        list.remove(toDo);

        return this;
    }

    /**
     * Add all to-dos in {@param toDoList}.
     * @throws IllegalValueException if any to-do in {@param toDoList} already exists
     */
    public ToDoList add(ReadOnlyToDoList toDoList) throws IllegalValueException {
        assert toDoList != null;

        for (ReadOnlyToDo toDo : toDoList.getToDos()) {
            if (contains(toDo)) {
                throw new IllegalValueException(Messages.TODO_ALREADY_EXISTS);
            }
        }

        list.addAll(toDoList.getToDos());

        return this;
    }

    /**
     * Removes all to-dos in {@param toDoList}.
     * @throws IllegalValueException if any to-do in {@param toDoList} was not found for deletion
     */
    public ToDoList remove(ReadOnlyToDoList toDoList) throws IllegalValueException {
        assert toDoList != null;

        for (ReadOnlyToDo toDoToRemove : toDoList.getToDos()) {
            if (!contains(toDoToRemove)) {
                throw new IllegalValueException(Messages.TODO_NOT_FOUND);
            }
        }

        list.removeAll(toDoList.getToDos());

        return this;
    }

    /**
     * Clears the list and sets it to a deep copy of {@param newToDos}.
     */
    public void reset(List<ReadOnlyToDo> newToDos) {
        List<ToDo> toDos = new LinkedList<>();
        newToDos.forEach(toDo -> toDos.add(new ToDo(toDo)));
        list.setAll(toDos);
    }

    @Override
    public String toString() {
        return getText();
    }

    /**
     * @return a read-only list of read-only to-dos it contains
     */
    public UnmodifiableObservableList<ReadOnlyToDo> getToDos() {
        return protectedList;
    }

    /**
     *  @see ReadOnlyToDoList#contains(ReadOnlyToDo)
     */
    @Override
    public boolean contains(ReadOnlyToDo toDo) {
        return list.filtered(x -> x.isSimilar(toDo)).size() > 0;
    }

    /**
     *  @see ReadOnlyToDoList#isSimilar(ReadOnlyToDoList)
     */
    @Override
    public boolean isSimilar(ReadOnlyToDoList toDoList) {
        return list.size() == toDoList.getToDos().size()
            && list.filtered(toDoList::contains).size() == list.size();
    }

    @Override
    public boolean equals(Object other) {
        // short circuit if same object
        // instanceof handles nulls
        return other == this
                || (other instanceof ToDoList
                && list.equals(((ToDoList) other).list));
    }

    @Override
    public int hashCode() {
        return Objects.hash(list);
    }
}
```
###### \java\seedu\commando\model\todo\ToDoListChange.java
``` java
/**
 * An immutable representation of a change in a to-do list.
 */
public class ToDoListChange {
    private final ToDoList addedToDos;
    private final ToDoList deletedToDos;

    /**
     * Constructor for a to-do list change.
     * @param addedToDos list of to-dos to be added, which is deep copied
     * @param deletedToDos list of to-dos to be deleted, which is deep copied
     */
    public ToDoListChange(ReadOnlyToDoList addedToDos, ReadOnlyToDoList deletedToDos) {
        this.addedToDos = new ToDoList(addedToDos);
        this.deletedToDos = new ToDoList(deletedToDos);
    }

    public ReadOnlyToDoList getAddedToDos() {
        return addedToDos;
    }

    public ReadOnlyToDoList getDeletedToDos() {
        return deletedToDos;
    }

    /**
     * @return reverse of this change
     */
    public ToDoListChange getReverseChange() {
        return new ToDoListChange(deletedToDos, addedToDos);
    }

    @Override
    public boolean equals(Object other) {
        // short circuit if same object
        // instanceof handles nulls
        return other == this
            || (other instanceof ToDoListChange
            && addedToDos.equals(((ToDoListChange) other).addedToDos)
            && deletedToDos.equals(((ToDoListChange) other).deletedToDos));
    }

    @Override
    public int hashCode() {
        return Objects.hash(addedToDos, deletedToDos);
    }

    @Override
    public String toString(){
        return "Added " + addedToDos + " & deleted " + deletedToDos;
    }
}
```
###### \java\seedu\commando\model\ToDoListManager.java
``` java
/**
 * In charge of supporting the editing, undoing and redoing of the to-do list,
 *   hinging on the {@link ToDoListChange} class
 */
public class ToDoListManager {
    private final ToDoList toDoList;

    // changes that can be undone
    private final ArrayList<ToDoListChange> toDoListChanges = new ArrayList<>();

    // changes that can be redone
    private final ArrayList<ToDoListChange> toDoListUndoChanges = new ArrayList<>();

    private ToDoListChange lastToDoListChange;

    /**
     * Initializes with the given to-do list, which is managed internally.
     * Asserts parameters are non-null.
     * To-do list is deep copied.
     */
    public ToDoListManager(ReadOnlyToDoList toDoList) {
        assert toDoList != null;

        this.toDoList = new ToDoList(toDoList);
    }

    public ReadOnlyToDoList getToDoList() {
        return toDoList;
    }

    public void changeToDoList(ToDoListChange change) throws IllegalValueException {
        applyToDoListChange(change);
        toDoListChanges.add(change);

        // Reset undo list upon a change
        toDoListUndoChanges.clear();
    }

    public boolean undoToDoList() {
        // Nothing else to undo if the list of changes is empty
        if (toDoListChanges.isEmpty()) {
            return false;
        }

        ToDoListChange change = toDoListChanges.get(toDoListChanges.size() - 1);

        try {
            applyToDoListChange(change.getReverseChange());
        } catch (IllegalValueException exception) {
            // undo should always work
            assert false;
            return false;
        }

        // move changes from change list to to undo change list
        toDoListUndoChanges.add(change);
        toDoListChanges.remove(toDoListChanges.size() - 1);

        return true;
    }

    public boolean redoToDoList() {
        // Check if there are any undos to redo
        if (toDoListUndoChanges.isEmpty()) {
            return false;
        }

        ToDoListChange change = toDoListUndoChanges.get(toDoListUndoChanges.size() - 1);

        try {
            applyToDoListChange(change);
        } catch (IllegalValueException exception) {
            // Redo should always work
            assert false;
            return false;
        }

        // move changes from undo change list to change list
        toDoListChanges.add(change);
        toDoListUndoChanges.remove(toDoListUndoChanges.size() - 1);

        return true;
    }

    /**
     * Tries to apply a change to the to-do list
     * @throws IllegalValueException if there were duplicate to-dos added or
     *   there were non-existent to-dos deleted
     */
    private void applyToDoListChange(ToDoListChange change) throws IllegalValueException {
        lastToDoListChange = change;

        toDoList.remove(change.getDeletedToDos());

        try {
            toDoList.add(change.getAddedToDos());
        } catch (IllegalValueException exception) {
            // there were duplicate to-dos
            // revert removal of to-dos
            toDoList.add(change.getDeletedToDos());
            lastToDoListChange = null;
            throw exception;
        }
    }

    /**
     * @return last successful change to the to-do list, considering undos and redos
     */
    public Optional<ToDoListChange> getLastToDoListChange() {
        return Optional.ofNullable(lastToDoListChange);
    }
}
```
###### \java\seedu\commando\model\ui\UiModel.java
``` java
/**
 * In charge of processing and filtering the list of to-dos for the UI.
 */
public class UiModel {
    private final ToDoListManager toDoListManager;
    private final ObservableList<UiToDo> events = FXCollections.observableArrayList();
    private final ObservableList<UiToDo> tasks = FXCollections.observableArrayList();
    private final UnmodifiableObservableList<UiToDo> protectedEvents = new UnmodifiableObservableList<>(events);
    private final UnmodifiableObservableList<UiToDo> protectedTasks = new UnmodifiableObservableList<>(tasks);
    private final ArrayList<UiToDo> toDoAtIndices = new ArrayList<>();
    private int runningIndex;

    // Parameters for filtering
    private FILTER_MODE filterMode = FILTER_MODE.ALL;

    public enum FILTER_MODE {
        FINISHED, UNFINISHED, ALL
    }

    /**
     * @param toDoListManager ToDoListManager it tracks and grabs the list of to-dos from
     */
    public UiModel(ToDoListManager toDoListManager) {
        this.toDoListManager = toDoListManager;

        // Initialize the filter to show unfinished to-dos
        clearToDoListFilter(FILTER_MODE.UNFINISHED);

        // Start tracking changes to-do list, and update UI to-dos when a change happens
        toDoListManager.getToDoList().getToDos().addListener(new ListChangeListener<ReadOnlyToDo>() {
            @Override
            public void onChanged(Change<? extends ReadOnlyToDo> change) {
                clearToDoListFilter(filterMode);
            }
        });
    }

    /**
     * Get to-do item at index as displayed on the UI
     */
    public Optional<UiToDo> getToDoAtIndex(int index) {
        if (index - 1 < 0 || index - 1 >= toDoAtIndices.size()) {
            return Optional.empty();
        } else {
            return Optional.of(toDoAtIndices.get(index - 1));
        }
    }

    /**
     * Clears any keywords, tags or daterange filters on the UI to-dos
     *   and sets the filter mode.
     * Asserts parameters to be non-null.
     */
    public void clearToDoListFilter(FILTER_MODE filterMode) {
        assert !CollectionUtil.isAnyNull(filterMode);
        setToDoListFilter(Collections.emptySet(), Collections.emptySet(), filterMode);
    }

    /**
     * Sets a filter mode, keywords filter, and tags filter on the UI to-dos.
     * Asserts parameters to be non-null.
     * If {@param filterMode} ==
     *   - ALL: all to-dos that match keywords and tags are shown.
     *   - FINISHED: finished to-dos that match keywords and tags are shown
     *   - UNFINISHED: unfinished to-dos or finished to-dos that are finished on the
     *       the current day, that match keywords and tags, are shown
     */
    public void setToDoListFilter(Set<String> keywords, Set<Tag> tags, FILTER_MODE filterMode) {
        assert !CollectionUtil.isAnyNull(keywords, tags, filterMode);

        this.filterMode = filterMode;

        updateEventsAndTasks(keywords, tags);
    }

```
###### \java\seedu\commando\model\ui\UiModel.java
``` java
    /**
     * @return a list of UI to-dos defined as events, to be shown on the UI
     */
    public UnmodifiableObservableList<UiToDo> getEvents() {
        return protectedEvents;
    }

    /**
     * @return a list of UI to-dos defined as tasks, to be shown on the UI
     */
    public UnmodifiableObservableList<UiToDo> getTasks() {
        return protectedTasks;
    }

    /**
     * Update the UI to-dos based on {@link #toDoListManager}'s to-do list and
     *   the keywords and tags filter.
     */
    private void updateEventsAndTasks(Set<String> keywords, Set<Tag> tags) {
        // Sort and filter events and tasks for UI
        List<ReadOnlyToDo> events = filterAndSortEvents(toDoListManager.getToDoList().getToDos(), keywords, tags);
        List<ReadOnlyToDo> tasks = filterAndSortTasks(toDoListManager.getToDoList().getToDos(), keywords, tags);

        // Update its own lists of UI to-dos
        updateUiToDos(events, tasks);
    }

```
###### \java\seedu\commando\model\ui\UiModel.java
``` java
    /**
     * Populate its lists of UI to-dos based on supplied to-dos
     */
    private void updateUiToDos(List<ReadOnlyToDo> events, List<ReadOnlyToDo> tasks) {
        toDoAtIndices.clear();
        runningIndex = 0;

        Optional<ToDoListChange> lastChange = toDoListManager.getLastToDoListChange();

        ReadOnlyToDoList newToDos = lastChange.isPresent()
            ? lastChange.get().getAddedToDos() : new ToDoList();

        // Map each event to a UI to-do and add an index to each
        // Also check if the events are new with respect to last change
        this.events.setAll(events.stream().map(
            toDo -> new UiToDo(toDo, ++ runningIndex, newToDos.contains(toDo))
        ).collect(Collectors.toList()));
        toDoAtIndices.addAll(this.events);

        // Then do the same for tasks
        this.tasks.setAll(tasks.stream().map(
            toDo -> new UiToDo(toDo, ++ runningIndex, newToDos.contains(toDo))
        ).collect(Collectors.toList()));
        toDoAtIndices.addAll(this.tasks);

        // running index should be incremented by no. of to-dos
        assert runningIndex == toDoAtIndices.size();
    }
```
###### \java\seedu\commando\model\ui\UiModel.java
``` java
	private List<ReadOnlyToDo> filterAndSortTasks(List<ReadOnlyToDo> toDos,
                                                  Set<String> keywords, Set<Tag> tags) {
        List<ReadOnlyToDo> tasks = toDos.stream()
            .filter(toDoFilterModePredicate)
            .filter(toDo -> ifMatchesKeywordsAndTags(toDo, keywords, tags))
            .filter(UiToDo::isTask)
            .collect(Collectors.toList());

        // For tasks, sort by created date first (latest first)
        tasks.sort((task1, task2) -> task2.getDateCreated().compareTo(task1.getDateCreated()));

        // Then, by whether they have due date and that date (latest first)
        tasks.sort((task1, task2) -> compareDueDates(task1, task2));

        // Then, by whether they are finished and finished date (latest first)
        tasks.sort((task1, task2) -> compareDateFinished(task2, task1));

        return tasks;
    }

    private List<ReadOnlyToDo> filterAndSortEvents(List<ReadOnlyToDo> toDos,
                                                   Set<String> keywords, Set<Tag> tags) {
        List<ReadOnlyToDo> events = toDos.stream()
            .filter(toDoFilterModePredicate)
            .filter(toDo -> ifMatchesKeywordsAndTags(toDo, keywords, tags))
            .filter(UiToDo::isEvent)
            .collect(Collectors.toList());

        // For events, sort by created date first (latest first)
        events.sort((event1, event2) -> event2.getDateCreated().compareTo(event1.getDateCreated()));

        // Then, by start dates (earlier first)
        events.sort((event1, event2) -> compareDateRangeStarts(event1, event2));

        // Then, by whether they are finished and finished date (latest first)
        events.sort((event1, event2) -> compareDateFinished(event2, event1));

        return events;
    }

    //================================================================================
    //  Utility methods for sorting and filtering
    //================================================================================

    private int compareDateFinished(ReadOnlyToDo toDo1, ReadOnlyToDo toDo2) {
        LocalDateTime date1 = toDo1.getDateFinished().orElse(LocalDateTime.MAX);
        LocalDateTime date2 = toDo2.getDateFinished().orElse(LocalDateTime.MAX);

        return date1.compareTo(date2);
    }

    private int compareDueDates(ReadOnlyToDo toDo1, ReadOnlyToDo toDo2) {
        LocalDateTime date1 = toDo1.getDueDate().isPresent() ?
            toDo1.getDueDate().get().value : LocalDateTime.MAX;
        LocalDateTime date2 = toDo2.getDueDate().isPresent() ?
            toDo2.getDueDate().get().value : LocalDateTime.MAX;

        return date1.compareTo(date2);
    }

    private int compareDateRangeStarts(ReadOnlyToDo toDo1, ReadOnlyToDo toDo2) {
        LocalDateTime date1 = toDo1.getDateRange().isPresent() ?
            toDo1.getDateRange().get().startDate : LocalDateTime.MAX;
        LocalDateTime date2 = toDo2.getDateRange().isPresent() ?
            toDo2.getDateRange().get().startDate : LocalDateTime.MAX;

        return date1.compareTo(date2);
    }

    private boolean checkForKeyword(ReadOnlyToDo toDo, String keyword) {
        return StringUtil.substringIgnoreCase(toDo.getTitle().value, keyword) ||
            toDo.getTags().stream().anyMatch(toDoTag -> StringUtil.substringIgnoreCase(toDoTag.value, keyword));
    }

    private boolean checkForTag(ReadOnlyToDo toDo, Tag tag) {
        return toDo.getTags().stream().anyMatch(toDoTag -> toDoTag.value.equalsIgnoreCase(tag.value));
    }

    /**
     * Predicate that filters to-dos based on filter mode
     */
    private Predicate<ReadOnlyToDo> toDoFilterModePredicate = toDo -> {
        switch (filterMode) {
            case ALL: return true;
            case UNFINISHED:
                // if unfinished mode but to-do is finished before the current day
                return !toDo.isFinished()
                    || (toDo.isFinished() && toDo.getDateFinished().get().toLocalDate().isEqual(LocalDate.now()));
            case FINISHED:
                // if finished mode but to-do is unfinished
                return toDo.isFinished();
            default:
                assert false : "Should have covered all filter modes";
                return false;
        }
    };

    /**
     * Returns whether a to-do matches a set of keywords and tags
     */
    private boolean ifMatchesKeywordsAndTags(ReadOnlyToDo toDo, Set<String> keywords, Set<Tag> tags) {
        return (keywords.stream()
            .allMatch(keyword -> checkForKeyword(toDo, keyword)))
            && (tags.stream()
            .allMatch(tag -> checkForTag(toDo, tag)));
    }
}
```
###### \java\seedu\commando\model\ui\UiToDo.java
``` java
/**
 * Represents a to-do on the UI.
 */
public class UiToDo implements ReadOnlyToDo {

    private final ReadOnlyToDo toDo;
    private final int index;
    private final boolean isNew;

    public UiToDo(ReadOnlyToDo toDo, int index, boolean isNew) {
        this.toDo = toDo;
        this.isNew = isNew;
        this.index = index;
    }

    /**
     * Returns whether a to-do item is an event
     */
    public static boolean isEvent(ReadOnlyToDo todo) {
        return todo.getDateRange().isPresent();
    }

    /**
     * Returns whether a to-do item is a task
     */
    public static boolean isTask(ReadOnlyToDo todo) {
        return !todo.getDateRange().isPresent();
    }

    @Override
    public Title getTitle() {
        return toDo.getTitle();
    }

    @Override
    public Optional<DateRange> getDateRange() {
        return toDo.getDateRange();
    }

    @Override
    public Optional<DueDate> getDueDate() {
        return toDo.getDueDate();
    }

    @Override
    public Set<Tag> getTags() {
        return toDo.getTags();
    }

    @Override
    public boolean isFinished() {
        return toDo.isFinished();
    }

    @Override
    public Optional<LocalDateTime> getDateFinished() {
        return toDo.getDateFinished();
    }

    @Override
    public LocalDateTime getDateCreated() {
        return toDo.getDateCreated();
    }

    @Override
    public ObservableValue getObservableValue() {
        return toDo.getObservableValue();
    }

    /**
     * @return index of the to-do on the UI.
     */
    public int getIndex() {
        return index;
    }

    /**
     * @return whether the to-do is newly added or edited.
     */
    public boolean isNew() { return isNew; }

    public boolean isEvent() {
        return isEvent(this);
    }

    public boolean isTask() {
        return isTask(this);
    }

    @Override
    public boolean equals(Object other) {
        // short circuit if same object
        // instanceof handles nulls
        return other == this
            || (other instanceof UiToDo
            && this.isSameStateAs((UiToDo) other)
            && index == ((UiToDo) other).index
            && isNew == ((UiToDo) other).isNew);
    }

    @Override
    public int hashCode() {
        return Objects.hash(toDo, index, isNew);
    }

    @Override
    public String toString() {
        return toDo + " with index of " + index
            + (isNew ? "(new)" : "");
    }
}
```
###### \java\seedu\commando\model\UserPrefs.java
``` java
/**
 * Represents the user's preferences.
 */
public class UserPrefs {
    private GuiSettings guiSettings = new GuiSettings();
    private StringProperty toDoListFilePath = new SimpleStringProperty(Config.DefaultToDoListFilePath);

    public UserPrefs() {}

    public GuiSettings getGuiSettings() {
        return guiSettings;
    }

    /**
     * @return an observable string for its to-do list file path
     */
    public ObservableValue<String> getToDoListFilePath() {
        return toDoListFilePath;
    }

    /**
     * Sets its to-do list file path and triggers change listeners of {@link #getToDoListFilePath()}
     */
    public void setToDoListFilePath(String filePath) {
        toDoListFilePath.setValue(filePath);
    }


    /**
     * Sets its GUI settings to that given.
     * Does a deep copy of {@param guiSettings}.
     */
    public void setGuiSettings(GuiSettings guiSettings) {
        this.guiSettings = new GuiSettings(guiSettings);
    }

    public void setGuiSettings(double width, double height, int x, int y, boolean isMaximized) {
        guiSettings = new GuiSettings(width, height, x, y, isMaximized);
    }

    @Override
    public boolean equals(Object other) {
        // short circuit if same object
        // instanceof handles nulls
        return other == this
            || (other instanceof UserPrefs
            && (guiSettings.equals(((UserPrefs) other).guiSettings)
            && toDoListFilePath.getValue().equals(((UserPrefs) other).toDoListFilePath.getValue())));
    }

    @Override
    public int hashCode() {
        return Objects.hash(guiSettings, toDoListFilePath);
    }

    @Override
    public String toString() {
        return String.join(",",
            "Gui Settings: " + guiSettings,
            "To-do List File Path: " + toDoListFilePath.getValue()
        );
    }

    /**
     * @return a {@link JsonObject} which fully defines this instance's state
     */
    public JsonObject getJsonObject() {
        JsonObject jsonObject = new JsonObject();
        jsonObject.guiSettings = guiSettings;
        jsonObject.toDoListFilePath = toDoListFilePath.getValue();
        return jsonObject;
    }

    /**
     * Sets fields of user prefs to that of {@param jsonObject}.
     * If any of the fields are null, the default of user prefs are used.
     */
    public void setJsonObject(JsonObject jsonObject) {
        if (jsonObject.guiSettings != null) {
            guiSettings = jsonObject.guiSettings;
        }

        if (jsonObject.toDoListFilePath != null) {
            toDoListFilePath.setValue(jsonObject.toDoListFilePath);
        }
    }

    public static class JsonObject {
        public GuiSettings guiSettings;
        public String toDoListFilePath;
    }
}
```
