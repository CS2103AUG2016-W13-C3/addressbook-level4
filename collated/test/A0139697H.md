# A0139697H
###### \java\seedu\commando\logic\commands\AddCommandTest.java
``` java
public class AddCommandTest {
    @Rule
    public TemporaryFolder folder = new TemporaryFolder();

    private Logic logic;
    private EventsCollector eventsCollector;
    private LocalDateTime now = LocalDateTime.now();

    @Before
    public void setUp() throws IOException {
        logic = initLogic();
        eventsCollector = new EventsCollector();
    }

    @After
    public void tearDown() {
        EventsCenter.clearSubscribers();
    }

    @Test
    public void execute_addWithMissingTitle_error() {
        CommandResult result = logic.execute("add");
        assertTrue(result.hasError());
        assertEquals(Messages.MISSING_TODO_TITLE + "\n" + Messages.getCommandFormatMessage("add").get(), result.getFeedback());

        assertFalse(wasToDoListChangedEventPosted(eventsCollector));
    }

    @Test
    public void execute_addWithTitle_added() throws IllegalValueException {
        CommandResult result = logic.execute("add valid title");
        assertFalse(result.hasError());

        assertTrue(wasToDoListChangedEventPosted(eventsCollector));
        assertToDoExists(logic, new ToDoBuilder("valid title").build());
    }

    @Test
    public void execute_addWithTitleDueDate_added() throws IllegalValueException {
        CommandResult result = logic.execute("add valid title by 10 Feb 2016 11:59");
        assertFalse(result.hasError());

        assertTrue(wasToDoListChangedEventPosted(eventsCollector));
        assertToDoExists(logic,
            new ToDoBuilder("valid title")
                .withDueDate(LocalDateTime.of(2016, 2, 10, 11, 59))
                .build()
        );
    }

    @Test
    public void execute_addWithTitleDateRange_added() throws IllegalValueException {
        String command = "add valid title from 10 Dec 2016 11:59 to 11 Apr 2017 23:10";
        CommandResult result = logic.execute(command);
        assertFalse(result.hasError());

        assertTrue(wasToDoListChangedEventPosted(eventsCollector));
        assertToDoExists(logic,
            new ToDoBuilder("valid title")
                .withDateRange(
                    LocalDateTime.of(2016, 12, 10, 11, 59),
                    LocalDateTime.of(2017, 4, 11, 23, 10)
                )
                .build()
        );
    }

    @Test
    public void execute_addWithIllogicalDateRange_error() throws IllegalValueException {
        String command = "add valid title from 10 Dec 2017 11:59 to 11 Apr 2017 23:10";
        CommandResult result = logic.execute(command);
        assertTrue(result.hasError());
        assertEquals(Messages.TODO_DATERANGE_END_MUST_AFTER_START + "\n" + Messages.DATE_FORMAT + "\n" +
            Messages.getCommandFormatMessage("add").get(), result.getFeedback());
        assertFalse(wasToDoListChangedEventPosted(eventsCollector));
    }

    @Test
    public void execute_addWithMissingDateRangeStart_error() throws IllegalValueException {
        String command = "add valid title from not date to 11 Apr 2017 23:10";
        CommandResult result = logic.execute(command);
        assertTrue(result.hasError());
        assertEquals(Messages.INVALID_TODO_DATERANGE_START + "\n" + Messages.DATE_FORMAT + "\n" +
            Messages.getCommandFormatMessage("add").get(), result.getFeedback());
        assertFalse(wasToDoListChangedEventPosted(eventsCollector));
    }

    @Test
    public void execute_addWithMissingDateRangeEnd_error() throws IllegalValueException {
        String command = "add valid title from 11 Apr 2017 23:10 to not date";
        CommandResult result = logic.execute(command);
        assertTrue(result.hasError());
        assertEquals(Messages.INVALID_TODO_DATERANGE_END + "\n" + Messages.DATE_FORMAT + "\n" +
            Messages.getCommandFormatMessage("add").get(), result.getFeedback());
        assertFalse(wasToDoListChangedEventPosted(eventsCollector));
    }

    @Test
    public void execute_addWithTaskEndingWithBy_added() throws IllegalValueException {
        String command = "add task ending with by by 10 Oct 2016 10:10";
        CommandResult result = logic.execute(command);
        assertFalse(result.hasError());
        assertTrue(wasToDoListChangedEventPosted(eventsCollector));
        assertToDoExists(logic,
            new ToDoBuilder("task ending with by")
                .withDueDate(
                    LocalDateTime.of(2016, 10, 10, 10, 10)
                )
                .build()
        );
    }

    @Test
    public void execute_addWithInferredDateFromStart_added() throws IllegalValueException {
        String command = "add title from 10 Dec 2016 3pm to 7pm";
        CommandResult result = logic.execute(command);
        assertFalse(result.hasError());

        assertToDoExists(logic,
            new ToDoBuilder("title")
                .withDateRange(
                    LocalDateTime.of(2016, 12, 10, 15, 0),
                    LocalDateTime.of(2016, 12, 10, 19, 0)
                )
                .build()
        );
    }

    @Test
    public void execute_addWithTitleTags_added() throws IllegalValueException {
        String command = "add valid title #tag1 #tag2";
        CommandResult result = logic.execute(command);
        assertFalse(result.hasError());

        assertTrue(wasToDoListChangedEventPosted(eventsCollector));
        assertToDoExists(logic,
            new ToDoBuilder("valid title")
                .withTags(
                    "tag1", "tag2"
                )
                .build()
        );
    }

    @Test
    public void execute_addWithTitleDueDateTags_added() throws IllegalValueException {
        String command = "add valid title by 1 Mar 2016 20:01 #tag1 #tag2";
        CommandResult result = logic.execute(command);
        assertFalse(result.hasError());
        assertTrue(wasToDoListChangedEventPosted(eventsCollector));
        assertToDoExists(logic,
            new ToDoBuilder("valid title")
                .withTags(
                    "tag1", "tag2"
                )
                .withDueDate(
                    LocalDateTime.of(2016, 3, 1, 20, 1)
                )
                .build()
        );
    }

    @Test
    public void execute_addWithEmptyTag_added() throws IllegalValueException {
        CommandResult result = logic.execute("add title #    ");
        assertFalse(result.hasError());
        assertTrue(wasToDoListChangedEventPosted(eventsCollector));
        assertToDoExists(logic, new ToDoBuilder("title").build());
    }

    @Test
    public void execute_addWithTaskWithFromToBy_added() throws IllegalValueException {
        CommandResult result = logic.execute("add walk by the beach from here to there");
        assertFalse(result.hasError());
        assertTrue(wasToDoListChangedEventPosted(eventsCollector));
        assertToDoExists(logic,
            new ToDoBuilder("walk by the beach from here to there")
                .build()
        );
    }

    @Test
    public void execute_addWithEventWith2DateRanges_added() throws IllegalValueException {
        CommandResult result = logic.execute("add walk by the beach from today to tomorrow from 10 Nov 2011 1200h to 11 Dec 2012 1300h");
        assertFalse(result.hasError());
        assertTrue(wasToDoListChangedEventPosted(eventsCollector));
        assertToDoExists(logic,
            new ToDoBuilder("walk by the beach from today to tomorrow")
                .withDateRange(
                    LocalDateTime.of(2011, 11, 10, 12, 0),
                    LocalDateTime.of(2012, 12, 11, 13, 0)
                )
                .build()
        );
    }

    @Test
    public void execute_addWithDuplicate_error() throws IllegalValueException {
        logic.execute("add task by 10 Oct 2015");
        eventsCollector.reset();

        CommandResult result = logic.execute("add task by 10 Oct 2015");
        assertTrue(result.hasError());
        assertEquals(Messages.TODO_ALREADY_EXISTS, result.getFeedback());
        assertFalse(wasToDoListChangedEventPosted(eventsCollector));
    }

    @Test
    public void execute_addEventWithRecurrence_added() throws IllegalValueException {
        logic.execute("add event from 10 Oct 1200h to 11 Oct 1300h monthly");

        LocalDateTime startDate = LocalDateTime.of(now.getYear(), 10, 10, 12, 0);
        LocalDateTime endDate = LocalDateTime.of(now.getYear(), 10, 11, 13, 0);

        while (startDate.isBefore(LocalDateTime.now())) {
            startDate = startDate.plusMonths(1);
            endDate = endDate.plusMonths(1);
        }

        assertToDoExists(logic,
            new ToDoBuilder("event")
                .withDateRange(
                    startDate, endDate, Recurrence.Monthly
                )
                .build()
        );
    }

    @Test
    public void execute_addEventWithInvalidRecurrence_error() throws IllegalValueException {
        CommandResult result = logic.execute("add event from 10 Oct to 12 Oct daily");
        assertTrue(result.hasError());
        assertEquals(Messages.TODO_DATERANGE_RECURRENCE_INVALID + "\n" + Messages.DATE_FORMAT + "\n" +
            Messages.getCommandFormatMessage("add").get(), result.getFeedback());
        assertFalse(wasToDoListChangedEventPosted(eventsCollector));
    }

    @Test
    public void execute_addWithMissingStartEndDates_error() throws IllegalValueException {
        CommandResult result = logic.execute("add event from to 12 Oct");
        assertTrue(result.hasError());
        assertEquals(Messages.MISSING_TODO_DATERANGE_START + "\n" + Messages.DATE_FORMAT + "\n" +
            Messages.getCommandFormatMessage("add").get(), result.getFeedback());
        assertFalse(wasToDoListChangedEventPosted(eventsCollector));

        eventsCollector.reset();

        result = logic.execute("add event from 12 Oct to");
        assertTrue(result.hasError());
        assertEquals(Messages.MISSING_TODO_DATERANGE_END + "\n" + Messages.DATE_FORMAT + "\n" +
            Messages.getCommandFormatMessage("add").get(), result.getFeedback());
        assertFalse(wasToDoListChangedEventPosted(eventsCollector));
    }

    @Test
    public void execute_addWithQuotedTitle_added() throws IllegalValueException {
        CommandResult result = logic.execute("add `event from today to tomorrow`");
        assertFalse(result.hasError());
        assertTrue(wasToDoListChangedEventPosted(eventsCollector));
        assertToDoExists(logic,
            new ToDoBuilder("event from today to tomorrow")
                .build()
        );
    }

    @Test
    public void execute_addWithTrailingTextAfterQuotedTitle_error() throws IllegalValueException {
        CommandResult result = logic.execute("add `event from today to` tomorrow");
        assertTrue(result.hasError());
        assertFalse(wasToDoListChangedEventPosted(eventsCollector));
    }

    @Test
    public void execute_addWithEmptyQuotedTitle_error() throws IllegalValueException {
        CommandResult result = logic.execute("add `  ` from today to tomorrow");
        assertTrue(result.hasError());
        assertFalse(wasToDoListChangedEventPosted(eventsCollector));
        assertEquals(Messages.MISSING_TODO_TITLE + "\n" + Messages.ADD_COMMAND_FORMAT, result.getFeedback());
    }

    @Test
    public void execute_addWithDateRangeAndDueDate_error() throws IllegalValueException {
        CommandResult result = logic.execute("add eventask by tomorrow from today to tomorrow");
        assertTrue(result.hasError());
        assertFalse(wasToDoListChangedEventPosted(eventsCollector));
        assertEquals(Messages.TODO_CANNOT_HAVE_DUEDATE_AND_DATERANGE, result.getFeedback());
    }

    @Test
    public void execute_addOnDate_added() throws IllegalValueException {
        CommandResult result = logic.execute("add event on 23/11/2015");
        assertFalse(result.hasError());
        assertTrue(wasToDoListChangedEventPosted(eventsCollector));
        assertToDoExists(logic,
            new ToDoBuilder("event")
                .withDateRange(
                    LocalDateTime.of(2015, 11, 23, 0, 0),
                    LocalDateTime.of(2015, 11, 23, 23, 59)
                )
                .build()
        );
    }

    @Test
    public void execute_addOnDateTime_added() throws IllegalValueException {
        CommandResult result = logic.execute("add event on today 1.21pm");
        assertFalse(result.hasError());
        assertTrue(wasToDoListChangedEventPosted(eventsCollector));
        assertToDoExists(logic,
            new ToDoBuilder("event")
                .withDateRange(
                    LocalDateTime.now().withHour(13).withMinute(21),
                    LocalDateTime.now().withHour(23).withMinute(59)
                )
                .build()
        );
    }

    @Test
    public void execute_addTaskWithRecurringDeadline_added() throws IllegalValueException {
        CommandResult result = logic.execute("add task by tomorrow monthly");
        assertFalse(result.hasError());
        assertTrue(wasToDoListChangedEventPosted(eventsCollector));
        assertToDoExists(logic,
            new ToDoBuilder("task")
                .withDueDate(
                    LocalDateTime.now().plusDays(1).withHour(0).withMinute(0),
                    Recurrence.Monthly
                )
                .build()
        );
    }
}
```
###### \java\seedu\commando\logic\commands\ClearCommandTest.java
``` java
public class ClearCommandTest {

    @Rule
    public TemporaryFolder folder = new TemporaryFolder();
    
    private Logic logic;
    private EventsCollector eventsCollector;

    @Before
    public void setUp() throws IOException {
        logic = initLogic();
        eventsCollector = new EventsCollector();
    }

    @After
    public void tearDown() {
        EventsCenter.clearSubscribers();
    }
    
    @Test
    public void execute_clear_cleared() {
        logic.execute("add value from 10 Jan 1994 12:00 to 21 Jan 1994 13:00");
        logic.execute("add title2 #tag1 #tag2");

        eventsCollector.reset();
        assertFalse(wasToDoListChangedEventPosted(eventsCollector));
        assertTrue(logic.getToDoList().getToDos().size() == 2);

        CommandResult result = logic.execute("clear");
        assertFalse(result.hasError());
        assertTrue(wasToDoListChangedEventPosted(eventsCollector));
        assertTrue(logic.getToDoList().getToDos().size() == 0);
    }
}
```
###### \java\seedu\commando\logic\commands\CommandTest.java
``` java
public class CommandTest {
    @Rule
    public ExpectedException thrown = ExpectedException.none();

    private final String feedback = "Feedback";
    private Command command;
    private Model modelStub = new Model() {
        @Override
        public ReadOnlyToDoList getToDoList() {
            return null;
        }

        @Override
        public void changeToDoList(ToDoListChange change) throws IllegalValueException {

        }

        @Override
        public boolean undoToDoList() {
            return false;
        }

        @Override
        public boolean redoToDoList() {
            return false;
        }

        @Override
        public UnmodifiableObservableList<UiToDo> getUiEvents() {
            return null;
        }

        @Override
        public UnmodifiableObservableList<UiToDo> getUiTasks() {
            return null;
        }

        @Override
        public Optional<UiToDo> getUiToDoAtIndex(int index) {
            return null;
        }

        @Override
        public void clearUiToDoListFilter(Model.FILTER_MODE filterMode) {

        }

        @Override
        public void setUiToDoListFilter(Set<String> keywords, Set<Tag> tags, Model.FILTER_MODE filterMode) {

        }

		@Override
		public void setUiToDoListFilter(DateRange dateRange) {
			
		}
    };

    @Before
    public void setUp() {
        command = new Command() {
            @Override
            public CommandResult execute() throws NoModelException, NoEventsCenterException {
                if (getModel() == null) {
                    throw new NoModelException();
                }

                if (getEventsCenter() == null) {
                    throw new NoEventsCenterException();
                }

                return new CommandResult(feedback);
            }
        };
    }

    @Test
    public void setModel_onlyModel_exceptionThrown() throws Command.NoModelException, Command.NoEventsCenterException {
        thrown.expect(Command.NoEventsCenterException.class);
        command.setModel(modelStub);
        command.execute();
    }

    @Test
    public void setEventsCenter_onlyEventsCenter_exceptionThrown() throws Command.NoModelException, Command.NoEventsCenterException {
        thrown.expect(Command.NoModelException.class);
        command.setEventsCenter(EventsCenter.getInstance());
        command.execute();
    }

}
```
###### \java\seedu\commando\logic\commands\DeleteCommandTest.java
``` java
public class DeleteCommandTest {
    @Rule
    public TemporaryFolder folder = new TemporaryFolder();
    

    private Logic logic;
    private EventsCollector eventsCollector;
    private int nextYear = LocalDate.now().getYear() + 1;

    @Before
    public void setUp() throws IOException {
        logic = initLogic();
        eventsCollector = new EventsCollector();
    }

    @After
    public void tearDown() {
        EventsCenter.clearSubscribers();
    }

    @Test
    public void execute_deleteWithNoSuchIndex_error() {
        CommandResult result = logic.execute("delete 2");
        assertTrue(result.hasError());

        assertEquals(String.format(Messages.TODO_ITEM_INDEX_INVALID, 2), result.getFeedback());
    }

    @Test
    public void execute_deleteWithInvalidIndex_error() {
        CommandResult result = logic.execute("delete 0");
        assertTrue(result.hasError());

        assertEquals(String.format(Messages.TODO_ITEM_INDEX_INVALID, 0), result.getFeedback());
    }

    @Test
    public void execute_deleteWithInvalidIndex2_error() {
        CommandResult result = logic.execute("delete -1");
        assertTrue(result.hasError());

        assertEquals(String.format(Messages.TODO_ITEM_INDEX_INVALID, -1), result.getFeedback());
    }

    @Test
    public void execute_deleteWithInvalidFormat_error() {
        CommandResult result = logic.execute("delete 1 #troll");
        assertTrue(result.hasError());

        assertEquals(String.format(Messages.INVALID_COMMAND_FORMAT, DeleteCommand.COMMAND_WORD)
            + "\n" + Messages.getCommandFormatMessage("delete").get(), result.getFeedback());
    }

    @Test
    public void execute_deleteWithMissingIndex_error() {
        CommandResult result = logic.execute("delete missing index");
        assertTrue(result.hasError());

        assertEquals(Messages.MISSING_TODO_ITEM_INDEX
            + "\n" + Messages.getCommandFormatMessage("delete").get(), result.getFeedback());
    }

    @Test
    public void execute_delete_deleted() throws IllegalValueException {
        logic.execute("add title");
        logic.execute("add title2");

        eventsCollector.reset();
        assertFalse(wasToDoListChangedEventPosted(eventsCollector));

        assertToDoExists(logic,
            new ToDoBuilder("title2")
                .build());

        CommandResult result = logic.execute("delete 1");
        assertFalse(result.hasError());

        assertTrue(wasToDoListChangedEventPosted(eventsCollector));
        assertToDoNotExists(logic,
            new ToDoBuilder("title2")
                .build());
        assertToDoExists(logic,
            new ToDoBuilder("title")
                .build());
    }

    @Test
    public void execute_deleteTags_deletedTags() throws IllegalValueException {
        logic.execute("add title from 22 Oct 2014 1300h to 23 Oct 2016 1400h #tag1 #tag2");
        logic.execute("recall");
        
        eventsCollector.reset();

        CommandResult result = logic.execute("delete 1 tag");
        assertFalse(result.hasError());

        assertTrue(wasToDoListChangedEventPosted(eventsCollector));
        assertToDoExists(logic,
            new ToDoBuilder("title")
                .withDateRange(
                    LocalDateTime.of(2014, 10, 22, 13, 0),
                    LocalDateTime.of(2016, 10, 23, 14, 0)
                )
                .build());
    }
    
    @Test
    public void execute_deleteEndGreaterThanStartIndex_error() {
        logic.execute("add test 1");
        logic.execute("add test 2");
        
        eventsCollector.reset();
        
        CommandResult result = logic.execute("delete 2 to 1");
        assertTrue(result.hasError());
        assertEquals(Messages.INDEXRANGE_CONSTRAINTS + "\n" + Messages.DELETE_COMMAND_FORMAT, result.getFeedback());
    }

    @Test
    public void execute_deleteTagsButNoTags_error() throws IllegalValueException {
        logic.execute("add title by 10 Nov 2015 1200h");

        eventsCollector.reset();

        CommandResult result = logic.execute("delete 1 tag");
        assertTrue(result.hasError());
        assertEquals(String.format(Messages.DELETE_COMMAND_NO_TAGS, "1"), result.getFeedback());

        assertFalse(wasToDoListChangedEventPosted(eventsCollector));
        assertToDoExists(logic,
            new ToDoBuilder("title")
                .withDueDate(LocalDateTime.of(2015, 11, 10, 12, 0))
                .build());
    }

    @Test
    public void execute_deleteTimeButNoTime_error() throws IllegalValueException {
        logic.execute("add title #tag1");

        eventsCollector.reset();

        CommandResult result = logic.execute("delete 1 time");
        assertTrue(result.hasError());
        assertEquals(String.format(Messages.DELETE_COMMAND_NO_TIME_CONSTRAINTS, "1"), result.getFeedback());

        assertFalse(wasToDoListChangedEventPosted(eventsCollector));
        assertToDoExists(logic,
            new ToDoBuilder("title")
                .withTags("tag1")
                .build());
    }

    @Test
    public void execute_deleteTimeDueDate_deletedDueDate() throws IllegalValueException {
        logic.execute("add title by 23 Oct 2016");

        eventsCollector.reset();

        CommandResult result = logic.execute("delete 1 time");
        assertFalse(result.hasError());

        assertTrue(wasToDoListChangedEventPosted(eventsCollector));
        assertToDoExists(logic,
            new ToDoBuilder("title")
                .build());
    }

    @Test
    public void execute_deleteTimeDateRange_deletedDateRange() throws IllegalValueException {
        logic.execute("add title from 22 Oct 2016 to 23 Oct 2016 weekly #tag1");

        eventsCollector.reset();

        CommandResult result = logic.execute("delete 1 time");
        assertFalse(result.hasError());

        assertTrue(wasToDoListChangedEventPosted(eventsCollector));
        assertToDoExists(logic,
            new ToDoBuilder("title")
                .withTags("tag1")
                .build());
    }

    @Test
    public void execute_deleteInvalidFields_error() throws IllegalValueException {
        logic.execute("add title");

        eventsCollector.reset();

        CommandResult result = logic.execute("delete 1 invalid field");
        assertTrue(result.hasError());
        assertFalse(wasToDoListChangedEventPosted(eventsCollector));
        assertEquals(String.format(Messages.INVALID_COMMAND_FORMAT, DeleteCommand.COMMAND_WORD)
                + "\n" + Messages.getCommandFormatMessage("delete").get(), result.getFeedback() );
    }

    @Test
    public void execute_deleteTagsAndTime_deletedAll() throws IllegalValueException {
        logic.execute("add title from 22 Oct 2016 to 23 Oct 2016 weekly #tag1");

        eventsCollector.reset();

        CommandResult result = logic.execute("delete 1 time tag");
        assertFalse(result.hasError());

        assertTrue(wasToDoListChangedEventPosted(eventsCollector));
        assertToDoExists(logic,
            new ToDoBuilder("title")
                .build());
    }

    @Test
    public void execute_deleteRecurrence_deletedRecurrence() throws IllegalValueException {
        logic.execute("add title on 22 Oct " + nextYear +  " weekly");

        eventsCollector.reset();

        CommandResult result = logic.execute("delete 1 recurrence");
        assertFalse(result.hasError());

        assertTrue(wasToDoListChangedEventPosted(eventsCollector));
        assertToDoExists(logic,
            new ToDoBuilder("title")
                .withDateRange(
                    LocalDateTime.of(nextYear, 10, 22, 0, 0),
                    LocalDateTime.of(nextYear, 10, 22, 23, 59)
                )
                .build()
        );
    }

    @Test
    public void execute_deleteRecurrenceButNone_error() throws IllegalValueException {
        logic.execute("add title from 22 Oct 2016 to 23 Oct 2016 #tag1");
        logic.execute("recall");

        eventsCollector.reset();

        CommandResult result = logic.execute("delete 1 recurrence");
        assertTrue(result.hasError());
        assertFalse(wasToDoListChangedEventPosted(eventsCollector));
    }
    
```
###### \java\seedu\commando\logic\commands\EditCommandTest.java
``` java
public class EditCommandTest {
    @Rule
    public TemporaryFolder folder = new TemporaryFolder();

    private Logic logic;
    private EventsCollector eventsCollector;
    private int nextYear = LocalDateTime.now().getYear() + 1;

    @Before
    public void setUp() throws IOException {
        logic = initLogic();
        eventsCollector = new EventsCollector();
    }

    @After
    public void tearDown() {
        EventsCenter.clearSubscribers();
    }

    @Test
    public void execute_editNoSuchIndex_error() {
        CommandResult result = logic.execute("edit 2");
        assertTrue(result.hasError());

        assertEquals(String.format(Messages.TODO_ITEM_INDEX_INVALID, 2), result.getFeedback());
    }

    @Test
    public void execute_editInvalidIndex_error() {
        CommandResult result = logic.execute("edit 0");
        assertTrue(result.hasError());

        assertEquals(String.format(Messages.TODO_ITEM_INDEX_INVALID, 0), result.getFeedback());
    }

    @Test
    public void execute_editInvalidIndex2_error() {
        CommandResult result = logic.execute("edit -1");
        assertTrue(result.hasError());

        assertEquals(String.format(Messages.TODO_ITEM_INDEX_INVALID, -1), result.getFeedback());
    }

    @Test
    public void execute_editMissingIndex_error() {
        CommandResult result = logic.execute("edit missing index");
        assertTrue(result.hasError());

        assertEquals(Messages.MISSING_TODO_ITEM_INDEX
                + "\n" + Messages.getCommandFormatMessage("edit").get(), result.getFeedback());
    }

    @Test
    public void execute_editTitle_editedTitle() throws IllegalValueException {
        logic.execute("add title #tag");

        eventsCollector.reset();

        String command = "edit 1 new title";
        CommandResult result = logic.execute(command);
        assertFalse(result.hasError());

        assertTrue(wasToDoListChangedEventPosted(eventsCollector));
        assertToDoExists(logic,
            new ToDoBuilder("new title")
                .withTags("tag")
                .build());
    }

    @Test
    public void execute_editTags_editedTags() throws IllegalValueException {
        logic.execute("add title #tag1 #tag2");

        assertToDoExists(logic,
            new ToDoBuilder("title")
                .withTags("tag1", "tag2")
                .build());

        String command = "edit 1 #tag2 #tag3 #tag4";
        CommandResult result = logic.execute(command);
        assertFalse(result.hasError());

        assertTrue(wasToDoListChangedEventPosted(eventsCollector));
        assertToDoExists(logic,
            new ToDoBuilder("title")
                .withTags("tag2", "tag3", "tag4")
                .build());
    }

    @Test
    public void execute_editDueDate_editedDueDate() throws IllegalValueException {
        logic.execute("add title by 10 Jan " + nextYear + " 12:00");

        assertToDoExists(logic,
            new ToDoBuilder("title")
                .withDueDate(LocalDateTime.of(nextYear, 1, 10, 12, 0))
                .build());

        String command = "edit 1 by 11 Apr " + (nextYear + 1) + " 00:12";
        CommandResult result = logic.execute(command);
        assertFalse(result.hasError());

        assertTrue(wasToDoListChangedEventPosted(eventsCollector));
        assertToDoExists(logic,
            new ToDoBuilder("title")
                .withDueDate(LocalDateTime.of(nextYear + 1, 4, 11, 0, 12))
                .build());
    }

    @Test
    public void execute_editDateRange_editedDateRange() throws IllegalValueException {
        logic.execute("add title from 10 Jan " + nextYear + " 12:00 to 21 Jan " + nextYear + " 13:00");

        assertToDoExists(logic,
            new ToDoBuilder("title")
                .withDateRange(
                    LocalDateTime.of(nextYear, 1, 10, 12, 0),
                    LocalDateTime.of(nextYear, 1, 21, 13, 0)
                )
                .build());

        String command = "edit 1 from 10 Sep " + nextYear + " 12:15 to 21 Sep " + nextYear + " 13:45";
        CommandResult result = logic.execute(command);
        assertFalse(result.hasError());

        assertTrue(wasToDoListChangedEventPosted(eventsCollector));
        assertToDoExists(logic,
            new ToDoBuilder("title")
                .withDateRange(
                    LocalDateTime.of(nextYear, 9, 10, 12, 15),
                    LocalDateTime.of(nextYear, 9, 21, 13, 45)
                )
                .build());
    }

    @Test
    public void execute_editInvalidDateRange_error() throws IllegalValueException {
        logic.execute("add title from 11 Dec " + nextYear + " to 12 Dec " + nextYear);
        eventsCollector.reset();
        String command = "edit 1 from 10 Dec " + nextYear + " 11:59 to 11 Apr " + nextYear + " 23:10";
        CommandResult result = logic.execute(command);
        assertTrue(result.hasError());
        assertEquals(Messages.TODO_DATERANGE_END_MUST_AFTER_START + "\n" + Messages.DATE_FORMAT + "\n" + 
                Messages.getCommandFormatMessage("edit").get(), result.getFeedback());
        assertFalse(wasToDoListChangedEventPosted(eventsCollector));
    }

    @Test
    public void execute_editInferredDateFromStart_editedDateRange() throws IllegalValueException {
        logic.execute("add title from 11 Dec " + nextYear + " to 12 Dec " + nextYear + " ");
        String command = "edit 1 from 10 Dec " + nextYear + " 3pm to 7pm";
        CommandResult result = logic.execute(command);
        assertFalse(result.hasError());

        assertToDoExists(logic,
            new ToDoBuilder("title")
                .withDateRange(
                    LocalDateTime.of(nextYear, 12, 10, 15, 0),
                    LocalDateTime.of(nextYear, 12, 10, 19, 0)
                )
                .build());
    }

    @Test
    public void execute_editAddDueDateToEvent_error() throws IllegalValueException {
        logic.execute("add title from 11 Dec " + nextYear + " to 12 Dec " + nextYear);
        eventsCollector.reset();
        String command = "edit 1 by 13 Dec " + nextYear;
        CommandResult result = logic.execute(command);
        assertTrue(result.hasError());
        assertFalse(wasToDoListChangedEventPosted(eventsCollector));
        assertEquals(Messages.TODO_CANNOT_HAVE_DUEDATE_AND_DATERANGE, result.getFeedback());
    }

    @Test
    public void execute_editAddDateRangeToTaskWithDueDate_error() throws IllegalValueException {
        logic.execute("add title by 13 Dec " + nextYear);
        eventsCollector.reset();
        String command = "edit 1 from 11 Dec " + nextYear + " to 12 Dec " + nextYear;
        CommandResult result = logic.execute(command);
        assertTrue(result.hasError());
        assertFalse(wasToDoListChangedEventPosted(eventsCollector));
        assertEquals(Messages.TODO_CANNOT_HAVE_DUEDATE_AND_DATERANGE, result.getFeedback());
    }

    @Test
    public void execute_editDuplicatedTitle_error() throws IllegalValueException {
        logic.execute("add task");
        logic.execute("add task2");
        eventsCollector.reset();

        CommandResult result = logic.execute("edit 2 task2");
        assertTrue(result.hasError());
        assertEquals(Messages.TODO_ALREADY_EXISTS, result.getFeedback());
        assertFalse(wasToDoListChangedEventPosted(eventsCollector));

        assertToDoExists(logic,
            new ToDoBuilder("task")
                .build());
        assertToDoExists(logic,
            new ToDoBuilder("task2")
                .build());
    }

    @Test
    public void execute_editEventWith2DateRanges_editedTitleAndDateRange() throws IllegalValueException {
        logic.execute("add title from 10 Jan " + nextYear + " 12:00 to 21 Jan " + nextYear + " 13:00");

        logic.execute("edit 1 from today to tomorrow from 10 Nov 2011 1200h to 11 Dec 2012 1300h");
        assertToDoExists(logic,
            new ToDoBuilder("from today to tomorrow")
                .withDateRange(
                    LocalDateTime.of(2011, 11, 10, 12, 0),
                    LocalDateTime.of(2012, 12, 11, 13, 0)
                )
                .build());
    }


    @Test
    public void execute_editQuotedTitleWithBy_editedTitle() throws IllegalValueException {
        logic.execute("add title #tag");

        eventsCollector.reset();

        CommandResult result = logic.execute("edit 1 `by tomorrow`");
        assertFalse(result.hasError());
        assertTrue(wasToDoListChangedEventPosted(eventsCollector));
        assertToDoExists(logic,
            new ToDoBuilder("by tomorrow")
                .withTags("tag")
                .build());
    }

    @Test
    public void execute_editQuotedTitleWithFromTo_editedTitle() throws IllegalValueException {
        logic.execute("add title from 10 Jan " + nextYear + " 12:00 to 21 Jan " + nextYear + " 13:00");

        eventsCollector.reset();

        String command = "edit 1 `from today to tomorrow`"
            + "from 10 Feb " + nextYear + " 12:15 to 21 Feb " + nextYear + " 13:45";
        CommandResult result = logic.execute(command);
        assertFalse(result.hasError());
        assertTrue(wasToDoListChangedEventPosted(eventsCollector));
        assertToDoExists(logic,
            new ToDoBuilder("from today to tomorrow")
                .withDateRange(
                    LocalDateTime.of(nextYear, 2, 10, 12, 15),
                    LocalDateTime.of(nextYear, 2, 21, 13, 45)
                )
                .build());
    }

    @Test
    public void execute_editWithTrailingTextAfterQuotedTitle_error() throws IllegalValueException {
        logic.execute("add title");

        eventsCollector.reset();

        String command = "edit 1 `from today to tomorrow` 13:45";
        CommandResult result = logic.execute(command);
        assertTrue(result.hasError());
        assertFalse(wasToDoListChangedEventPosted(eventsCollector));
    }

    @Test
    public void execute_editEmptyQuotedTitle_error() throws IllegalValueException {
        logic.execute("add title");

        eventsCollector.reset();

        CommandResult result = logic.execute("edit 1 ``");
        assertTrue(result.hasError());
        assertFalse(wasToDoListChangedEventPosted(eventsCollector));
        assertEquals(Messages.MISSING_TODO_TITLE + "\n" + Messages.EDIT_COMMAND_FORMAT, result.getFeedback());
    }


    @Test
    public void execute_editNoEdits_error() throws IllegalValueException {
        logic.execute("add task");

        eventsCollector.reset();

        CommandResult result = logic.execute("edit 1");
        assertTrue(result.hasError());
        assertEquals(Messages.EDIT_COMMAND_NO_EDITS, result.getFeedback());
    }

    @Test
    public void execute_editOnDateTime_edited() throws IllegalValueException {
        logic.execute("add event on 10 Jan " + nextYear);

        eventsCollector.reset();

        String command = "edit 1 on 10 Sep " + nextYear + " 11:33am";
        CommandResult result = logic.execute(command);
        assertFalse(result.hasError());

        assertTrue(wasToDoListChangedEventPosted(eventsCollector));
        assertToDoExists(logic,
            new ToDoBuilder("event")
                .withDateRange(
                    LocalDateTime.of(nextYear, 9, 10, 11, 33),
                    LocalDateTime.of(nextYear, 9, 10, 23, 59)
                )
                .build());
    }

    @Test
    public void execute_addTaskWithRecurringDeadline_added() throws IllegalValueException {
        logic.execute("add task by 10 Jan " + nextYear);

        eventsCollector.reset();

        CommandResult result = logic.execute("add task by 11 April " + nextYear + " weekly");
        assertFalse(result.hasError());
        assertTrue(wasToDoListChangedEventPosted(eventsCollector));
        assertToDoExists(logic,
            new ToDoBuilder("task")
                .withDueDate(
                    LocalDateTime.of(nextYear, 4, 11, 0, 0),
                    Recurrence.Weekly
                )
                .build()
        );
    }
}
```
###### \java\seedu\commando\logic\commands\FindCommandTest.java
``` java
public class FindCommandTest {
    @Rule
    public TemporaryFolder folder = new TemporaryFolder();

    private Logic logic;
    private EventsCollector eventsCollector;

    @Before
    public void setUp() throws IOException {
        logic = initLogic();
        eventsCollector = new EventsCollector();
    }

    @After
    public void tearDown() {
        EventsCenter.clearSubscribers();
    }

    @Test
    public void execute_findKeywords_filtered() throws IllegalValueException {
        logic.execute("add Title"); // case insensitivity
        logic.execute("add title2"); // superstrings
        logic.execute("add title 3");
        logic.execute("add somethingelse");

        eventsCollector.reset();
        assertFalse(wasToDoListChangedEventPosted(eventsCollector));

        CommandResult result = logic.execute("find title");
        assertFalse(result.hasError());

        assertFalse(wasToDoListChangedEventPosted(eventsCollector));

        assertToDoExistsFiltered(logic,
            new ToDoBuilder("Title")
                .build());
        assertToDoExistsFiltered(logic,
            new ToDoBuilder("title2")
                .build());
        assertToDoExistsFiltered(logic,
            new ToDoBuilder("title 3")
                .build());
        assertToDoNotExistsFiltered(logic,
            new ToDoBuilder("somethingelse")
                .build());
    }

    @Test
    public void execute_findTagsWithKeywords_filtered() throws IllegalValueException {
        logic.execute("add title #tag");
        logic.execute("add somethingelse");

        eventsCollector.reset();
        assertFalse(wasToDoListChangedEventPosted(eventsCollector));

        CommandResult result = logic.execute("find tag");
        assertFalse(result.hasError());

        assertFalse(wasToDoListChangedEventPosted(eventsCollector));

        assertToDoExistsFiltered(logic,
            new ToDoBuilder("title")
                .withTags("tag")
                .build());
        assertToDoNotExistsFiltered(logic,
            new ToDoBuilder("somethingelse")
                .build());
    }

    @Test
    public void execute_findTags_filtered() throws IllegalValueException {
        logic.execute("add Title #Tag"); // case insensitivity
        logic.execute("add title2 #tag2"); // superstrings
        logic.execute("add title 3 #tag #tag2"); // multiple tags
        logic.execute("add tag"); // title with tag
        logic.execute("add somethingelse");

        eventsCollector.reset();
        assertFalse(wasToDoListChangedEventPosted(eventsCollector));

        CommandResult result = logic.execute("find #tag");
        assertFalse(result.hasError());

        assertFalse(wasToDoListChangedEventPosted(eventsCollector));

        assertToDoExistsFiltered(logic,
            new ToDoBuilder("Title")
                .withTags("Tag")
                .build());
        assertToDoNotExistsFiltered(logic,
            new ToDoBuilder("Title2")
                .withTags("tag2")
                .build());
        assertToDoExistsFiltered(logic,
            new ToDoBuilder("title 3")
                .withTags("tag", "tag2")
                .build());
        assertToDoNotExistsFiltered(logic,
            new ToDoBuilder("tag")
                .build());
        assertToDoNotExistsFiltered(logic,
            new ToDoBuilder("somethingelse")
                .build());
    }


    @Test
    public void execute_findMultipleTags_filtered() throws IllegalValueException {
        logic.execute("add title #tag");
        logic.execute("add title2 #tag #tag2");
        logic.execute("add title3 #tag #tag2 #tag3");

        eventsCollector.reset();
        assertFalse(wasToDoListChangedEventPosted(eventsCollector));

        CommandResult result = logic.execute("find #tag #tag2");
        assertFalse(result.hasError());

        assertFalse(wasToDoListChangedEventPosted(eventsCollector));

        assertToDoNotExistsFiltered(logic,
            new ToDoBuilder("title")
                .withTags("tag")
                .build());
        assertToDoExistsFiltered(logic,
            new ToDoBuilder("title2")
                .withTags("tag", "tag2")
                .build());
        assertToDoExistsFiltered(logic,
            new ToDoBuilder("title3")
                .withTags("tag", "tag2", "tag3")
                .build());
    }

    @Test
    public void execute_findKeywordsWithTags_filtered() throws IllegalValueException {
        logic.execute("add title #tag");
        logic.execute("add title3 #tag #tag2");
        logic.execute("add title3");

        eventsCollector.reset();
        assertFalse(wasToDoListChangedEventPosted(eventsCollector));

        CommandResult result = logic.execute("find title 3 #tag");
        assertFalse(result.hasError());

        assertFalse(wasToDoListChangedEventPosted(eventsCollector));

        assertToDoNotExistsFiltered(logic,
            new ToDoBuilder("title")
                .withTags("tag")
                .build());
        assertToDoExistsFiltered(logic,
            new ToDoBuilder("title3")
                .withTags("tag", "tag2")
                .build());
        assertToDoNotExistsFiltered(logic,
            new ToDoBuilder("title3")
                .build());
    }
}
```
###### \java\seedu\commando\logic\commands\FinishCommandTest.java
``` java
public class FinishCommandTest {
    @Rule
    public TemporaryFolder folder = new TemporaryFolder();

    private Logic logic;
    private EventsCollector eventsCollector;
    private LocalDateTime now = LocalDateTime.now();

    @Before
    public void setUp() throws IOException {
        logic = initLogic();
        eventsCollector = new EventsCollector();
    }

    @After
    public void tearDown() {
        EventsCenter.clearSubscribers();
    }

    @Test
    public void execute_finishNoSuchIndex_error() {
        CommandResult result = logic.execute("delete 2");
        assertTrue(result.hasError());

        assertEquals(String.format(Messages.TODO_ITEM_INDEX_INVALID, 2), result.getFeedback());
    }

    @Test
    public void execute_finishInvalidIndex_error() {
        CommandResult result = logic.execute("finish 0");
        assertTrue(result.hasError());

        assertEquals(String.format(Messages.TODO_ITEM_INDEX_INVALID, 0), result.getFeedback());
    }
    
    @Test
    public void execute_finishInvalidIndex2_error() {
        CommandResult result = logic.execute("finish -1");
        assertTrue(result.hasError());

        assertEquals(String.format(Messages.TODO_ITEM_INDEX_INVALID, -1), result.getFeedback());
    }

    @Test
    public void execute_finishMissingIndex_error() {
        CommandResult result = logic.execute("finish missing index");
        assertTrue(result.hasError());

        assertEquals(Messages.MISSING_TODO_ITEM_INDEX + "\n" + Messages.getCommandFormatMessage("finish").get(), result.getFeedback());
    }

    @Test
    public void execute_finishInvalidFormat_error() {
        CommandResult result = logic.execute("finish 1 #troll");
        assertTrue(result.hasError());

        assertEquals(String.format(Messages.INVALID_COMMAND_FORMAT, FinishCommand.COMMAND_WORD)
                + "\n" + Messages.getCommandFormatMessage("finish").get(), result.getFeedback());
    }

    @Test
    public void execute_finish_finished() throws IllegalValueException {
        logic.execute("add title");
        logic.execute("add title2");

        eventsCollector.reset();
        assertFalse(wasToDoListChangedEventPosted(eventsCollector));

        assertToDoExists(logic,
            new ToDoBuilder("title2")
                .build());

        CommandResult result = logic.execute("finish 2");
        assertFalse(result.hasError());

        assertTrue(wasToDoListChangedEventPosted(eventsCollector));
        assertToDoExists(logic,
            new ToDoBuilder("title2")
                .build());
        assertToDoExists(logic,
            new ToDoBuilder("title")
                .build());
    }

    @Test
    public void execute_finishFinishedTask_error() throws IllegalValueException {
        logic.execute("add title");
        logic.execute("finish 1");

        eventsCollector.reset();

        CommandResult result = logic.execute("finish 1");
        assertTrue(result.hasError());
        assertFalse(wasToDoListChangedEventPosted(eventsCollector));
    }

    @Test
    public void execute_finishEvent_error() throws IllegalValueException {
        logic.execute("add event from today to tomorrow");

        eventsCollector.reset();

        CommandResult result = logic.execute("finish 1");
        assertTrue(result.hasError());
        assertFalse(wasToDoListChangedEventPosted(eventsCollector));
    }
    
```
###### \java\seedu\commando\logic\commands\HelpCommandTest.java
``` java
public class HelpCommandTest {
    @Rule
    public TemporaryFolder folder = new TemporaryFolder();
    
    private Logic logic;
    private EventsCollector eventsCollector;

    @Before
    public void setUp() throws IOException {
        logic = initLogic();
        eventsCollector = new EventsCollector();
    }

    @After
    public void tearDown() {
        EventsCenter.clearSubscribers();
    }
    

    @Test
    public void execute_help_eventPosted() {
        logic.execute("help");
        assertTrue(wasShowHelpRequestEventPosted(eventsCollector));
    }

    @Test
    public void execute_helpWithWord_eventPosted() {
        logic.execute("help add");
        assertTrue(wasShowHelpRequestEventPosted(eventsCollector));
    }

    @Test
    public void execute_helpWithInvalidWord_error() {
        CommandResult result = logic.execute("help invalid word");
        assertTrue(result.hasError());
        assertEquals(String.format(Messages.HELP_COMMAND_INVALID_TOPIC, "invalid word"), result.getFeedback());
        assertFalse(wasShowHelpRequestEventPosted(eventsCollector));
    }
}
```
###### \java\seedu\commando\logic\commands\RecallCommandTest.java
``` java
public class RecallCommandTest {
    @Rule
    public TemporaryFolder folder = new TemporaryFolder();

    private Logic logic;
    private EventsCollector eventsCollector;

    @Before
    public void setUp() throws IOException {
        logic = initLogic();
        eventsCollector = new EventsCollector();
    }

    @After
    public void tearDown() {
        EventsCenter.clearSubscribers();
    }
    
    @Test
    public void execute_recallKeywords_filtered() throws IllegalValueException {
        logic.execute("add Title"); // case insensitivity
        logic.execute("add title2"); // superstrings
        logic.execute("add title 3"); // spaces
        logic.execute("add somethingelse");
        
        logic.execute("finish 1");
        logic.execute("finish 1");
        logic.execute("finish 1");
        logic.execute("finish 1");

        eventsCollector.reset();
        assertFalse(wasToDoListChangedEventPosted(eventsCollector));

        CommandResult result = logic.execute("recall title");
        assertFalse(result.hasError());

        assertFalse(wasToDoListChangedEventPosted(eventsCollector));
        
        assertToDoExistsFiltered(logic,
            new ToDoBuilder("Title")
                .build());
        assertToDoExistsFiltered(logic,
            new ToDoBuilder("title2")
                .build());
        assertToDoExistsFiltered(logic,
            new ToDoBuilder("title 3")
                .build());
        assertToDoNotExistsFiltered(logic,
            new ToDoBuilder("somethingelse")
                .build());
    }
    
    @Test
    public void execute_recallTagsWithKeywords_filtered() throws IllegalValueException {
        logic.execute("add title #tag");
        logic.execute("add somethingelse");
        
        logic.execute("finish 1");
        logic.execute("finish 1");

        eventsCollector.reset();
        assertFalse(wasToDoListChangedEventPosted(eventsCollector));

        CommandResult result = logic.execute("recall tag");
        assertFalse(result.hasError());

        assertFalse(wasToDoListChangedEventPosted(eventsCollector));

        assertToDoExistsFiltered(logic,
            new ToDoBuilder("title")
                .withTags("tag")
                .build());
        assertToDoNotExistsFiltered(logic,
            new ToDoBuilder("somethingelse")
                .build());
    }

    @Test
    public void execute_recallTags_filtered() throws IllegalValueException {
        logic.execute("add Title #Tag"); // case insensitivity
        logic.execute("add title2 #tag2"); // superstrings
        logic.execute("add title 3 #tag #tag2"); // multiple tags
        logic.execute("add tag"); // title with tag
        logic.execute("add somethingelse");
        
        logic.execute("finish 1");
        logic.execute("finish 1");
        logic.execute("finish 1");
        logic.execute("finish 1");
        logic.execute("finish 1");

        eventsCollector.reset();
        assertFalse(wasToDoListChangedEventPosted(eventsCollector));

        CommandResult result = logic.execute("recall #tag");
        assertFalse(result.hasError());

        assertFalse(wasToDoListChangedEventPosted(eventsCollector));

        assertToDoExistsFiltered(logic,
            new ToDoBuilder("Title")
                .withTags("Tag")
                .build());
        assertToDoNotExistsFiltered(logic,
            new ToDoBuilder("Title2")
                .withTags("tag2")
                .build());
        assertToDoExistsFiltered(logic,
            new ToDoBuilder("title 3")
                .withTags("tag", "tag2")
                .build());
        assertToDoNotExistsFiltered(logic,
            new ToDoBuilder("tag")
                .build());
        assertToDoNotExistsFiltered(logic,
            new ToDoBuilder("somethingelse")
                .build());
    }


    @Test
    public void execute_find_multipleTags() throws IllegalValueException {
        logic.execute("add title #tag");
        logic.execute("add title2 #tag #tag2");
        logic.execute("add title3 #tag #tag2 #tag3");
        
        logic.execute("finish 1");
        logic.execute("finish 1");
        logic.execute("finish 1");

        eventsCollector.reset();
        assertFalse(wasToDoListChangedEventPosted(eventsCollector));

        CommandResult result = logic.execute("recall #tag #tag2");
        assertFalse(result.hasError());

        assertFalse(wasToDoListChangedEventPosted(eventsCollector));

        assertToDoNotExistsFiltered(logic,
            new ToDoBuilder("title")
                .withTags("tag")
                .build());
        assertToDoExistsFiltered(logic,
            new ToDoBuilder("title2")
                .withTags("tag", "tag2")
                .build());
        assertToDoExistsFiltered(logic,
            new ToDoBuilder("title3")
                .withTags("tag", "tag2", "tag3")
                .build());
    }

    @Test
    public void execute_find_keywordsWithTags() throws IllegalValueException {
        logic.execute("add title #tag");
        logic.execute("add title3 #tag #tag2");
        logic.execute("add title3");
        
        logic.execute("finish 1");
        logic.execute("finish 1");
        logic.execute("finish 1");

        eventsCollector.reset();
        assertFalse(wasToDoListChangedEventPosted(eventsCollector));

        CommandResult result = logic.execute("recall title 3 #tag");
        assertFalse(result.hasError());

        assertFalse(wasToDoListChangedEventPosted(eventsCollector));

        assertToDoNotExistsFiltered(logic,
            new ToDoBuilder("title")
                .withTags("tag")
                .build());
        assertToDoExistsFiltered(logic,
            new ToDoBuilder("title3")
                .withTags("tag", "tag2")
                .build());
        assertToDoNotExistsFiltered(logic,
            new ToDoBuilder("title3")
                .build());
    }
}
```
###### \java\seedu\commando\logic\commands\UndoRedoCommandsTest.java
``` java
public class UndoRedoCommandsTest {
    @Rule
    public TemporaryFolder folder = new TemporaryFolder();

    private Logic logic;
    private EventsCollector eventsCollector;

    @Before
    public void setUp() throws IOException {
        logic = initLogic();
        eventsCollector = new EventsCollector();
    }

    @After
    public void tearDown() {
        EventsCenter.clearSubscribers();
    }

    @Test
    public void execute_undoAndRedoInvalidFormat_error() {
        CommandResult result = logic.execute("undo 2");
        assertTrue(result.hasError());
        assertEquals(String.format(Messages.INVALID_COMMAND_FORMAT, UndoCommand.COMMAND_WORD), result.getFeedback());

        result = logic.execute("redo 2");
        assertTrue(result.hasError());
        assertEquals(String.format(Messages.INVALID_COMMAND_FORMAT, RedoCommand.COMMAND_WORD), result.getFeedback());
    }

    @Test
    public void execute_undoMultiple_undone() {
        logic.execute("add title");
        logic.execute("add test 3");
        logic.execute("delete 2");
        logic.execute("edit 1 titlereplaced");

        assertTrue(logic.getUiTasks().size() == 1);

        CommandResult result = logic.execute("undo");
        assertFalse(result.hasError());
        assertTrue(logic.getUiTasks().size() == 1);

        result = logic.execute("undo");
        assertFalse(result.hasError());
        assertTrue(logic.getUiTasks().size() == 2);

        result = logic.execute("undo");
        assertFalse(result.hasError());
        assertTrue(logic.getUiTasks().size() == 1);

        result = logic.execute("undo");
        assertFalse(result.hasError());
        assertTrue(logic.getUiTasks().size() == 0);

        result = logic.execute("undo");
        assertTrue(result.hasError());
        assertEquals(Messages.UNDO_COMMAND_FAIL, result.getFeedback());
    }

    @Test
    public void execute_redoMultiple_redone() {
        logic.execute("add title");
        logic.execute("add title2");
        logic.execute("undo");

        assertTrue(logic.getUiTasks().size() == 1);

        CommandResult result = logic.execute("redo");
        assertFalse(result.hasError());
        assertTrue(logic.getUiTasks().size() == 2);

        result = logic.execute("redo");
        assertTrue(result.hasError());
        assertEquals(Messages.REDO_COMMAND_FAIL, result.getFeedback());
        assertTrue(logic.getUiTasks().size() == 2);
    }

    @Test
    public void execute_undoEditUndoRedo_undoneRedone() {
        logic.execute("add title");
        logic.execute("add title2");
        logic.execute("undo");
        logic.execute("add title3");

        assertTrue(logic.getUiTasks().size() == 2);

        eventsCollector.reset();

        CommandResult result = logic.execute("undo");
        assertFalse(result.hasError());
        assertTrue(logic.getUiTasks().size() == 1);

        result = logic.execute("undo");
        assertFalse(result.hasError());
        assertTrue(logic.getUiTasks().size() == 0);

        result = logic.execute("undo");
        assertTrue(result.hasError());
        assertEquals(Messages.UNDO_COMMAND_FAIL, result.getFeedback());
        assertTrue(logic.getUiTasks().size() == 0);

        result = logic.execute("redo");
        assertFalse(result.hasError());
        assertTrue(logic.getUiTasks().size() == 1);

        result = logic.execute("redo");
        assertFalse(result.hasError());
        assertTrue(logic.getUiTasks().size() == 2);

        result = logic.execute("redo");
        assertTrue(result.hasError());
        assertEquals(Messages.REDO_COMMAND_FAIL, result.getFeedback());
        assertTrue(logic.getUiTasks().size() == 2);
    }

    @Test
    public void execute_undoClearAndEdit_clearedAndEdited() throws IllegalValueException {
        logic.execute("add title");
        logic.execute("add title2");
        logic.execute("clear");
        logic.execute("add title3");
        logic.execute("clear");

        CommandResult result = logic.execute("undo");
        assertFalse(result.hasError());
        assertTrue(logic.getUiTasks().size() == 1);

        result = logic.execute("edit 1 title4");
        assertFalse(result.hasError());
        assertTrue(logic.getUiTasks().size() == 1);

        result = logic.execute("redo");
        assertTrue(result.hasError());
        assertEquals(Messages.REDO_COMMAND_FAIL, result.getFeedback());
        assertTrue(logic.getUiTasks().size() == 1);

        result = logic.execute("undo");
        assertFalse(result.hasError());
        assertToDoExists(logic,
            new ToDoBuilder("title3")
                .build());

        result = logic.execute("undo");
        assertFalse(result.hasError());
        assertTrue(logic.getUiTasks().size() == 0);

        result = logic.execute("undo");
        assertFalse(result.hasError());
        assertTrue(logic.getUiTasks().size() == 2);

        result = logic.execute("undo");
        assertFalse(result.hasError());
        assertTrue(logic.getUiTasks().size() == 1);

        result = logic.execute("undo");
        assertFalse(result.hasError());
        assertTrue(logic.getUiTasks().size() == 0);
    }
}
```
###### \java\seedu\commando\logic\LogicManagerTest.java
``` java
/**
 * Contains tests for LogicManager
 * More tests for specific command words might also be in {@link seedu.commando.logic.commands}
 */
public class LogicManagerTest {
    
    /**
     * See https://github.com/junit-team/junit4/wiki/rules#temporaryfolder-rule
     */
    
    private LogicManager logic;
    private EventsCollector eventsCollector;
    private static Storage storage;

    @Before
    public void setUp() throws IOException {
        eventsCollector = new EventsCollector();
        logic = initLogic();
    }

    @After
    public void tearDown() {
        EventsCenter.clearSubscribers();
    }

    public static LogicManager initLogic() throws IOException {
        Model model = new ModelManager();
        storage = new StorageStub();
        return new LogicManager(model, storage, new UserPrefs());
    }

    @Test
    public void execute_emptyString_error() {
        CommandResult result = logic.execute("");
        assertTrue(result.hasError());
        assertEquals(Messages.MISSING_COMMAND_WORD, result.getFeedback());
    }

    @Test
    public void execute_unknownCommand_error() {
        CommandResult result = logic.execute("unknownCommand");
        assertTrue(result.hasError());
        assertEquals(String.format(Messages.UNKNOWN_COMMAND, "unknowncommand"), result.getFeedback());
    }

    @Test
    public void handleToDoListChangedEvent_toDoListChanged_eventsPosted() {
        logic.handleToDoListChangedEvent(new ToDoListChangedEvent(new ToDoList()));
        assertTrue(eventsCollector.hasCollectedEvent(StorageStub.ToDoListSavedEvent.class));

    }
    
    @Test
    public void handleToDoListChangedEvent_mockStorage_throwsException() throws IOException {
        Storage mockedStorage = Mockito.mock(StorageManager.class);
        logic = new LogicManager(new ModelManager(), mockedStorage, new UserPrefs());
        Mockito.doThrow(new IOException()).when(mockedStorage).saveToDoList(new ToDoList());
        logic.handleToDoListChangedEvent(new ToDoListChangedEvent(new ToDoList()));
        assertTrue(eventsCollector.hasCollectedEvent(DataSavingExceptionEvent.class));
    }

}
```
###### \java\seedu\commando\logic\parser\CommandParserTest.java
``` java
public class CommandParserTest {
    @Rule
    public ExpectedException thrown = ExpectedException.none();

    private CommandParser commandParser = new CommandParser();

    private static int nextYear = LocalDateTime.now().getYear() + 1;

    @Test
    public void extractText_emptyString_empty()  {
        commandParser.setInput("");
        assertFalse(commandParser.extractText().isPresent());
    }

    @Test
    public void extractText_valid_extracted()  {
        commandParser.setInput("valid text");
        assertEquals("valid text", commandParser.extractText().orElse(""));
        assertEquals("", commandParser.getInput());
    }

    @Test
    public void extractText_whitespace_trimmed()  {
        commandParser.setInput(" trims   ");
        assertEquals("trims", commandParser.extractText().orElse(""));
        assertEquals("", commandParser.getInput());
    }

    @Test
    public void extractWords_noWords_empty()  {
        commandParser.setInput("");
        assertTrue(commandParser.extractWords().isEmpty());
    }

    @Test
    public void extractWords_1Word_extracted()  {
        commandParser.setInput("1Word");
        assertEquals(Arrays.asList("1Word"), commandParser.extractWords());
        assertEquals("", commandParser.getInput());
    }

    @Test
    public void extractWords_2Words_extracted()  {
        commandParser.setInput("2 words");
        assertEquals(Arrays.asList("2", "words"), commandParser.extractWords());
        assertEquals("", commandParser.getInput());
    }

    @Test
    public void extractWord_2Words_firstWordExtracted()  {
        commandParser.setInput("command word");
        assertEquals("command", commandParser.extractWord().orElse(""));
        assertEquals("word", commandParser.getInput().trim());
    }

    @Test
    public void extractInteger_noInteger_empty()  {
        commandParser.setInput("no index");
        assertFalse(commandParser.extractInteger().isPresent());
        assertEquals("no index", commandParser.getInput());
    }

    @Test
    public void extractInteger_anyInteger_extracted()  {
        commandParser.setInput("1 index");
        assertTrue(1 == commandParser.extractInteger().orElse(-1));
        assertEquals("index", commandParser.getInput());

        commandParser.setInput("0 index");
        assertTrue(0 == commandParser.extractInteger().orElse(-1));
        assertEquals("index", commandParser.getInput());

        commandParser.setInput("-2 index");
        assertTrue(-2 == commandParser.extractInteger().orElse(-1));
        assertEquals("index", commandParser.getInput());
    }

    @Test
    public void extractTrailingTags_noMatches_empty()  {
        commandParser.setInput("no matches");
        assertTrue(commandParser.extractTrailingTags().isEmpty());
        assertEquals("no matches", commandParser.getInput());
    }

    @Test
    public void extractTrailingTags_allTags_extracted()  {
        commandParser.setInput("#tag1 #tag2 #tag3");
        assertEquals(
            Sets.newHashSet(new Tag("tag1"), new Tag("tag2"), new Tag("tag3")),
            commandParser.extractTrailingTags()
        );
        assertEquals("", commandParser.getInput().trim());
    }

    @Test
    public void extractTrailingTags_notTrailing_empty()  {
        commandParser.setInput("other #tag1 #tag2 words");
        assertEquals(Collections.emptySet(), commandParser.extractTrailingTags());
        assertEquals("other #tag1 #tag2 words", commandParser.getInput());
    }


    @Test
    public void extractTrailingTags_nonTrailingTags_onlyTrailingTagExtracted()  {
        commandParser.setInput("other #tag1 words #tag2");
        assertEquals(Sets.newHashSet(new Tag("tag2")), commandParser.extractTrailingTags());
        assertEquals("other #tag1 words", commandParser.getInput());
    }

    @Test
    public void extractTrailingDueDate_valid_extracted() throws IllegalValueException {
        commandParser.setInput("extract text by 10 Nov 2015");

        Optional<DueDate> dueDate = commandParser.extractTrailingDueDate();

        assertTrue(dueDate.isPresent());
        assertEquals(
            new DueDate(LocalDateTime.of(2015, 11, 10, 0, 0)),
            dueDate.get()
        );

        assertEquals("extract text", commandParser.getInput());
    }

    @Test
    public void extractTrailingDueDate_invalidDate_empty() throws IllegalValueException {
        commandParser.setInput("extract text by invalid date");
        assertFalse(commandParser.extractTrailingDueDate().isPresent());
        assertEquals("extract text by invalid date", commandParser.getInput());
    }

    @Test
    public void extractTrailingDueDate_notTrailing_empty() throws IllegalValueException {
        commandParser.setInput("extract text by 10 Nov 2015 #nottrailing");
        assertFalse(commandParser.extractTrailingDueDate().isPresent());
        assertEquals("extract text by 10 Nov 2015 #nottrailing", commandParser.getInput());
    }

    @Test
    public void extractTrailingTwoSidedDateRange_valid_extracted() throws IllegalValueException {
        commandParser.setInput("from 10 Apr 2016 9am to 11 Jan 2018 10:28");
        Optional<DateRange> dateRange = commandParser.extractTrailingTwoSidedDateRange();
        assertTrue(dateRange.isPresent());
        assertEquals(
            LocalDateTime.of(2016, 4, 10, 9, 0),
            dateRange.get().startDate
        );
        assertEquals(
            LocalDateTime.of(2018, 1, 11, 10, 28),
            dateRange.get().endDate
        );
        assertEquals("", commandParser.getInput());
    }

    @Test
    public void extractTrailingTwoSidedDateRange_invalidDates_empty() throws IllegalValueException {
        commandParser.setInput("walk by the beach from 1 end to another");
        assertFalse(
            commandParser.extractTrailingTwoSidedDateRange().isPresent()
        );
        assertEquals(
            "walk by the beach from 1 end to another", commandParser.extractText().orElse("")
        );
    }

    @Test
    public void extractTrailingTwoSidedDateRange_2DateRanges_onlyTrailingExtracted() throws IllegalValueException {
        commandParser.setInput("walk by the beach from today to tomorrow from 28 Oct 2018 1200h to 29 Nov 2019 1300h");
        Optional<DateRange> dateRange = commandParser.extractTrailingTwoSidedDateRange();
        assertTrue(dateRange.isPresent());
        assertEquals(
            new DateRange(
                LocalDateTime.of(2018, 10, 28, 12, 0),
                LocalDateTime.of(2019, 11, 29, 13, 0)
            ),
            dateRange.get()
        );
        assertEquals(
            "walk by the beach from today to tomorrow", commandParser.extractText().orElse("")
        );
    }

    @Test
    public void extractTrailingSingleDateDateRange_onDate_extractedOnDate() throws IllegalValueException {
        commandParser.setInput("event on 1/2/2011");
        Optional<DateRange> dateRange = commandParser.extractTrailingSingleDateDateRange();
        assertTrue(dateRange.isPresent());
        assertEquals(
            new DateRange(
                LocalDateTime.of(2011, 2, 1, 0, 0),
                LocalDateTime.of(2011, 2, 1, 23, 59)
            ),
            dateRange.get()
        );
        assertEquals(
            "event", commandParser.extractText().orElse("")
        );
    }

    @Test
    public void extractTrailingSingleDateDateRange_onDateTime_extractedOnDateTime() throws IllegalValueException {
        commandParser.setInput("event on 1/2/2011 9pm");
        Optional<DateRange> dateRange = commandParser.extractTrailingSingleDateDateRange();
        assertTrue(dateRange.isPresent());
        assertEquals(
            new DateRange(
                LocalDateTime.of(2011, 2, 1, 21, 0),
                LocalDateTime.of(2011, 2, 1, 23, 59)
            ),
            dateRange.get()
        );
        assertEquals(
            "event", commandParser.extractText().orElse("")
        );
    }

    @Test
    public void extractTrailingSingleDateDateRange_onWithInvalidTime_notExtracted() throws IllegalValueException {
        commandParser.setInput("event on 100");
        Optional<DateRange> dateRange = commandParser.extractTrailingSingleDateDateRange();
        assertFalse(dateRange.isPresent());
        assertEquals(
            "event on 100", commandParser.extractText().orElse("")
        );
    }

    @Test
    public void extractTrailingSingleDateDateRange_withOnFromTo_extractedTrailing() throws IllegalValueException {
        commandParser.setInput("event from today to tomorrow on 1 Feb 2011 2359h");
        Optional<DateRange> dateRange = commandParser.extractTrailingSingleDateDateRange();
        assertTrue(dateRange.isPresent());
        assertEquals(
            new DateRange(
                LocalDateTime.of(2011, 2, 1, 23, 59),
                LocalDateTime.of(2011, 2, 1, 23, 59)
            ),
            dateRange.get()
        );
        assertEquals(
            "event from today to tomorrow", commandParser.extractText().orElse("")
        );
    }

    @Test
    public void extractTrailingTwoSidedDateRange_withFromTodayToTomorrow_extractedTrailing() throws IllegalValueException {
        commandParser.setInput("event from today to tomorrow");
        Optional<DateRange> dateRange = commandParser.extractTrailingTwoSidedDateRange();
        assertTrue(dateRange.isPresent());
        assertEquals(
            new DateRange(
                LocalDateTime.now().withHour(0).withMinute(0),
                LocalDateTime.now().plusDays(1).withHour(23).withMinute(59)
            ),
            dateRange.get()
        );
        assertEquals(
            "event", commandParser.extractText().orElse("")
        );
    }

    @Test
    public void extractTrailingTwoSidedDateRange_withFromOnly_notExtracted() throws IllegalValueException {
        commandParser.setInput("event from today");
        Optional<DateRange> dateRange = commandParser.extractTrailingTwoSidedDateRange();
        assertFalse(dateRange.isPresent());
        assertEquals(
            "event from today", commandParser.extractText().orElse("")
        );
    }

    @Test
    public void extractTrailingStartDateDateRange_withFromOnly_extracted() throws IllegalValueException {
        commandParser.setInput("event from today");
        Optional<DateRange> dateRange = commandParser.extractTrailingStartDateDateRange();
        assertEquals(
            new DateRange(
                LocalDateTime.now().withHour(0).withMinute(0),
                LocalDateTime.MAX
            ),
            dateRange.get()
        );
        assertEquals(
            "event", commandParser.extractText().orElse("")
        );
    }

    @Test
    public void extractTrailingTwoSidedDateRange_withToOnly_notExtracted() throws IllegalValueException {
        commandParser.setInput("event to 21 Jan 2017");
        Optional<DateRange> dateRange = commandParser.extractTrailingTwoSidedDateRange();
        assertFalse(dateRange.isPresent());
        assertEquals(
            "event to 21 Jan 2017", commandParser.extractText().orElse("")
        );
    }

    @Test
    public void extractTrailingEndDateDateRange_withToOnly_extracted() throws IllegalValueException {
        commandParser.setInput("event to 21 Jan 2017");
        Optional<DateRange> dateRange = commandParser.extractTrailingEndDateDateRange();
        assertTrue(dateRange.isPresent());
        assertEquals(
            new DateRange(
                LocalDateTime.now(),
                LocalDateTime.of(2017, 1, 21, 0, 0)
            ),
            dateRange.get()
        );
        assertEquals(
            "event", commandParser.extractText().orElse("")
        );
    }

    @Test
    public void extractTrailingSingleDateDateRange_withOnAndRecurrence_extracted() throws IllegalValueException {
        commandParser.setInput("event on 1/11/" + nextYear + " weekly");
        Optional<DateRange> dateRange = commandParser.extractTrailingSingleDateDateRange();
        assertTrue(dateRange.isPresent());
        assertEquals(
            new DateRange(
                LocalDateTime.of(nextYear, 11, 1, 0, 0),
                LocalDateTime.of(nextYear, 11, 1, 23, 59),
                Recurrence.Weekly
            ),
            dateRange.get()
        );
        assertEquals(
            "event", commandParser.extractText().orElse("")
        );
    }

```
###### \java\seedu\commando\logic\parser\DateTimeParserTest.java
``` java
public class DateTimeParserTest {
    private DateTimeParser dateTimeParser;
    private LocalDateTime now = LocalDateTime.now();

    @Before
    public void setUp() {
        dateTimeParser = new DateTimeParser();
    }

    @Test
    public void parseDateTime_emptyString_empty() {
        assertFalse(dateTimeParser.parseDateTime("").isPresent());
    }

    @Test
    public void parseDateTime_ddMMMyyyy_colonHHmm_parsed() {
        assertEquals(
            LocalDateTime.of(2016, 2, 28, 23, 59),
            dateTimeParser.parseDateTime("28 Feb 2016 23:59").orElse(null)
        );
    }

    @Test
    public void parseDateTime_ddMMM_HHmmPm_parsed() {
        assertEquals(
            LocalDateTime.of(now.getYear(), 2, 28, 21, 30),
            dateTimeParser.parseDateTime("28 Feb 9.30pm").orElse(null)
        );
    }

    @Test
    public void parseDateTime_ddMMMyyh_parsed() {
        assertEquals(
            LocalDateTime.of(2016, 2, 28, 23, 59),
            dateTimeParser.parseDateTime("28 Feb 16 2359h").orElse(null)
        );
    }

    @Test
    public void parseDateTime_dateWithSlashes_parsed() {
        assertEquals(
            LocalDateTime.of(2001, 1, 1,
                LocalTime.MIDNIGHT.getHour(),
                LocalTime.MIDNIGHT.getMinute()),
            dateTimeParser.parseDateTime("1/1/01").orElse(null)
        );

        LocalTime localTime = LocalTime.of(23, 59);
        assertEquals(
            LocalDateTime.of(2016, 12, 11,
                localTime.getHour(),
                localTime.getMinute()),
            dateTimeParser.parseDateTime("11/12/16", localTime).orElse(null)
        );
    }

    @Test
    public void parseDateTime_ddMMMWithNoonDefaultTime_parsed() {
        assertEquals(
            LocalDateTime.of(now.getYear(), 2, 28,
                LocalTime.NOON.getHour(),
                LocalTime.NOON.getMinute()),
            dateTimeParser.parseDateTime("28 Feb", LocalTime.NOON).orElse(null)
        );
    }

    @Test
    public void parseDateTime_HHmmh_parsed() {
        assertEquals(
            LocalDateTime.of(now.getYear(), now.getMonthValue(), now.getDayOfMonth(), 19, 19),
            dateTimeParser.parseDateTime("1919h").orElse(null)
        );
    }

    // Underlying natty doesn't parse this properly
    @Test
    public void parseDateTime_DateWithoutYearAndHHmmh_parsed() {
        assertEquals(
            LocalDateTime.of(now.getYear(), 10, 31, 19, 19),
            dateTimeParser.parseDateTime("31 Oct 1919h").orElse(null)
        );
    }

    @Test
    public void parseDateTime_ordinalFullMonthHHAm_parsed() {
        assertEquals(
            LocalDateTime.of(now.getYear(), 1, 1, 11, 0),
            dateTimeParser.parseDateTime("1st January 11am").orElse(null)
        );
    }

    @Test
    public void parseDateTime_DateWithSlashesHHmmh_parsed() {
        assertEquals(
            LocalDateTime.of(2016, 11, 14, 20, 1),
            dateTimeParser.parseDateTime("14/11/2016 2001h").orElse(null)
        );
    }

    @Test
    public void parseDateTime_DateWithSlashesNoYearHHmmWithColon_parsed() {
        assertEquals(
            LocalDateTime.of(2016, 11, 26, 13, 0),
            dateTimeParser.parseDateTime("26/11 13:00").orElse(null)
        );
    }

    @Test
    public void parseDateTime_presets_parsed() {
        // today
        assertEquals(
            LocalDateTime.of(now.getYear(), now.getMonth(), now.getDayOfMonth(),
                LocalTime.MIDNIGHT.getHour(),
                LocalTime.MIDNIGHT.getMinute()),
            dateTimeParser.parseDateTime("today").orElse(null)
        );

        // tomorrow
        LocalDateTime tomorrow = now.plusDays(1);
        assertEquals(
            LocalDateTime.of(tomorrow.getYear(), tomorrow.getMonth(), tomorrow.getDayOfMonth(),
                LocalTime.MIDNIGHT.getHour(),
                LocalTime.MIDNIGHT.getMinute()),
            dateTimeParser.parseDateTime("tomorrow").orElse(null)
        );

        assertEquals(
            LocalDateTime.of(tomorrow.getYear(), tomorrow.getMonth(), tomorrow.getDayOfMonth(),
                LocalTime.MIDNIGHT.getHour(),
                LocalTime.MIDNIGHT.getMinute()),
            dateTimeParser.parseDateTime("tmr").orElse(null)
        );

        // yesterday
        LocalDateTime yesterday = now.minusDays(1);
        assertEquals(
            LocalDateTime.of(yesterday.getYear(), yesterday.getMonth(), yesterday.getDayOfMonth(),
                LocalTime.MIDNIGHT.getHour(),
                LocalTime.MIDNIGHT.getMinute()),
            dateTimeParser.parseDateTime("yesterday").orElse(null)
        );
    }

    @Test
    public void parseDateTime_extraSpaces_parsed() {
        assertEquals(
            LocalDateTime.of(2016, 4, 22, 8, 0),
            dateTimeParser.parseDateTime("22     April   2016  0800h ").orElse(null)
        );
    }

    @Test
    public void parseDateTime_reversedMonthWord_parsed() {
        assertEquals(
            LocalDateTime.of(2011, 6, 21, 13, 13),
            dateTimeParser.parseDateTime("June 21 2011 1.13pm").orElse(null)
        );
    }

    @Test
    public void parseDateTime_inferDateFromPreviousParse_inferred() {
        // In multiple parses, date should be inferred from previous parse
        dateTimeParser.parseDateTime("10 Jan 2016 10am");

        assertEquals(
            LocalDateTime.of(2016, 1, 10, 23, 0),
            dateTimeParser.parseDateTime("11pm").orElse(null)
        );

        assertEquals(
            LocalDateTime.of(2016, 1, 10, 11, 11),
            dateTimeParser.parseDateTime("1111h").orElse(null)
        );
    }

    @Test
    public void parseDateTime_invalidDates_empty() {
        assertFalse(dateTimeParser.parseDateTime("No date").isPresent());

        // Use of Boundary value analysis
        // Close to date with slashes format
        assertFalse(dateTimeParser.parseDateTime("10/2016").isPresent());
        assertFalse(dateTimeParser.parseDateTime("1/2/3/4").isPresent());

        // Close to date with month word formats
        assertFalse(dateTimeParser.parseDateTime("1 May be").isPresent());
        assertFalse(dateTimeParser.parseDateTime("10 Marching").isPresent());
        assertFalse(dateTimeParser.parseDateTime("Feb20").isPresent());

        // Close to relative date formats
        assertFalse(dateTimeParser.parseDateTime("wed thurs").isPresent());
        assertFalse(dateTimeParser.parseDateTime("coming dayum").isPresent());
        assertFalse(dateTimeParser.parseDateTime("next weekday").isPresent());

        // No such dates
        assertFalse(dateTimeParser.parseDateTime("32 Feb").isPresent());
        assertFalse(dateTimeParser.parseDateTime("-1/1/2016").isPresent());
    }

    @Test
    public void parseDateTime_invalidTimes_empty() {
        assertFalse(dateTimeParser.parseDateTime("0").isPresent());
        assertFalse(dateTimeParser.parseDateTime("31").isPresent());

        // Use of Boundary value analysis
        // Close to "pm" format
        assertFalse(dateTimeParser.parseDateTime("10cm").isPresent());

        // Close to "hhmm"h format
        assertFalse(dateTimeParser.parseDateTime("2359").isPresent());
        assertFalse(dateTimeParser.parseDateTime("h").isPresent());

        // Close to colon format
        assertFalse(dateTimeParser.parseDateTime("23::10").isPresent());
        assertFalse(dateTimeParser.parseDateTime("23:110").isPresent());

        // No such times
        assertFalse(dateTimeParser.parseDateTime("10059h").isPresent());
        assertFalse(dateTimeParser.parseDateTime("44:44").isPresent());
    }

    @Test
    public void resetContext_afterParseDateTime_noInferrence() {
        dateTimeParser.parseDateTime("10 Jan 2016 10am");

        dateTimeParser.resetContext();

        assertEquals(
            LocalDateTime.of(now.getYear(), now.getMonth(), now.getDayOfMonth(), 23, 0),
            dateTimeParser.parseDateTime("11pm").orElse(null)
        );
    }

```
###### \java\seedu\commando\model\ModelManagerTest.java
``` java
public class ModelManagerTest {
    @Rule
    public final ExpectedException exception = ExpectedException.none();

    private LocalDateTime now = LocalDateTime.now();

    private ToDoList toDoList;
    private ToDo toDoListItem1;
    private ToDo toDoListItem2;
    private ToDoList toDoList2;
    private ToDo toDoList2Item1;
    private ModelManager modelManager;

    private ToDoListChange toDoListChangeAdd1;
    private ToDoListChange toDoListChangeDelete1;
    private ToDoListChange toDoListChangeEdit1;

    private boolean hasReached;

    @Before
    public void setUp() throws IllegalValueException {
        toDoList = new ToDoList();
        toDoListItem1 = new ToDoBuilder("title")
            .created(now.plusYears(-1))
            .build();
        toDoListItem2 = new ToDoBuilder("title 2")
            .created(now)
            .withTags("tag1", "tag2")
            .withDueDate(
                LocalDateTime.of(2016, 5, 1, 20, 1)
            )
            .withDateRange(
                LocalDateTime.of(2016, 3, 1, 20, 1),
                LocalDateTime.of(2016, 4, 1, 20, 1)
            )
            .finish(now.plusYears(1))
            .build();

        toDoList.add(toDoListItem1);
        toDoList.add(toDoListItem2);

        toDoList2Item1 = new ToDoBuilder("title 3")
            .withDateRange(
                LocalDateTime.of(2016, 3, 1, 20, 1),
                LocalDateTime.of(2016, 4, 1, 20, 1)
            )
            .build();
        toDoList2 = new ToDoList().add(toDoList2Item1);

        modelManager = new ModelManager(toDoList);

        toDoListChangeAdd1 = new ToDoListChange(
            new ToDoList().add(toDoList2Item1),
            new ToDoList()
        );

        toDoListChangeDelete1 = new ToDoListChange(
            new ToDoList(),
            new ToDoList().add(toDoListItem1)
        );

        toDoListChangeEdit1 = new ToDoListChange(
            new ToDoList().add(toDoList2Item1),
            new ToDoList().add(toDoListItem1)
        );

        hasReached = false;
    }

    @Test
    public void getToDoList_setup_containsAllToDos() {
        assertEquals(modelManager.getToDoList(), toDoList);
        assertTrue(modelManager.getToDoList().contains(toDoListItem1));
        assertTrue(modelManager.getToDoList().contains(toDoListItem1));
        assertFalse(modelManager.getToDoList().contains(toDoList2Item1));
    }

    @Test
    public void changeToDoList_changeAdd_containsAddedToDo() throws IllegalValueException {
        modelManager.changeToDoList(toDoListChangeAdd1);

        assertTrue(modelManager.getToDoList().contains(toDoListItem1));
    }

    @Test
    public void changeToDoList_changeDelete_notContainsDeletedToDo() throws IllegalValueException {
        modelManager.changeToDoList(toDoListChangeDelete1);

        assertFalse(modelManager.getToDoList().contains(toDoListItem1));
    }

    @Test
    public void changeToDoList_changeEdit_containsAddedNotContainsDeleted() throws IllegalValueException {
        modelManager.changeToDoList(toDoListChangeEdit1);

        assertFalse(modelManager.getToDoList().contains(toDoListItem1));
        assertTrue(modelManager.getToDoList().contains(toDoList2Item1));
    }

    @Test
    public void changeToDoList_changeAddThenDelete_containsAddedNotContainsDeleted() throws IllegalValueException {
        modelManager.changeToDoList(toDoListChangeAdd1);
        modelManager.changeToDoList(toDoListChangeDelete1);

        assertTrue(modelManager.getToDoList().contains(toDoList2Item1));
        assertFalse(modelManager.getToDoList().contains(toDoListItem1));
    }

    @Test
    public void changeToDoList_changeClear_noToDos() throws IllegalValueException {
        ToDoListChange clearChange = new ToDoListChange(
            new ToDoList(),
            modelManager.getToDoList()
        );
        modelManager.changeToDoList(clearChange);
        assertTrue(modelManager.getToDoList().getToDos().size() == 0);
    }

    @Test
    public void undoToDoList_once_undone() throws IllegalValueException {
        modelManager.changeToDoList(toDoListChangeAdd1);
        modelManager.changeToDoList(toDoListChangeDelete1);

        assertTrue(modelManager.undoToDoList());

        assertTrue(modelManager.getToDoList().contains(toDoList2Item1));
        assertTrue(modelManager.getToDoList().contains(toDoListItem1));
    }

    @Test
    public void undoToDoList_multiple_undone() throws IllegalValueException {
        modelManager.changeToDoList(toDoListChangeAdd1);
        modelManager.changeToDoList(toDoListChangeDelete1);

        // try to undo 3x
        assertTrue(modelManager.undoToDoList());
        assertTrue(modelManager.undoToDoList());
        assertFalse(modelManager.undoToDoList()); // fails

        assertFalse(modelManager.getToDoList().contains(toDoList2Item1));
        assertTrue(modelManager.getToDoList().contains(toDoListItem1));
    }

    @Test
    public void undoToDoList_undoChangeUndo_undone() throws IllegalValueException {
        modelManager.changeToDoList(toDoListChangeAdd1);

        assertTrue(modelManager.undoToDoList());

        modelManager.changeToDoList(toDoListChangeDelete1);

        assertTrue(modelManager.undoToDoList());

        assertFalse(modelManager.getToDoList().contains(toDoList2Item1));
        assertTrue(modelManager.getToDoList().contains(toDoListItem1));
    }

    @Test
    public void redoToDoList_noUndos_noAction() throws IllegalValueException {
        modelManager.changeToDoList(toDoListChangeAdd1);
        modelManager.changeToDoList(toDoListChangeDelete1);

        assertFalse(modelManager.redoToDoList()); // fails

        assertTrue(modelManager.getToDoList().contains(toDoList2Item1));
        assertFalse(modelManager.getToDoList().contains(toDoListItem1));
    }

    @Test
    public void redoToDoList_once_redone() throws IllegalValueException {
        modelManager.changeToDoList(toDoListChangeAdd1);
        modelManager.changeToDoList(toDoListChangeDelete1);

        assertTrue(modelManager.undoToDoList());
        assertTrue(modelManager.undoToDoList());
        assertTrue(modelManager.redoToDoList());

        assertTrue(modelManager.getToDoList().contains(toDoList2Item1));
    }

    @Test
    public void redoToDoList_undoChangeRedo_noAction() throws IllegalValueException {
        modelManager.changeToDoList(toDoListChangeAdd1);

        assertTrue(modelManager.undoToDoList());

        modelManager.changeToDoList(toDoListChangeDelete1);

        assertFalse(modelManager.redoToDoList()); // fails

        assertFalse(modelManager.getToDoList().contains(toDoList2Item1));
        assertFalse(modelManager.getToDoList().contains(toDoListItem1));
    }
}
```
###### \java\seedu\commando\model\todo\ToDoListTest.java
``` java
public class ToDoListTest {
    @Rule
    public final ExpectedException exception = ExpectedException.none();

    private ToDoList toDoList;
    private ToDo toDoListItem1;
    private ToDo toDoListItem2;
    private ToDoList toDoList2;
    private ToDo toDoList2Item1;

    @Before
    public void setUp() throws IllegalValueException {
        toDoList = new ToDoList();
        toDoListItem1 = new ToDoBuilder("title").build();
        toDoListItem2 = new ToDoBuilder("title 2").withTags("tag1", "tag2")
            .withDueDate(LocalDateTime.of(2016, 5, 1, 20, 1))
            .finish(LocalDateTime.of(2016, 6, 3, 20, 20)).build();
        toDoList.add(toDoListItem1);
        toDoList.add(toDoListItem2);
        toDoList2Item1 = new ToDoBuilder("title 3")
            .withDateRange(LocalDateTime.of(2016, 3, 1, 20, 1), LocalDateTime.of(2016, 4, 1, 20, 1)).build();
        toDoList2 = new ToDoList();
        toDoList2.add(toDoList2Item1);
    }

    @Test
    public void ToDoList_copyConstructor_equals() {
        ToDoList copied = new ToDoList(toDoList);
        assertEquals(copied, toDoList);
    }

    @Test
    public void getToDos_setup_sizeAndContains() throws IllegalValueException {
        assertTrue(toDoList.getToDos().size() == 2);
        assertTrue(toDoList.getToDos().contains(toDoListItem1));
        assertTrue(toDoList.getToDos().contains(toDoListItem2));
    }

    @Test
    public void reset_anotherToDoList_equals() {
        toDoList.reset(toDoList2.getToDos());
        assertEquals(toDoList, toDoList2);
    }

    @Test
    public void equals_withSingleToDo_equals() throws IllegalValueException {
        ReadOnlyToDo toDo = new ToDoBuilder("title").build();

        ReadOnlyToDoList toDoList1 = new ToDoList().add(toDo);
        ReadOnlyToDoList toDoList2 = new ToDoList().add(toDo);

        assertEquals(toDoList1, toDoList2);
    }

    @Test
    public void hashCode_withSingleToDo_equals() throws IllegalValueException {
        ReadOnlyToDo toDo = new ToDoBuilder("title").build();

        ReadOnlyToDoList toDoList1 = new ToDoList().add(toDo);
        ReadOnlyToDoList toDoList2 = new ToDoList().add(toDo);

        assertEquals(toDoList1.hashCode(), toDoList2.hashCode());
    }

    @Test
    public void add_newToDo_contains() throws IllegalValueException {
        assertFalse(toDoList.getToDos().contains(toDoList2Item1));
        toDoList.add(toDoList2Item1);
        assertTrue(toDoList.getToDos().contains(toDoList2Item1));
    }

    @Test
    public void remove_existingToDo_notContains() throws IllegalValueException {
        assertTrue(toDoList.getToDos().contains(toDoListItem1));
        toDoList.remove(toDoListItem1);
        assertFalse(toDoList.getToDos().contains(toDoListItem1));
    }
}
```
###### \java\seedu\commando\model\todo\ToDoTest.java
``` java
public class ToDoTest {
    private ToDo toDo;

    @Before
    public void setUp() throws IllegalValueException {
        toDo = new ToDo(new Title("title"));
    }

    @Test
    public void ToDo() throws IllegalValueException {
        ToDo toDo = new ToDo(new Title("title"));
        assertEquals(toDo.getTitle(), new Title("title"));
        assertTrue(toDo.getDateCreated().toLocalDate().equals(LocalDate.now()));
    }

    @Test
    public void ToDo_copyConstructor_equals() throws IllegalValueException {
        ToDo toDo = new ToDo(new Title("title"))
            .setTags(Sets.newHashSet(new Tag("tag1"), new Tag("tag2")))
            .setIsFinished(true);

        toDo.setDateRange(new DateRange(
            LocalDateTime.of(2001, 10, 8, 12, 59),
            LocalDateTime.of(2001, 10, 8, 15, 59),
            Recurrence.Weekly
        ));
        toDo.setDueDate(new DueDate(
            LocalDateTime.of(2001, 10, 8, 12, 59),
            Recurrence.Yearly
        ));

        ToDo newToDo = new ToDo(toDo);
        assertEquals(newToDo, toDo);
    }

    @Test
    public void setTitle_validTitle_getTitleEquals() throws IllegalValueException {
        toDo.setTitle(new Title("set title"));
        assertEquals(toDo.getTitle(), new Title("set title"));
    }

    @Test
    public void setTags_validTags_getTagsEquals() throws IllegalValueException {
        assertTrue(toDo.getTags().size() == 0);
        toDo.setTags(Sets.newHashSet(new Tag("tag1"), new Tag("tag2")));
        assertEquals(toDo.getTags(), Sets.newHashSet(new Tag("tag1"), new Tag("tag2")));
    }

    @Test
    public void setDueDate_validDueDate_getDueDateEquals() throws IllegalValueException {
        assertFalse(toDo.getDueDate().isPresent());
        toDo.setDueDate(new DueDate(LocalDateTime.of(2001, 10, 8, 12, 59)));
        assertTrue(toDo.getDueDate().isPresent());
        assertEquals(toDo.getDueDate().get(),
            new DueDate(LocalDateTime.of(2001, 10, 8, 12, 59))
        );
    }

    @Test
    public void setDateRange_validDateRange_getDateRangeEquals() throws IllegalValueException {
        assertFalse(toDo.getDateRange().isPresent());
        toDo.setDateRange(new DateRange(
            LocalDateTime.of(2001, 10, 8, 12, 59),
            LocalDateTime.of(2001, 10, 8, 13, 59)
        ));
        assertTrue(toDo.getDateRange().isPresent());
        assertEquals(toDo.getDateRange().get(), new DateRange(
            LocalDateTime.of(2001, 10, 8, 12, 59),
            LocalDateTime.of(2001, 10, 8, 13, 59)
        ));
    }

    @Test
    public void setDateRange_recurringDateRange_getDateRangeConsidersRecurrence() throws IllegalValueException {
        assertFalse(toDo.getDateRange().isPresent());
        toDo.setDateRange(new DateRange(
            LocalDateTime.now().minusDays(2),
            LocalDateTime.now().minusDays(1),
            Recurrence.Yearly
        ));
        assertTrue(toDo.getDateRange().isPresent());
        assertEquals(toDo.getDateRange().get(), new DateRange(
            LocalDateTime.now().minusDays(2).plusYears(1),
            LocalDateTime.now().minusDays(1).plusYears(1),
            Recurrence.Yearly
        ));
    }

    @Test
    public void setIsFinished_trueThenFalse_getDateFinishedEqualsNowThenEmpty() throws IllegalValueException {
        assertFalse(toDo.isFinished());
        assertFalse(toDo.getDateFinished().isPresent());
        toDo.setIsFinished(true);
        assertTrue(toDo.getDateFinished().isPresent());
        assertTrue(toDo.getDateFinished().get().toLocalDate().equals(LocalDate.now()));
        toDo.setIsFinished(false);
        assertFalse(toDo.isFinished());
        assertFalse(toDo.getDateFinished().isPresent());
    }

    @Test
    public void setIsFinished_withRecurringDueDate_advancesDueDate() throws IllegalValueException {
        toDo.setDueDate(new DueDate(
            LocalDateTime.now().minusDays(1),
            Recurrence.Yearly
        ));

        assertEquals(new DueDate(
            LocalDateTime.now().minusDays(1),
            Recurrence.Yearly
        ), toDo.getDueDate().get());

        toDo.setIsFinished(true);
        assertFalse(toDo.isFinished());

        assertEquals(new DueDate(
            LocalDateTime.now().minusDays(1).plusYears(1),
            Recurrence.Yearly
        ), toDo.getDueDate().get());

        toDo.setIsFinished(true);
        assertFalse(toDo.isFinished());

        assertEquals(new DueDate(
            LocalDateTime.now().minusDays(1).plusYears(2),
            Recurrence.Yearly
        ), toDo.getDueDate().get());
    }

    @Test
    public void setGetDateFinished_withDateRange_dateFinishedAlwaysEqualsEndDate() throws IllegalValueException {
        LocalDateTime endDate = LocalDateTime.of(2012, 11, 2, 1, 23);
        toDo.setDateRange(
            new DateRange(
                LocalDateTime.of(2011, 11, 2, 1, 23),
                endDate
            )
        );
        assertEquals(endDate, toDo.getDateFinished().get());
        toDo.setDateFinished(LocalDateTime.now());
        assertEquals(endDate, toDo.getDateFinished().get());
    }

    @Test
    public void setGetDateFinished_withRecurringDateRange_dateFinishedAlwaysEmpty() throws IllegalValueException {
        LocalDateTime endDate = LocalDateTime.of(2011, 11, 2, 2, 23);
        toDo.setDateRange(
            new DateRange(
                LocalDateTime.of(2011, 11, 2, 1, 23),
                endDate,
                Recurrence.Weekly
            )
        );
        assertFalse(toDo.getDateFinished().isPresent());
        toDo.setDateFinished(LocalDateTime.now());
        assertFalse(toDo.getDateFinished().isPresent());
    }

    @Test
    public void setGetDateFinished_withRecurringDueDate_dateFinishedAlwaysEmpty() throws IllegalValueException {
        LocalDateTime dueDate = LocalDateTime.of(2011, 11, 2, 2, 23);
        toDo.setDueDate(
            new DueDate(
                dueDate,
                Recurrence.Weekly
            )
        );
        assertFalse(toDo.getDateFinished().isPresent());
        toDo.setDateFinished(LocalDateTime.now());
        assertFalse(toDo.getDateFinished().isPresent());
    }


    @Test
    public void setDateFinished_validDateTime_getDateFinishedEquals() throws IllegalValueException {
        LocalDateTime datetime = LocalDateTime.of(2011, 11, 2, 1, 23);
        toDo.setDateFinished(datetime);
        assertEquals(datetime, toDo.getDateFinished().orElse(null));
    }

    @Test
    public void setDateCreated_validDateTime_getDateCreatedEquals() throws IllegalValueException {
        LocalDateTime datetime = LocalDateTime.of(2011, 11, 2, 1, 23);
        toDo.setDateCreated(datetime);
        assertEquals(datetime, toDo.getDateCreated());
    }

    @Test
    public void equalsAndHashCode_sameFields_equals() throws IllegalValueException {
        ReadOnlyToDo toDo1 = new ToDoBuilder("title")
            .withDateRange(LocalDateTime.MIN, LocalDateTime.MAX)
            .withDueDate(LocalDateTime.MAX)
            .withTags("tag1", "tag2")
            .finish(LocalDateTime.MAX)
            .build();

        ReadOnlyToDo toDo2 = new ToDoBuilder("title")
            .withDateRange(LocalDateTime.MIN, LocalDateTime.MAX)
            .withDueDate(LocalDateTime.MAX)
            .withTags("tag1", "tag2")
            .finish(LocalDateTime.MAX)
            .build();

        assertEquals(toDo1, toDo2);
        assertEquals(toDo1.hashCode(), toDo2.hashCode());
    }

    @Test
    public void getObservableValue_allFields_changeListenerCalledEachFieldChange() throws IllegalValueException {
        List<String> changes = new LinkedList<>();
        toDo.getObservableValue().addListener((observable, oldValue, newValue) -> {
            changes.add(newValue);
        });

        toDo.setTitle(new Title("new title"));
        assertTrue(changes.size() == 1);

        toDo.setIsFinished(true);
        assertTrue(changes.size() == 2);

        toDo.setDateRange(new DateRange(
            LocalDateTime.of(2001, 10, 8, 12, 59),
            LocalDateTime.of(2002, 10, 8, 11, 59)
        ));
        assertTrue(changes.size() == 3);

        toDo.setDueDate(new DueDate(
            LocalDateTime.of(2001, 10, 8, 12, 59)
        ));
        assertTrue(changes.size() == 4);

        toDo.setTags(Sets.newHashSet(new Tag("tag1"), new Tag("tag2")));
        assertTrue(changes.size() == 5);

        toDo.setDateCreated(LocalDateTime.of(2011, 11, 11, 12, 12));
        assertTrue(changes.size() == 6);

        // with date range, date finished won't change
        toDo.clearTimeConstraint();
        assertTrue(changes.size() == 7);

        toDo.setDateFinished(LocalDateTime.now().plusYears(1));
        assertTrue(changes.size() == 8);
    }
}
```
###### \java\seedu\commando\model\ui\UiModelTest.java
``` java
public class UiModelTest {
    private UiModel uiModel;
    private ToDoListManager toDoListManager;

    @Before
    public void setUp() throws IllegalValueException {
        ReadOnlyToDoList toDoList = new ToDoList()
            .add(TaskOldDueUnfinishedNewCreated)
            .add(TaskOldDueUnfinishedOldCreated)
            .add(TaskNewDueUnfinishedNewCreated)
            .add(TaskNewDueUnfinishedOldCreated)
            .add(TaskUnfinishedNewCreated)
            .add(TaskUnfinishedOldCreated)
            .add(TaskOldFinished)
            .add(TaskOlderFinished)
            .add(EventOldRangeUnfinishedNewCreated)
            .add(EventOldRangeUnfinishedOldCreated)
            .add(EventNewRangeUnfinishedNewCreated)
            .add(EventNewRangeUnfinishedOldCreated)
            .add(EventNewFinished)
            .add(EventOldFinished);

        toDoListManager = new ToDoListManager(toDoList);

        uiModel = new UiModel(toDoListManager);
    }

    // Check if the order of events for ui is correct
    @Test
    public void getUiEvents_setup_orderCorrect() {
        List<UiToDo> events = uiModel.getEvents();

        assertEquals(4, events.size());

        assertEquals(EventOldRangeUnfinishedNewCreated, events.get(0));
        assertEquals(EventOldRangeUnfinishedOldCreated, events.get(1));
        assertEquals(EventNewRangeUnfinishedNewCreated, events.get(2));
        assertEquals(EventNewRangeUnfinishedOldCreated, events.get(3));
    }

    // Check if the order of events for ui is correct for history mode
    @Test
    public void getUiEvents_setupFinishedMode_orderCorrect() {
        uiModel.setToDoListFilter(Collections.emptySet(), Collections.emptySet(), Model.FILTER_MODE.FINISHED);
        List<UiToDo> events = uiModel.getEvents();

        assertEquals(2, events.size());

        assertEquals(EventNewFinished, events.get(0));
        assertEquals(EventOldFinished, events.get(1));
    }

    // Check if the order of tasks for ui is correct
    @Test
    public void getUiTasks_setup_orderCorrect() {
        List<UiToDo> tasks = uiModel.getTasks();

        assertEquals(6, tasks.size());

        assertEquals(TaskOldDueUnfinishedNewCreated, tasks.get(0));
        assertEquals(TaskOldDueUnfinishedOldCreated, tasks.get(1));
        assertEquals(TaskNewDueUnfinishedNewCreated, tasks.get(2));
        assertEquals(TaskNewDueUnfinishedOldCreated, tasks.get(3));
        assertEquals(TaskUnfinishedNewCreated, tasks.get(4));
        assertEquals(TaskUnfinishedOldCreated, tasks.get(5));
    }

    // Check if the order of tasks for ui is correct for history
    @Test
    public void getUiTasks_setupFinishedMode_orderCorrect() {
        uiModel.setToDoListFilter(Collections.emptySet(), Collections.emptySet(), Model.FILTER_MODE.FINISHED);

        List<UiToDo> tasks = uiModel.getTasks();

        assertEquals(2, tasks.size());

        assertEquals(TaskOldFinished, tasks.get(0));
        assertEquals(TaskOlderFinished, tasks.get(1));
    }
}
```
###### \java\seedu\commando\testutil\TestHelper.java
``` java

/**
 * Collection of convenience methods for testing
 */
public class TestHelper {

    public static boolean wasToDoListChangedEventPosted(EventsCollector eventsCollector) {
        return eventsCollector.hasCollectedEvent(ToDoListChangedEvent.class);
    }

    public static boolean wasShowHelpRequestEventPosted(EventsCollector eventsCollector) {
        return eventsCollector.hasCollectedEvent(ShowHelpRequestEvent.class);
    }

    /**
     * Checks if a to-do exists in the model
     */
    public static void assertToDoExists(Logic logic, ReadOnlyToDo readOnlyToDo) {
        assert logic.getToDoList().contains(readOnlyToDo);
    }

    /**
     * Checks if a to-do doesn't exist in the model
     */
    public static void assertToDoNotExists(Logic logic, ReadOnlyToDo readOnlyToDo) {
        assert !logic.getToDoList().contains(readOnlyToDo);
    }

    /**
     * Checks if a to-do appears on the UI
     */
    public static void assertToDoExistsFiltered(Logic logic, ReadOnlyToDo readOnlyToDo) {
        assert logic.getUiEvents().filtered(uiToDo -> uiToDo.isSimilar(readOnlyToDo)).size() > 0
            || logic.getUiTasks().filtered(uiToDo -> uiToDo.isSimilar(readOnlyToDo)).size() > 0;
    }

    /**
     * Checks if a to-do doesn't appear on the UI
     */
    public static void assertToDoNotExistsFiltered(Logic logic, ReadOnlyToDo readOnlyToDo) {
        assert logic.getUiEvents().filtered(uiToDo -> uiToDo.isSimilar(readOnlyToDo)).size() == 0
            && logic.getUiTasks().filtered(uiToDo -> uiToDo.isSimilar(readOnlyToDo)).size() == 0;
    }
}
```
###### \java\seedu\commando\testutil\ToDoBuilder.java
``` java

/**
 * Helps build a to-do in 1 line
 * Also contains sample to-dos that are relative to the current day
 */
public class ToDoBuilder {
    private ToDo toDo;

    public static LocalDateTime now = LocalDateTime.now();

    public static LocalDateTime OldestDate = now.minusDays(4);
    public static LocalDateTime OlderDate = now.minusDays(3);
    public static LocalDateTime OldDate = now.minusDays(2);
    public static LocalDateTime RecentDate = now.minusDays(1);
    public static LocalDateTime FutureDate = now.plusDays(1);
    public static LocalDateTime FutureDate2 = now.plusDays(2);
    public static LocalDateTime FutureDate3 = now.plusDays(2);

    public static ReadOnlyToDo TaskOldDueUnfinishedNewCreated =
        new ToDoBuilder("<DD|UF|>C").withDueDate(RecentDate).created(OldDate).build();

    public static ReadOnlyToDo TaskOldDueUnfinishedOldCreated =
        new ToDoBuilder("<DD|UF|<C").withDueDate(RecentDate).created(OlderDate).build();

    public static ReadOnlyToDo TaskNewDueUnfinishedNewCreated =
        new ToDoBuilder(">DD|UF|>C").withDueDate(FutureDate).created(OldDate).build();

    public static ReadOnlyToDo TaskNewDueUnfinishedOldCreated =
        new ToDoBuilder(">DD|UF|<C").withDueDate(FutureDate).created(OlderDate).build();

    public static ReadOnlyToDo TaskUnfinishedNewCreated =
        new ToDoBuilder("UF|>C").created(OldDate).build();

    public static ReadOnlyToDo TaskUnfinishedOldCreated =
        new ToDoBuilder("UF|<C").created(OlderDate).build();

    public static ReadOnlyToDo TaskOldFinished =
        new ToDoBuilder(">F").created(OldDate).finish(OldDate).build();

    public static ReadOnlyToDo TaskOlderFinished =
        new ToDoBuilder("<F").created(OldDate).finish(OlderDate).build();

    public static ReadOnlyToDo EventOldRangeUnfinishedNewCreated =
        new ToDoBuilder("<DR|UF|>C").withDateRange(
            FutureDate, FutureDate2
        ).created(OldDate).build();

    public static ReadOnlyToDo EventOldRangeUnfinishedOldCreated =
        new ToDoBuilder("<DR|UF|<C").withDateRange(
            FutureDate, FutureDate2
        ).created(OlderDate).build();

    public static ReadOnlyToDo EventNewRangeUnfinishedNewCreated =
        new ToDoBuilder(">DR|UF|>C").withDateRange(
            FutureDate2, FutureDate3
        ).created(OldDate).build();

    public static ReadOnlyToDo EventNewRangeUnfinishedOldCreated =
        new ToDoBuilder(">DR|UF|<C").withDateRange(
            FutureDate2, FutureDate3
        ).created(OlderDate).build();

    public static ReadOnlyToDo EventNewFinished =
        new ToDoBuilder(">F").withDateRange(
            OlderDate, OldDate
        ).build();

    public static ReadOnlyToDo EventOldFinished =
        new ToDoBuilder("<F").withDateRange(
            OldestDate, OlderDate
        ).build();

    public ToDoBuilder(String title) {
        toDo = new ToDo(new Title(title));
    }

    public ToDoBuilder withDateRange(LocalDateTime startDate, LocalDateTime endDate,
                                     Recurrence recurrence) {
        try {
            toDo.setDateRange(new DateRange(
                startDate, endDate, recurrence
            ));
        } catch (IllegalValueException e) {
            assert false : "Test data should not be invalid";
        }

        return this;
    }

    public ToDoBuilder withDateRange(LocalDateTime startDate, LocalDateTime endDate) {
        try {
            toDo.setDateRange(new DateRange(
                startDate, endDate
            ));
        } catch (IllegalValueException e) {
            assert false : "Test data should not be invalid";
        }

        return this;
    }

    public ToDoBuilder withDueDate(LocalDateTime dueDate) {
        toDo.setDueDate(
            new DueDate(dueDate)
        );

        return this;
    }

    public ToDoBuilder withDueDate(LocalDateTime dueDate, Recurrence recurrence) {
        toDo.setDueDate(
            new DueDate(dueDate, recurrence)
        );

        return this;
    }

    public ToDoBuilder withTags(String... tags) {
        Set<Tag> tagsSet = new HashSet<>();
        for (String tag : tags) {
            tagsSet.add(new Tag(tag));
        }

        toDo.setTags(tagsSet);

        return this;
    }

    public ToDoBuilder finish(LocalDateTime date) {
        toDo.setDateFinished(date);

        return this;
    }

    public ToDoBuilder created(LocalDateTime date) {
        toDo.setDateCreated(date);

        return this;
    }

    public ToDo build() {
        return toDo;
    }
}
```
