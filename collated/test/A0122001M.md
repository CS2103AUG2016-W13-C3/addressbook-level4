# A0122001M
###### \java\guitests\AddCommandTest.java
``` java

public class AddCommandTest extends CommanDoGuiTest {

    @Test
    public void addCommand_nonEmptyList_addSuccessful() throws IllegalValueException {
        // add one todo to existing list
        // add floating task
        ToDo[] currentList = td.getTypicalToDos();
        ToDo toDoToAdd = td.testToDoItem1;
        assertAddSuccess(toDoToAdd, 4, currentList);
        currentList = TestUtil.addToDosToList(currentList, 4, toDoToAdd);

        // add event
        toDoToAdd = td.testToDoItem2;
        assertAddSuccess(toDoToAdd, 1, currentList);
        currentList = TestUtil.addToDosToList(currentList, 1, toDoToAdd);

        // add deadline
        toDoToAdd = td.testToDoItem3;
        assertAddSuccess(toDoToAdd, 3, currentList);
        currentList = TestUtil.addToDosToList(currentList, 3, toDoToAdd);
    }
    
    @Test
    public void addCommand_emptyList_addSuccessful() {
        //add one todo to empty list
        commandBox.runCommand("clear");
        ToDo[] currentList = td.getEmptyToDos();
        ToDo toDoToAdd = td.toDoItem2;
        assertAddSuccess(toDoToAdd, currentList.length, currentList);
        currentList = TestUtil.addToDosToList(currentList, currentList.length, toDoToAdd);

        //add another todo
        toDoToAdd = td.toDoItem1;
        assertAddSuccess(toDoToAdd, currentList.length, currentList);
        currentList = TestUtil.addToDosToList(currentList, currentList.length, toDoToAdd);
    }
    
    @Test
    public void addCommand_invalidCommand_reportErrorMessage() {
        //Invalid add command:
        ToDo[] currentList = td.getTypicalToDos();

        //add duplicate todo
        commandBox.runCommand(CommandBuilder.buildAddCommand(td.toDoItem1));
        assertResultMessage(Messages.TODO_ALREADY_EXISTS);
        assertTrue(ToDoListPanelHandle.isBothListMatching(eventListPanel, taskListPanel, currentList));
        
        //add missing title
        commandBox.runCommand("add ");
        assertResultMessage(Messages.MISSING_TODO_TITLE + "\n" + Messages.ADD_COMMAND_FORMAT);
        assertTrue(ToDoListPanelHandle.isBothListMatching(eventListPanel, taskListPanel, currentList));

        //invalid command
        commandBox.runCommand("adds Johnny");
        assertResultMessage(String.format(Messages.UNKNOWN_COMMAND, "adds"));
    }
    
    @Test
    public void addCommand_invalidTimeWindow_reportErrorMessage() {
        ToDo[] currentList = td.getTypicalToDos();
        
        //enddate is earlier than start date
        commandBox.runCommand("add test from tomorrow to today");
        assertResultMessage(Messages.TODO_DATERANGE_END_MUST_AFTER_START + "\n" + Messages.DATE_FORMAT + "\n" + 
                Messages.ADD_COMMAND_FORMAT);
        assertTrue(ToDoListPanelHandle.isBothListMatching(eventListPanel, taskListPanel, currentList));
    }
    
    @Test
    public void addCommand_invalidDate_reportErrorMessage() {
        ToDo[] currentList = td.getTypicalToDos();
        
        //invalid start date
        commandBox.runCommand("add test from abcde to 1pm");
        assertResultMessage(Messages.INVALID_TODO_DATERANGE_START + "\n" + Messages.DATE_FORMAT + "\n" + 
                Messages.ADD_COMMAND_FORMAT);
        assertTrue(ToDoListPanelHandle.isBothListMatching(eventListPanel, taskListPanel, currentList));
        
        //invalid end date
        commandBox.runCommand("add test from 1pm to abcde");
        assertResultMessage(Messages.INVALID_TODO_DATERANGE_END + "\n" + Messages.DATE_FORMAT + "\n" + 
                Messages.ADD_COMMAND_FORMAT);
        assertTrue(ToDoListPanelHandle.isBothListMatching(eventListPanel, taskListPanel, currentList));
    }
    
    @Test
    public void addCommand_emptyDate_reportErrorMessage() {
        ToDo[] currentList = td.getTypicalToDos();
        
        //empty start date
        commandBox.runCommand("add test from to 1pm");
        assertResultMessage(Messages.MISSING_TODO_DATERANGE_START + "\n" + Messages.DATE_FORMAT + "\n" + 
                Messages.ADD_COMMAND_FORMAT);
        assertTrue(ToDoListPanelHandle.isBothListMatching(eventListPanel, taskListPanel, currentList));
       
        //empty end date
        commandBox.runCommand("add test from 1pm to");
        assertResultMessage(Messages.MISSING_TODO_DATERANGE_END + "\n" + Messages.DATE_FORMAT + "\n" + 
                Messages.ADD_COMMAND_FORMAT);
        assertTrue(ToDoListPanelHandle.isBothListMatching(eventListPanel, taskListPanel, currentList));
    }
    
    /**
     * Runs the add command to add the new Todos into the list and
     * confirms the result is correct.
     * 
     * @param todoToAdd     The Todo object to be added into the list.
     * @param idx           The index in the list where Todo object should be added.
     * @param currentList   A copy of the current list of Todos (before addition).
     */
    private void assertAddSuccess(ToDo todoToAdd, int idx, ToDo... currentList ) {
        commandBox.runCommand(CommandBuilder.buildAddCommand(todoToAdd));

        //confirm the new card contains the right data
        ToDoCardHandle eventListResult = eventListPanel.navigateToTodo(todoToAdd.getTitle().value);
        ToDoCardHandle taskListResult = taskListPanel.navigateToTodo(todoToAdd.getTitle().value);
        ToDoCardHandle addedCard = null;
        if (eventListResult != null)
            addedCard = eventListResult;
        else if (taskListResult != null)
            addedCard = taskListResult;
        assertMatching(todoToAdd, addedCard);

        //confirm the list now contains all previous persons plus the new person
        ToDo[] expectedList = TestUtil.addToDosToList(currentList, idx, todoToAdd);
        assertTrue(ToDoListPanelHandle.isBothListMatching(eventListPanel, taskListPanel, expectedList));
    }

}
```
###### \java\guitests\ClearCommandTest.java
``` java

public class ClearCommandTest extends CommanDoGuiTest {

    @Test
    public void clearCommand_validCommand_listCleared() {
        //verify a non-empty list can be cleared
        assertTrue(ToDoListPanelHandle.isBothListMatching(eventListPanel, taskListPanel, td.getTypicalToDos()));
        assertClearCommandSuccess();

        //verify other commands can work after a clear command
        commandBox.runCommand(CommandBuilder.buildAddCommand(td.testToDoItem1));
        assertTrue(ToDoListPanelHandle.isBothListMatching(eventListPanel, taskListPanel, td.testToDoItem1));
        commandBox.runCommand("delete 1");
        assertListSize(0);

        //verify clear command works when the list is empty
        assertClearCommandSuccess();
    }
    
    @Test
    public void clearCommand_invalidCommand_reportErrorMessage() {
        //verify clear command does not take in extra params
        commandBox.runCommand("clear 1");
        assertResultMessage(String.format(Messages.INVALID_COMMAND_FORMAT, "clear"));
        
        //verify clear command does not execute on similar bur wrong command name
        commandBox.runCommand("clears");
        assertResultMessage(String.format(Messages.UNKNOWN_COMMAND, "clears"));
    }
    
    
    /**
     * Runs clear command and asserts that there is no Todo remained
     * in the list
     */
    private void assertClearCommandSuccess() {
        commandBox.runCommand("clear");
        assertListSize(0);
        assertResultMessage(Messages.TODO_LIST_CLEARED);
    }
}
```
###### \java\guitests\CommanDoGuiTest.java
``` java

/**
 * A GUI Test class for CommanDo.
 */
public abstract class CommanDoGuiTest {

    public static final String SAVE_LOCATION_FOR_TESTING = TestUtil.getFilePathInSandboxFolder("sampleData.xml");

    /* The TestName Rule makes the current test name available inside test methods */
    @Rule
    public TestName name = new TestName();

    TestApp testApp;

    protected static TypicalTestToDos td = new TypicalTestToDos();

    /*
     *   Handles to GUI elements present at the start up are created in advance
     *   for easy access from child classes.
     */
    protected MainGuiHandle mainGui;
    protected MainMenuHandle mainMenu;
    protected EventListPanelHandle eventListPanel;
    protected TaskListPanelHandle taskListPanel;
    protected ResultDisplayHandle resultDisplay;
    protected CommandBoxHandle commandBox;
    private Stage stage;

    @BeforeClass
    public static void setupSpec() {
        try {
            FxToolkit.registerPrimaryStage();
            FxToolkit.hideStage();
        } catch (TimeoutException e) {
            e.printStackTrace();
        }
    }

    @Before
    public void setUp() throws Exception {
        FxToolkit.setupStage((stage) -> {
            mainGui = new MainGuiHandle(new GuiRobot(), stage);
            mainMenu = mainGui.getMainMenu();
            eventListPanel = mainGui.getEventListPanel();
            taskListPanel = mainGui.getTaskListPanel();
            resultDisplay = mainGui.getResultDisplay();
            commandBox = mainGui.getCommandBox();
            this.stage = stage;
        });

        EventsCenter.clearSubscribers();
        testApp = (TestApp) FxToolkit.setupApplication(() -> new TestApp(this::getInitialData, getToDoListFileLocation()));
        FxToolkit.showStage();
        while (!stage.isShowing());
        mainGui.focusOnMainApp();
    }

    /**
     * Override this in child classes to set the initial local data.
     * Return null to use the data in the data file at toDoListFilePath specified in file of {@link #getToDoListFileLocation()}
     */
    protected ToDoList getInitialData() {
        ToDoList todoList = TestUtil.generateEmptyToDoList();
        td.loadToDoListWithSampleData(todoList);
        return todoList;
    }

    /**
     * Override this in child classes to set the save file location.
     */
    protected String getToDoListFileLocation() {
        return SAVE_LOCATION_FOR_TESTING;
    }

    @After
    public void cleanup() throws TimeoutException {
        FxToolkit.cleanupStages();
    }

    /**
     * Asserts the person shown in the card is same as the given person
     */
    public void assertMatching(ReadOnlyToDo todo, ToDoCardHandle card) {
        assertTrue(TestUtil.compareCardAndToDo(card, todo));
    }
    
    /**
     * Asserts the size of the person list is equal to the given number.
     */
    protected void assertListSize(int size) {
        int numberOfToDo = eventListPanel.getNumberOfToDo() + taskListPanel.getNumberOfToDo();
        assertEquals(size, numberOfToDo);
    }

    /**
     * Asserts the message shown in the Result Display area is same as the given string.
     * @param expected
     */
    protected void assertResultMessage(String expected) {
        assertEquals(expected, resultDisplay.getText());
    }
}
```
###### \java\guitests\DeleteCommandTest.java
``` java

public class DeleteCommandTest extends CommanDoGuiTest {

    @Test
    public void deleteCommand_oneIndex_deleteFromList() {
        // delete the first in the list
        ToDo[] currentList = td.getTypicalToDos();
        int targetIndex = 1;
        assertDeleteSuccess(targetIndex, currentList);

        // delete the last in the list
        currentList = TestUtil.removeToDoFromList(currentList, targetIndex);
        targetIndex = currentList.length;
        assertDeleteSuccess(targetIndex, currentList);

        // delete from the middle of the list
        currentList = TestUtil.removeToDoFromList(currentList, targetIndex);
        targetIndex = currentList.length / 2;
        assertDeleteSuccess(targetIndex, currentList);
    }
    
    @Test
    public void deleteCommand_consectiveIndex_deleteFromList() {
        // delete consective indices i.e. delete todo with index 2 to 3
        ToDo[] currentList = td.getTypicalToDos();
        assertDeleteConsectiveSuccess(2, 3, currentList);
    }
    
    @Test
    public void deleteCommand_multipleIndex_deleteFromList() {
        // delete multiple indices
        ToDo[] currentList = td.getTypicalToDos();
        assertDeleteMultipleSuccess(currentList, 2, 4, 5);
    }
    
    @Test
    public void deleteCommand_deleteTime_removeTimeAndChangeToTask() {
        ToDo[] currentList = td.getTypicalToDos();
        String toDoTitle = currentList[0].getTitle().toString();
        // delete the time window
        commandBox.runCommand("delete 1 time");
        currentList = TestUtil.removeToDoFromList(currentList, 1);
        currentList = TestUtil.addToDosToList(currentList, currentList.length, td.toDoItem2.clearTimeConstraint());
        assertTrue(ToDoListPanelHandle.isBothListMatching(eventListPanel, taskListPanel, currentList));

        assertResultMessage(String.format(Messages.EDIT_COMMAND, toDoTitle));
    }

    @Test
    public void deleteCommand_deleteTag_allTagsRemoved() {
        ToDo[] currentList = td.getTypicalToDos();
        String toDoTitle = currentList[0].getTitle().toString();

        // delete the tag
        commandBox.runCommand("delete 1 tag");
        currentList = TestUtil.removeToDoFromList(currentList, 1);
        currentList = TestUtil.addToDosToList(currentList, 0, td.toDoItem2.setTags(Collections.emptySet()));
        assertTrue(ToDoListPanelHandle.isBothListMatching(eventListPanel, taskListPanel, currentList));

        assertResultMessage(String.format(Messages.EDIT_COMMAND, toDoTitle));
    }
    
    
    @Test
    public void deleteCommand_deleteDeadline_MoveToBottomOfList() {
        ToDo[] currentList = td.getTypicalToDos();
        String toDoTitle = currentList[2].getTitle().toString();
        // delete the deadline
        commandBox.runCommand("delete 3 time");
        currentList = TestUtil.removeToDoFromList(currentList, 3);
        currentList = TestUtil.addToDosToList(currentList, currentList.length, td.toDoItem4.clearTimeConstraint());
        assertTrue(ToDoListPanelHandle.isBothListMatching(eventListPanel, taskListPanel, currentList));

        assertResultMessage(String.format(Messages.EDIT_COMMAND, toDoTitle));
    }

    @Test
    public void deleteCommand_invalidIndex_reportErrorMessage() {
        // invalid index
        ToDo[] currentList = td.getTypicalToDos();
        int targetIndex = currentList.length + 1;
        commandBox.runCommand("delete " + targetIndex);
        assertResultMessage(String.format(Messages.TODO_ITEM_INDEX_INVALID, targetIndex));
        
        targetIndex = 0;
        commandBox.runCommand("delete " + targetIndex);
        assertResultMessage(String.format(Messages.TODO_ITEM_INDEX_INVALID, targetIndex));

        targetIndex = -1;
        commandBox.runCommand("delete " + targetIndex);
        assertResultMessage(String.format(Messages.TODO_ITEM_INDEX_INVALID, targetIndex));
        
        //empty index      
        commandBox.runCommand("delete   ");
        assertResultMessage(Messages.MISSING_TODO_ITEM_INDEX + "\n" + Messages.DELETE_COMMAND_FORMAT);
    }
    
    @Test
    public void deleteCommand_endIndexGreaterThanStartIndex_reportErrorMessage() {
        commandBox.runCommand("delete 2 to 1");
        assertResultMessage(Messages.INDEXRANGE_CONSTRAINTS + "\n" + Messages.DELETE_COMMAND_FORMAT);
    }
    
    @Test
    public void deleteCommand_invalidParams_reportErrorMessage() {
        commandBox.runCommand("delete abc 1");
        assertResultMessage(Messages.MISSING_TODO_ITEM_INDEX + "\n" + Messages.DELETE_COMMAND_FORMAT);
        
        commandBox.runCommand("delete 1 abc");
        assertResultMessage(String.format(Messages.INVALID_COMMAND_FORMAT, "delete") + "\n" + Messages.DELETE_COMMAND_FORMAT);
    }
    
    @Test
    public void deleteCommand_invalidCommandName_reportErrorMessage() {
        // invalid command name
        commandBox.runCommand("deleted 1");
        assertResultMessage(String.format(Messages.UNKNOWN_COMMAND, "deleted"));
    }

    /**
     * Runs the delete command to delete the single Todo at specified index and
     * confirms the result is correct.
     * 
     * @param targetIndex   The indices Todos to be deleted in the list.
     * @param currentList   A copy of the current list of Todos (before deletion).
     */
    private void assertDeleteSuccess(int targetIndexOneIndexed, final ToDo[] currentList) {
        ToDo TodoToDelete = currentList[targetIndexOneIndexed - 1];
        ToDo[] expectedRemainder = TestUtil.removeToDoFromList(currentList, targetIndexOneIndexed);

        commandBox.runCommand("delete " + targetIndexOneIndexed);

        // confirm the list now contains all previous Todos except the deleted Todos
        assertTrue(ToDoListPanelHandle.isBothListMatching(eventListPanel, taskListPanel, expectedRemainder));

        // confirm the result message is correct
        assertResultMessage(String.format(Messages.DELETE_COMMAND, getToDosString(Collections.singletonList(TodoToDelete))));
    }
    
    /**
     * Runs the delete command to delete the consective Todos (e.g. from index 2 to 4) and
     * confirms the result is correct.
     * 
     * @param startIndex    The starting index Todo to be deleted in the list.
     * @param endIndex      The ending index Todo to be deleted in the list.
     * @param currentList   A copy of the current list of Todos (before deletion).
     */
    private void assertDeleteConsectiveSuccess(int startIndex, int endIndex, final ToDo[] currentList) {
        ToDo[] expectedRemainder = currentList;

        List<ToDo> expectedList = new ArrayList<ToDo>();
        // delete all indices from the list
        for (int i = startIndex; i <= endIndex; i++) {
            expectedList.add(expectedRemainder[startIndex - 1]);
            expectedRemainder = TestUtil.removeToDoFromList(expectedRemainder, startIndex);
        }

        commandBox.runCommand("delete " + startIndex + " to " + endIndex);

        // confirm the list now contains all previous Todoss except the deleted Todos
        assertTrue(ToDoListPanelHandle.isBothListMatching(eventListPanel, taskListPanel, expectedRemainder));

        // confirm the result message is correct
        assertResultMessage(String.format(Messages.DELETE_COMMAND, getToDosString(expectedList)));
    }

    private String getToDosString(List<ToDo> toDos) {
        return toDos.stream().map(toDo -> toDo.getTitle().toString()).collect(Collectors.joining(", "));
    }

    /**
     * Runs the delete command to delete multiple Todos (e.g. 2 4 5) and
     * confirms the result is correct.
     * 
     * @param indices       a sequence of indices to be deleted
     * @param currentList   A copy of the current list of Todos (before deletion).
     */
    private void assertDeleteMultipleSuccess(final ToDo[] currentList, int... indices) {
        ToDo[] expectedRemainder = currentList;
        String deletedIndices = "";

        // delete all indices from the list
        List<ToDo> expectedList = new ArrayList<ToDo>();
        for (int i=0; i<indices.length; i++) {
            expectedList.add(expectedRemainder[indices[i]-1]);
            deletedIndices += indices[i] + " ";
        }
        
        expectedRemainder = TestUtil.removeToDosFromList(currentList, expectedList.toArray(new ToDo[0]));
        
        commandBox.runCommand("delete " + deletedIndices);

        // confirm the list now contains all previous Todoss except the deleted Todos
        assertTrue(ToDoListPanelHandle.isBothListMatching(eventListPanel, taskListPanel, expectedRemainder));

        // confirm the result message is correct
        assertResultMessage(String.format(Messages.DELETE_COMMAND, getToDosString(expectedList)));
    }

}
```
###### \java\guitests\FindCommandTest.java
``` java

public class FindCommandTest extends CommanDoGuiTest {

    @Test
    public void findCommand_nonEmptyList() {
        //no results
        assertFindResult("find titles", Sets.newHashSet("titles"), Collections.emptySet());
        
        //multiple results
        assertFindResult("find title 3", Sets.newHashSet("title", "3"), Collections.emptySet(), td.toDoItem3);
        assertFindResult("find title tag2", Sets.newHashSet("title", "tag2"), Collections.emptySet(), td.toDoItem2, td.toDoItem5);
        
        //find after deleting one result
        commandBox.runCommand("delete 1");
        assertFindResult("find title 2", Sets.newHashSet("title", "2"), Collections.emptySet(), td.toDoItem5);
    }

    @Test
    public void findCommand_emptyList(){
        commandBox.runCommand("clear");
        
        //no results
        assertFindResult("find Jean", Sets.newHashSet("Jean"), Collections.emptySet());
    }

    @Test
    public void findCommand_invalidCommand_reportUnknownCommand() {
        commandBox.runCommand("findgeorge");
        assertResultMessage(String.format(Messages.UNKNOWN_COMMAND, "findgeorge"));
    }
    
    /**
     * Runs the find command to filter ToDoList according to given keywords
     * 
     * @param command        The find command to be executed.
     * @param keywords       Keywords that are used
     * @param tags           Tags that are used
     * @param expectedHits   The expected result list after filtering.
     */
    private void assertFindResult(String command, Set<String> keywords, Set<String> tags, ToDo... expectedHits) {
        Set<Tag> tagsSet = tags.stream().map(Tag::new).collect(Collectors.toSet());

        commandBox.runCommand(command);
        assertListSize(expectedHits.length); //number of expected todos = number of listed todos in result

        if (expectedHits.length == 0) {
            assertResultMessage(String.format(Messages.FIND_COMMAND_NO_TODOS, getSearchString(keywords, tags)));
        } else {
            assertResultMessage(String.format(Messages.FIND_COMMAND, getSearchString(keywords, tags)));
        }

        assertTrue(ToDoListPanelHandle.isBothListMatching(eventListPanel, taskListPanel, expectedHits));
    }

    private String getSearchString(Set<String> keywords, Set<String> tags) {
        Stream<String> keywordsStream = new TreeSet<>(keywords).stream();
        Stream<String> tagsStream = new TreeSet<>(tags).stream();

        return "[" + Stream.concat(keywordsStream, tagsStream).collect(Collectors.joining(", ")) + "]";
    }
}
```
###### \java\guitests\FinishCommandTest.java
``` java

public class FinishCommandTest extends CommanDoGuiTest {
        
    @Test
    public void finishCommand_oneIndex() {
        //finish one item
        ToDo[] currentList = td.getTypicalToDos();
        int targetIndex = 4;
        assertFinishSuccess(targetIndex, currentList);
           
    }
    
    @Test
    public void finishCommand_multipleIndices() {
        //finish multiple items
        ToDo[] currentList = td.getTypicalToDos();
        assertFinishConsectiveSuccess(3, 4, currentList);
    }
    
    @Test
    public void finishCommand_invalidIndex_reportError() {
        ToDo[] currentList = td.getTypicalToDos();
        int targetIndex = 4;
        
        //finish invalid index
        targetIndex = 7;
        commandBox.runCommand("finish " + targetIndex);
        assertResultMessage(String.format(Messages.TODO_ITEM_INDEX_INVALID, targetIndex ));
        
        targetIndex = 0;
        commandBox.runCommand("finish " + targetIndex);
        assertResultMessage(String.format(Messages.TODO_ITEM_INDEX_INVALID, targetIndex ));
        
        //finish event
        targetIndex = 1;
        commandBox.runCommand("finish " + targetIndex);
        assertResultMessage(String.format(Messages.FINISH_COMMAND_CANNOT_FINISH_EVENT, currentList[targetIndex-1].getTitle().toString()));
     
    }
    
    /**
     * Runs the finish command to mark the single Todo at specified index and
     * confirms the result is correct.
     * 
     * @param targetIndex   The indices Todos to be marked as done in the list.
     * @param currentList   A copy of the current list of Todos (before finish command).
     */
    
    private void assertFinishSuccess(int targetIndex, ToDo[] currentList) {
        ToDo TodosToFinish = currentList[targetIndex-1]; //-1 because array uses zero indexing
        TodosToFinish.setIsFinished(true);
        ToDo[] expectedRemainder = TestUtil.removeToDoFromList(currentList, targetIndex);
        expectedRemainder = TestUtil.addToDosToList(expectedRemainder, expectedRemainder.length, TodosToFinish);
        commandBox.runCommand("finish " + targetIndex);

        //confirm the list now contains all previous Todos with one marked as done
        assertTrue(ToDoListPanelHandle.isBothListMatching(eventListPanel, taskListPanel, expectedRemainder));

        //confirm the result message is correct
        assertResultMessage(String.format(Messages.FINISH_COMMAND, TodosToFinish.getTitle().toString()));
        
        //finish finished task
        targetIndex = 5;
        commandBox.runCommand("finish " + targetIndex);
        assertResultMessage(String.format(Messages.FINISH_COMMAND_ALREADY_FINISHED, expectedRemainder[targetIndex-1].getTitle().toString()));
        
    }
    
    /**
     * Runs the finish command to mark the consective Todos (e.g. from index 2 to 4) and
     * confirms the result is correct.
     * 
     * @param startIndex    The starting index Todo to be marked as done in the list.
     * @param endIndex      The ending index Todo to be marked as done in the list.
     * @param currentList   A copy of the current list of Todos (before finish command).
     */
    private void assertFinishConsectiveSuccess(int startIndex, int endIndex, ToDo[] currentList) {
        ToDo[] expectedRemainder = currentList;

        //setfinish for all target todos and reinsert them into the list
        List<ToDo> expectedList = new ArrayList<ToDo>();
        for (int i = startIndex; i<= endIndex; i++){
            ToDo TodosToFinish = expectedRemainder[startIndex-1]; //-1 because array uses zero indexing
            expectedList.add(TodosToFinish);
            TodosToFinish.setIsFinished(true);
            expectedRemainder = TestUtil.removeToDoFromList(expectedRemainder, startIndex);
            expectedRemainder = TestUtil.addToDosToList(expectedRemainder, expectedRemainder.length, TodosToFinish);
        }
        commandBox.runCommand("finish " + startIndex + " to " + endIndex);
        
        //confirm the list now contains all previous Todoss except the deleted Todos
        assertTrue(ToDoListPanelHandle.isBothListMatching(eventListPanel, taskListPanel, expectedRemainder));

        //confirm the result message is correct
        assertResultMessage(String.format(Messages.FINISH_COMMAND, getToDosString(expectedList)));
    }

    private String getToDosString(List<ToDo> toDos) {
        return toDos.stream().map(toDo -> toDo.getTitle().toString()).collect(Collectors.joining(", "));
    }
}
```
###### \java\guitests\guihandles\EventCardHandle.java
``` java

/**
 * Provides a handle to a person card in the person list panel.
 */
public class EventCardHandle extends GuiHandle implements ToDoCardHandle{
    private static final String TITLE_FIELD_ID = "#titleLabel";
    private static final String STARTDATE_FIELD_ID = "#startLabel";
    private static final String ENDDATE_FIELD_ID = "#endLabel";

    private Node node;

    public EventCardHandle(GuiRobot guiRobot, Stage primaryStage, Node node){
        super(guiRobot, primaryStage, null);
        this.node = node;
    }

    protected String getTextFromLabel(String fieldId) {
        return getTextFromLabel(fieldId, node);
    }

    public String getTitle() {
        return getTextFromLabel(TITLE_FIELD_ID);
    }

    public String getStartDate() {
        return getTextFromLabel(STARTDATE_FIELD_ID);
    }

    public String getEndDate() {
        return getTextFromLabel(ENDDATE_FIELD_ID);
    }

    public boolean isSameToDo(ReadOnlyToDo todo){
        return getTitle().equals(todo.getTitle().toString());
    }

    @Override
    public boolean equals(Object obj) {
        if(obj instanceof EventCardHandle) {
            EventCardHandle handle = (EventCardHandle) obj;
            return getTitle().equals(handle.getTitle()); //TODO: compare the rest
        }
        return super.equals(obj);
    }

    @Override
    public String toString() {
        return getTitle();
    }
}
```
###### \java\guitests\guihandles\EventListPanelHandle.java
``` java

/**
 * Provides a handle for the panel containing the Todo list.
 */
public class EventListPanelHandle extends GuiHandle implements ToDoListPanelHandle {

    public static final int NOT_FOUND = -1;
    public static final String CARD_PANE_ID = "#eventPane";

    private static final String EVENT_LIST_VIEW_ID = "#eventListView";

    public EventListPanelHandle(GuiRobot guiRobot, Stage primaryStage) {
        super(guiRobot, primaryStage, Config.ApplicationTitle);
    }

    public List<ReadOnlyToDo> getSelectedTodos() {
        ListView<ReadOnlyToDo> TodoList = getListView();
        return TodoList.getSelectionModel().getSelectedItems();
    }

    public ListView<ReadOnlyToDo> getListView() {
        return (ListView<ReadOnlyToDo>) getNode(EVENT_LIST_VIEW_ID);
    }
    
    /**
     * Returns true if the list is showing the Todo details correctly and in correct order.
     * @param Todos A list of Todo in the correct order.
     */
    public boolean isListMatching(ReadOnlyToDo... Todos) {
        return this.isListMatching(0, Todos);
    }

    /**
     * Clicks on the ListView.
     */
    public void clickOnListView() {
        Point2D point= TestUtil.getScreenMidPoint(getListView());
        guiRobot.clickOn(point.getX(), point.getY());
    }

    /**
     * Returns true if the {@code Todos} appear as the sub list (in that order) at position {@code startPosition}.
     */
    public boolean containsInOrder(int startPosition, ReadOnlyToDo... Todos) {
        List<ReadOnlyToDo> TodosInList = getListView().getItems();

        // Return false if the number of todos in the list is less than that in ui
        if (startPosition + Todos.length < TodosInList.size()){
            return false;
        }

        // Return false if any of the Todos doesn't match
        for (int i = 0; i < TodosInList.size(); i++) {
            if (!TodosInList.get(startPosition + i).getTitle().toString().equals(Todos[i].getTitle().toString())){
                return false;
            }
        }

        return true;
    }

    /**
     * Returns true if the list is showing the Todo details correctly and in correct order.
     * @param startPosition The starting position of the sub list.
     * @param Todos A list of Todo in the correct order.
     */
    public boolean isListMatching(int startPosition, ReadOnlyToDo... Todos) throws IllegalArgumentException {
        
        assertTrue(this.containsInOrder(startPosition, Todos));
        for (int i = 0; i < this.getNumberOfToDo(); i++) {
            final int scrollTo = i + startPosition;
            guiRobot.interact(() -> getListView().scrollTo(scrollTo));
            guiRobot.sleep(200);
            if (!TestUtil.compareCardAndToDo(getEventCardHandle(startPosition + i), Todos[i])) {
                return false;
            }
        }
        return true;
    }


    public EventCardHandle navigateToTodo(String title) {
        guiRobot.sleep(500); //Allow a bit of time for the list to be updated
        final Optional<ReadOnlyToDo> Todo = getListView().getItems().stream().filter(p -> p.getTitle().toString().equals(title)).findAny();
        if (!Todo.isPresent()) {
            return null;
        }

        return navigateToEvent(Todo.get());
    }

    /**
     * Navigates the listview to display and select the Todo.
     */
    public EventCardHandle navigateToEvent(ReadOnlyToDo Todo) {
        int index = getTodoIndex(Todo);

        guiRobot.interact(() -> {
            getListView().scrollTo(index);
            guiRobot.sleep(150);
            getListView().getSelectionModel().select(index);
        });
        guiRobot.sleep(100);
        return getEventCardHandle(Todo);
    }


    /**
     * Returns the position of the Todo given, {@code NOT_FOUND} if not found in the list.
     */
    public int getTodoIndex(ReadOnlyToDo targetTodo) {
        List<ReadOnlyToDo> TodosInList = getListView().getItems();
        for (int i = 0; i < TodosInList.size(); i++) {
            if(TodosInList.get(i).getTitle().equals(targetTodo.getTitle())){
                return i;
            }
        }
        return NOT_FOUND;
    }

    /**
     * Gets a Todo from the list by index
     */
    public ReadOnlyToDo getTodo(int index) {
        return getListView().getItems().get(index);
    }

    public EventCardHandle getEventCardHandle(int index) {
        return getEventCardHandle(new ToDo(getListView().getItems().get(index)));
    }

    public EventCardHandle getEventCardHandle(ReadOnlyToDo Todo) {
        Set<Node> nodes = getAllCardNodes();
        Optional<Node> EventCardNode = nodes.stream()
                .filter(n -> new EventCardHandle(guiRobot, primaryStage, n).isSameToDo(Todo))
                .findFirst();
        if (EventCardNode.isPresent()) {
            return new EventCardHandle(guiRobot, primaryStage, EventCardNode.get());
        } else {
            return null;
        }
    }

    protected Set<Node> getAllCardNodes() {
        return guiRobot.lookup(CARD_PANE_ID).queryAll();
    }

    public int getNumberOfToDo() {
        return getListView().getItems().size();
    }
}
```
###### \java\guitests\guihandles\HelpWindowHandle.java
``` java

/**
 * Provides a handle to the help window of the app.
 */
public class HelpWindowHandle extends GuiHandle {

    private static final String HELP_WINDOW_TITLE = "Help";
    private static final String HELP_WINDOW_ROOT_FIELD_ID = "#helpWindowRoot";

    public HelpWindowHandle(GuiRobot guiRobot, Stage primaryStage) {
        super(guiRobot, primaryStage, HELP_WINDOW_TITLE);
        guiRobot.sleep(1000);
    }

    public boolean isWindowOpen() {
        return getNode(HELP_WINDOW_ROOT_FIELD_ID) != null;
    }
    
    public boolean isWindowShowing(String commandName) {
        WebView node = (WebView) ((AnchorPane) getNode(HELP_WINDOW_ROOT_FIELD_ID)).getChildren().get(0);
        return node.getEngine().getLocation().contains(Config.UserGuideUrl);
    }
    
    public void closeWindow() {
        super.closeWindow();
        guiRobot.sleep(500);
    }

}
```
###### \java\guitests\guihandles\TaskCardHandle.java
``` java

/**
 * Provides a handle to a person card in the person list panel.
 */
public class TaskCardHandle extends GuiHandle implements ToDoCardHandle {
    private static final String TITLE_FIELD_ID = "#titleLabel";
    private static final String DUEDATE_FIELD_ID = "#dueLabel";

    private Node node;

    public TaskCardHandle(GuiRobot guiRobot, Stage primaryStage, Node node){
        super(guiRobot, primaryStage, null);
        this.node = node;
    }

    protected String getTextFromLabel(String fieldId) {
        return getTextFromLabel(fieldId, node);
    }

    public String getTitle() {
        return getTextFromLabel(TITLE_FIELD_ID);
    }

    public String getDueDate() {
        return getTextFromLabel(DUEDATE_FIELD_ID);
    }


    public boolean isSameToDo(ReadOnlyToDo todo){
        return getTitle().toString().equals(todo.getTitle().toString());
    }

    @Override
    public boolean equals(Object obj) {
        if(obj instanceof TaskCardHandle) {
            TaskCardHandle handle = (TaskCardHandle) obj;
            return getTitle().equals(handle.getTitle()); //TODO: compare the rest
        }
        return super.equals(obj);
    }

    @Override
    public String toString() {
        return getTitle();
    }
}
```
###### \java\guitests\guihandles\TaskListPanelHandle.java
``` java

/**
 * Provides a handle for the panel containing the Todo list.
 */
public class TaskListPanelHandle extends GuiHandle implements ToDoListPanelHandle {

    public static final int NOT_FOUND = -1;
    public static final String CARD_PANE_ID = "#taskPane";

    private static final String TASK_LIST_VIEW_ID = "#taskListView";

    public TaskListPanelHandle(GuiRobot guiRobot, Stage primaryStage) {
        super(guiRobot, primaryStage, Config.ApplicationTitle);
    }

    public List<ReadOnlyToDo> getSelectedTodos() {
        ListView<ReadOnlyToDo> TodoList = getListView();
        return TodoList.getSelectionModel().getSelectedItems();
    }

    public ListView<ReadOnlyToDo> getListView() {
        return (ListView<ReadOnlyToDo>) getNode(TASK_LIST_VIEW_ID);
    }

    /**
     * Returns true if the list is showing the Todo details correctly and in correct order.
     * @param Todos A list of Todo in the correct order.
     */
    public boolean isListMatching(ReadOnlyToDo... Todos) {
        return this.isListMatching(0, Todos);
    }

    /**
     * Clicks on the ListView.
     */
    public void clickOnListView() {
        Point2D point= TestUtil.getScreenMidPoint(getListView());
        guiRobot.clickOn(point.getX(), point.getY());
    }

    /**
     * Returns true if the {@code Todos} appear as the sub list (in that order) at position {@code startPosition}.
     */
    public boolean containsInOrder(int startPosition, ReadOnlyToDo... Todos) {
        List<ReadOnlyToDo> TodosInList = getListView().getItems();

        // Return false if the list in panel is too short to contain the given list
        if (Todos.length - startPosition < TodosInList.size()){
            return false;
        }

        // Return false if any of the Todos doesn't match
        for (int i = 0; i < TodosInList.size(); i++) {
            if (!TodosInList.get(i).getTitle().toString().equals(Todos[startPosition + i].getTitle().toString())){
                return false;
            }
        }

        return true;
    }

    /**
     * Returns true if the list is showing the Todo details correctly and in correct order.
     * @param startPosition The starting position of the sub list.
     * @param Todos A list of Todo in the correct order.
     */
    public boolean isListMatching(int startPosition, ReadOnlyToDo... Todos) throws IllegalArgumentException {
        
        assertTrue(this.containsInOrder(startPosition, Todos));
        for (int i = 0; i < getNumberOfToDo(); i++) {
            final int scrollTo = i + startPosition;
            guiRobot.interact(() -> getListView().scrollTo(scrollTo));
            guiRobot.sleep(200);
            if (!TestUtil.compareCardAndToDo(getTaskCardHandle(i), Todos[startPosition + i])) {
                return false;
            }
        }
        return true;
    }

    public TaskCardHandle navigateToTodo(String title) {
        guiRobot.sleep(500); //Allow a bit of time for the list to be updated
        final Optional<ReadOnlyToDo> Todo = getListView().getItems().stream().filter(p -> p.getTitle().toString().equals(title)).findAny();
        if (!Todo.isPresent()) {
            return null;
        }

        return navigateToTask(Todo.get());
    }

    /**
     * Navigates the listview to display and select the Todo.
     */
    public TaskCardHandle navigateToTask(ReadOnlyToDo Todo) {
        int index = getTodoIndex(Todo);

        guiRobot.interact(() -> {
            getListView().scrollTo(index);
            guiRobot.sleep(150);
            getListView().getSelectionModel().select(index);
        });
        guiRobot.sleep(100);
        return getTaskCardHandle(Todo);
    }


    /**
     * Returns the position of the Todo given, {@code NOT_FOUND} if not found in the list.
     */
    public int getTodoIndex(ReadOnlyToDo targetTodo) {
        List<ReadOnlyToDo> TodosInList = getListView().getItems();
        for (int i = 0; i < TodosInList.size(); i++) {
            if(TodosInList.get(i).getTitle().equals(targetTodo.getTitle())){
                return i;
            }
        }
        return NOT_FOUND;
    }

    /**
     * Gets a Todo from the list by index
     */
    public ReadOnlyToDo getTodo(int index) {
        return getListView().getItems().get(index);
    }

    public TaskCardHandle getTaskCardHandle(int index) {
        return getTaskCardHandle(new ToDo(getListView().getItems().get(index)));
    }

    public TaskCardHandle getTaskCardHandle(ReadOnlyToDo Todo) {
        Set<Node> nodes = getAllCardNodes();
        Optional<Node> taskCardNode = nodes.stream()
                .filter(n -> new TaskCardHandle(guiRobot, primaryStage, n).isSameToDo(Todo))
                .findFirst();
        if (taskCardNode.isPresent()) {
            return new TaskCardHandle(guiRobot, primaryStage, taskCardNode.get());
        } else {
            return null;
        }
    }

    protected Set<Node> getAllCardNodes() {
        return guiRobot.lookup(CARD_PANE_ID).queryAll();
    }

    public int getNumberOfToDo() {
        return getListView().getItems().size();
    }
}
```
###### \java\guitests\guihandles\ToDoCardHandle.java
``` java

public interface ToDoCardHandle {

    boolean isSameToDo(ReadOnlyToDo todo);

}
```
###### \java\guitests\guihandles\ToDoListPanelHandle.java
``` java

public interface ToDoListPanelHandle {
    public static boolean isBothListMatching(EventListPanelHandle eventListPanel, TaskListPanelHandle taskListPanel, ToDo... currentList){
        return eventListPanel.isListMatching(currentList) && 
                taskListPanel.isListMatching(eventListPanel.getNumberOfToDo(), currentList);
    }
}
```
###### \java\guitests\HelpWindowTest.java
``` java

public class HelpWindowTest extends CommanDoGuiTest {

    @Test
    public void openHelpWindow() {

        assertHelpWindowOpen(commandBox.runHelpCommand());
        
        assertHelpWindowOpenAtCommand(commandBox.runHelpCommand("add"), "add");
    }
    
    /**
     * Runs help command and asserts that correct page and url is displayed
     * 
     * @param helpWindowHandle The current handle of help window 
     */
    private void assertHelpWindowOpen(HelpWindowHandle helpWindowHandle) {
        assertTrue(helpWindowHandle.isWindowOpen());
        assertTrue(helpWindowHandle.isWindowShowing(""));
        helpWindowHandle.closeWindow();
    }
    
    /**
     * Runs help command and asserts that correct page and url is displayed
     * and the page is positioned at the section of given command
     * 
     * @param helpWindowHandle      The current handle of help window 
     * @param command               The command name of section to be displayed
     */    
    private void assertHelpWindowOpenAtCommand(HelpWindowHandle helpWindowHandle, String commandName) {
        assertTrue(helpWindowHandle.isWindowOpen());
        assertTrue(helpWindowHandle.isWindowShowing("add"));
        helpWindowHandle.closeWindow();
    }
}
```
###### \java\guitests\RecallCommandTest.java
``` java

public class RecallCommandTest extends CommanDoGuiTest {

    @Test
    public void recallCommand_nonEmptyList() {
        //recall when no finished items
        commandBox.runCommand("recall");
        assertListSize(0);
        
        //go back to current list
        commandBox.runCommand("find"); 

        //recall when some items are finished
        commandBox.runCommand("finish 4 5");
        
        //no results
        assertRecallResult("recall titles", Sets.newHashSet("titles"), Collections.emptySet());
        
        //multiple results
        assertRecallResult("recall title", Sets.newHashSet("title"), Collections.emptySet(), td.toDoItem5.setIsFinished(true), td.toDoItem1.setIsFinished(true));
        assertRecallResult("recall #tag2", Collections.emptySet(), Sets.newHashSet("#tag2"), td.toDoItem5.setIsFinished(true));
    }

    @Test
    public void recallCommand_emptyList() {
        commandBox.runCommand("clear");
        assertRecallResult("recall title", Sets.newHashSet("title"), Collections.emptySet()); //no results
    }

    @Test
    public void recallCommand_invalidCommand_reportErrorMessage() {
        commandBox.runCommand("recalltest");
        assertResultMessage(String.format(Messages.UNKNOWN_COMMAND, "recalltest"));
    }
    
    /**
     * Runs the recall command to filter ToDoList according to given keywords
     * 
     * @param command        The recall command to be executed.
     * @param keywords       Keywords that are used
     * @param tags           Tags that are used
     * @param expectedHits   The expected result list after filtering.
     */
    private void assertRecallResult(String command, Set<String> keywords, Set<String> tags, ToDo... expectedHits ) {
        commandBox.runCommand(command);
        assertListSize(expectedHits.length);  //number of expected todos = number of listed todos

        if (expectedHits.length == 0) {
            assertResultMessage(String.format(Messages.RECALL_COMMAND_NO_TODOS, getSearchString(keywords, tags)));
        } else {
            assertResultMessage(String.format(Messages.RECALL_COMMAND, getSearchString(keywords, tags)));
        }

        assertTrue(ToDoListPanelHandle.isBothListMatching(eventListPanel, taskListPanel, expectedHits));
    }

    private String getSearchString(Set<String> keywords, Set<String> tags) {
        Stream<String> keywordsStream = new TreeSet<>(keywords).stream();
        Stream<String> tagsStream = new TreeSet<>(tags).stream();

        return "[" + Stream.concat(keywordsStream, tagsStream).collect(Collectors.joining(", ")) + "]";
    }
}
```
###### \java\guitests\utils\CommandBuilder.java
``` java

public class CommandBuilder {
    public static String buildAddCommand(ToDo todo) {
        StringBuilder sb = new StringBuilder();
        sb.append("add " + todo.getTitle().toString());
        
        if (todo.getDateRange().isPresent()) {
            sb.append(" from " + LocalDateFormatter.toSimpleFormat(todo.getDateRange().get().startDate) + " to " + LocalDateFormatter.toSimpleFormat(todo.getDateRange().get().endDate));
        }
        
        if (todo.getDueDate().isPresent()) {
            sb.append(" by" + " " + LocalDateFormatter.toSimpleFormat(todo.getDueDate().get().value));
        }
        
        if (todo.getTags() != null && todo.getTags().size()!=0) {
            todo.getTags().stream().forEach(s -> sb.append(" #" + s.value));
        }
        return sb.toString();
    }
}
```
###### \java\guitests\utils\LocalDateFormatter.java
``` java

public class LocalDateFormatter {
    static String toSimpleFormat(LocalDateTime ldt){
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd/MM/yyyy HHmm");
        return ldt.format(formatter) + "h";
    }
}
```
###### \java\guitests\utils\TestUtil.java
``` java

/**
 * A utility class for test cases.
 */
public class TestUtil {

    public static final String LS = System.lineSeparator();

    /**
     * Folder used for temp files created during testing. Ignored by Git.
     */
    public static final String SANDBOX_FOLDER = FileUtil.getPath("./src/test/data/sandbox/");

    public static final ToDo[] SAMPLE_TODO_DATA = getSampleToDoData();

    public static final Tag[] SAMPLE_TAG_DATA = getSampleTagData();

    public static void assertThrows(Class<? extends Throwable> expected, Runnable executable) {
        try {
            executable.run();
        } catch (Throwable actualException) {
            if (actualException.getClass().isAssignableFrom(expected)) {
                return;
            }
            String message = String.format("Expected thrown: %s, actual: %s", expected.getName(),
                    actualException.getClass().getName());
            throw new AssertionFailedError(message);
        }
        throw new AssertionFailedError(
                String.format("Expected %s to be thrown, but nothing was thrown.", expected.getName()));
    }

    private static ToDo[] getSampleToDoData() {
        try {
            //CHECKSTYLE.OFF: LineLength
            return new ToDo[]{
                new ToDo(new Title("test1")).setDateRange(new DateRange(LocalDateTime.now(), LocalDateTime.now().plusDays(2))).setIsFinished(false),
                new ToDo(new Title("test2")).setDateRange(new DateRange(LocalDateTime.now().plusWeeks(1), LocalDateTime.now().plusWeeks(2))).setIsFinished(false),
                new ToDo(new Title("test3")).setDueDate(new DueDate(LocalDateTime.now())).setIsFinished(false),
                new ToDo(new Title("test4")).setDueDate(new DueDate(LocalDateTime.now().plusDays(3))).setIsFinished(false),
                new ToDo(new Title("test5")),
                new ToDo(new Title("test6")),
            };
            //CHECKSTYLE.ON: LineLength
        } catch (IllegalValueException e) {
            assert false;
            // not possible
            return null;
        }
    }


    private static Tag[] getSampleTagData() {
        return new Tag[]{
            new Tag("tag1"),
            new Tag("tag2")
        };
    }

    public static List<ToDo> generateSampleToDoData() {
        return Arrays.asList(SAMPLE_TODO_DATA);
    }

    /**
     * Appends the file name to the sandbox folder path.
     * Creates the sandbox folder if it doesn't exist.
     * @param fileName
     * @return
     */
    public static String getFilePathInSandboxFolder(String fileName) {
        try {
            FileUtil.createDirs(new File(SANDBOX_FOLDER));
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
        return SANDBOX_FOLDER + fileName;
    }

    public static void createDataFileWithSampleData(String filePath) {
        createDataFileWithData(generateSampleStorageToDoList(), filePath);
    }

    public static <T> void createDataFileWithData(T data, String filePath) {
        try {
            File saveFileForTesting = new File(filePath);
            FileUtil.createIfMissing(saveFileForTesting);
            XmlUtil.saveDataToFile(saveFileForTesting, data);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    public static void main(String... s) {
        createDataFileWithSampleData(CommanDoGuiTest.SAVE_LOCATION_FOR_TESTING);
    }

    public static ToDoList generateEmptyToDoList() {
        return new ToDoList();
    }

    public static XmlSerializableToDoList generateSampleStorageToDoList() {
        return new XmlSerializableToDoList(generateEmptyToDoList());
    }

    /**
     * Tweaks the {@code keyCodeCombination} to resolve the {@code KeyCode.SHORTCUT} to their
     * respective platform-specific keycodes
     */
    public static KeyCode[] scrub(KeyCodeCombination keyCodeCombination) {
        List<KeyCode> keys = new ArrayList<>();
        if (keyCodeCombination.getAlt() == KeyCombination.ModifierValue.DOWN) {
            keys.add(KeyCode.ALT);
        }
        if (keyCodeCombination.getShift() == KeyCombination.ModifierValue.DOWN) {
            keys.add(KeyCode.SHIFT);
        }
        if (keyCodeCombination.getMeta() == KeyCombination.ModifierValue.DOWN) {
            keys.add(KeyCode.META);
        }
        if (keyCodeCombination.getControl() == KeyCombination.ModifierValue.DOWN) {
            keys.add(KeyCode.CONTROL);
        }
        keys.add(keyCodeCombination.getCode());
        return keys.toArray(new KeyCode[]{});
    }

    public static boolean isHeadlessEnvironment() {
        String headlessProperty = System.getProperty("testfx.headless");
        return headlessProperty != null && headlessProperty.equals("true");
    }

    public static void captureScreenShot(String fileName) {
        File file = GuiTest.captureScreenshot();
        try {
            Files.copy(file, new File(fileName + ".png"));
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public static String descOnFail(Object... comparedObjects) {
        return "Comparison failed \n"
                + Arrays.asList(comparedObjects).stream()
                .map(Object::toString)
                .collect(Collectors.joining("\n"));
    }

    public static void setFinalStatic(Field field, Object newValue) throws NoSuchFieldException,
                                                                           IllegalAccessException {
        field.setAccessible(true);
        // remove final modifier from field
        Field modifiersField = Field.class.getDeclaredField("modifiers");
        modifiersField.setAccessible(true);
        // ~Modifier.FINAL is used to remove the final modifier from field so that its value is no longer
        // final and can be changed
        modifiersField.setInt(field, field.getModifiers() & ~Modifier.FINAL);
        field.set(null, newValue);
    }

    public static void initRuntime() throws TimeoutException {
        FxToolkit.registerPrimaryStage();
        FxToolkit.hideStage();
    }

    public static void tearDownRuntime() throws Exception {
        FxToolkit.cleanupStages();
    }

    /**
     * Gets private method of a class
     * Invoke the method using method.invoke(objectInstance, params...)
     *
     * Caveat: only find method declared in the current Class, not inherited from supertypes
     */
    public static Method getPrivateMethod(Class objectClass, String methodName) throws NoSuchMethodException {
        Method method = objectClass.getDeclaredMethod(methodName);
        method.setAccessible(true);
        return method;
    }

    public static void renameFile(File file, String newFileName) {
        try {
            Files.copy(file, new File(newFileName));
        } catch (IOException e1) {
            e1.printStackTrace();
        }
    }

    /**
     * Gets mid point of a node relative to the screen.
     * @param node
     * @return
     */
    public static Point2D getScreenMidPoint(Node node) {
        double x = getScreenPos(node).getMinX() + node.getLayoutBounds().getWidth() / 2;
        double y = getScreenPos(node).getMinY() + node.getLayoutBounds().getHeight() / 2;
        return new Point2D(x, y);
    }

    /**
     * Gets mid point of a node relative to its scene.
     * @param node
     * @return
     */
    public static Point2D getSceneMidPoint(Node node) {
        double x = getScenePos(node).getMinX() + node.getLayoutBounds().getWidth() / 2;
        double y = getScenePos(node).getMinY() + node.getLayoutBounds().getHeight() / 2;
        return new Point2D(x, y);
    }

    /**
     * Gets the bound of the node relative to the parent scene.
     * @param node
     * @return
     */
    public static Bounds getScenePos(Node node) {
        return node.localToScene(node.getBoundsInLocal());
    }

    public static Bounds getScreenPos(Node node) {
        return node.localToScreen(node.getBoundsInLocal());
    }

    public static double getSceneMaxX(Scene scene) {
        return scene.getX() + scene.getWidth();
    }

    public static double getSceneMaxY(Scene scene) {
        return scene.getX() + scene.getHeight();
    }

    public static Object getLastElement(List<?> list) {
        return list.get(list.size() - 1);
    }

    /**
     * Removes a subset from the list of todos.
     * @param todos The list of todos
     * @param todosToRemove The subset of todos.
     * @return The modified todos after removal of the subset from todos.
     */
    public static ToDo[] removeToDosFromList(final ToDo[] todos, ToDo... todosToRemove) {
        List<ToDo> listOfToDos = asList(todos);
        listOfToDos.removeAll(asList(todosToRemove));
        return listOfToDos.toArray(new ToDo[listOfToDos.size()]);
    }


    /**
     * Returns a copy of the list with the todo at specified index removed.
     * @param list original list to copy from
     * @param targetIndexInOneIndexedFormat e.g. index 1 if the first element is to be removed
     */
    public static ToDo[] removeToDoFromList(final ToDo[] list, int targetIndexInOneIndexedFormat) {
        return removeToDosFromList(list, list[targetIndexInOneIndexedFormat - 1]);
    }

    /**
     * Replaces todos[i] with a todo.
     * @param todos The array of todos.
     * @param todo The replacement todo
     * @param index The index of the todo to be replaced.
     * @return
     */
    public static ToDo[] replaceToDoFromList(ToDo[] todos, ToDo todo, int index) {
        todos[index] = todo;
        return todos;
    }

    /**
     * Appends todos to the array of todos.
     * @param todos A array of todos.
     * @param todosToAdd The todos that are to be appended behind the original array.
     * @return The modified array of todos.
     */
    public static ToDo[] addToDosToList(final ToDo[] todos, int idx, ToDo... todosToAdd) {
        List<ToDo> listOfToDos = asList(todos);
        List<ToDo> todoitem = asList(todosToAdd);
        listOfToDos.addAll(idx, todoitem);
        return listOfToDos.toArray(new ToDo[listOfToDos.size()]);
    }

    public static <T> List<T> asList(T[] objs) {
        List<T> list = new ArrayList<>();
        for (T obj : objs) {
            list.add(obj);
        }
        return list;
    }

    public static boolean compareCardAndToDo(ToDoCardHandle card, ReadOnlyToDo todo) {
        return card.isSameToDo(todo);
    }

    public static Tag[] getTagList(String tags) {
        if ("".equals(tags)) {
            return new Tag[]{};
        }

        final String[] split = tags.split(", ");

        final List<Tag> collect = Arrays.asList(split).stream().map(e -> {
            return new Tag(e.replaceFirst("Tag: ", ""));
        }).collect(Collectors.toList());

        return collect.toArray(new Tag[split.length]);
    }

}
```
###### \java\guitests\utils\TypicalTestToDos.java
``` java

/**
 *  To do items only for test
 */
public class TypicalTestToDos {

    public ToDo toDoItem1, toDoItem2, toDoItem3, toDoItem4, toDoItem5, toDoItem6, toDoItem7, testToDoItem1, testToDoItem2, testToDoItem3;

    public TypicalTestToDos() {
        resetToDos();
    }

    private void resetToDos() {
        toDoItem1 = new ToDoBuilder("title").finish(null).build();
        toDoItem2 = new ToDoBuilder("title 2").withTags("tag1", "tag2")
            .withDateRange(LocalDateTime.of(2016, 11, 1, 20, 1), LocalDateTime.of(2016, 12, 1, 20, 1))
            .finish(null).build();
        toDoItem3 = new ToDoBuilder("title 3").withTags("tag1", "tag3")
            .withDateRange(LocalDateTime.of(2017, 1, 1, 20, 1), LocalDateTime.of(2017, 2, 1, 20, 1))
            .finish(null).build();
        toDoItem4 = new ToDoBuilder("title 4").withDueDate(LocalDateTime.of(2016, 12, 1, 20, 1)).finish(null)
            .build();
        toDoItem5 = new ToDoBuilder("title 5").withTags("tag1", "tag2")
            .withDueDate(LocalDateTime.of(2017, 11, 1, 20, 1)).finish(null).build();
        toDoItem6 = new ToDoBuilder("title 99").withTags("tag1")
            .withDateRange(LocalDateTime.of(2017, 12, 9, 13, 30), LocalDateTime.of(2017, 12, 10, 12, 0))
            .finish(null).build();
        toDoItem7 = new ToDoBuilder("title 100").withTags("tag1")
            .withDateRange(LocalDateTime.of(2017, 12, 9, 13, 30), LocalDateTime.of(2017, 12, 9, 15, 0), Recurrence.Weekly)
            .finish(null).build();
        testToDoItem1 = new ToDoBuilder("test floating task").build();
        testToDoItem2 = new ToDoBuilder("test event").withTags("tag8", "tag3")
            .withDateRange(LocalDateTime.of(2016, 12, 3, 20, 1), LocalDateTime.of(2017, 2, 4, 20, 1))
            .finish(null).build();
        testToDoItem3 = new ToDoBuilder("test deadline").withTags("abcc", "tag2")
            .withDueDate(LocalDateTime.of(2016, 11, 14, 20, 1)).finish(null).build();
    }

    public void loadToDoListWithSampleData(ToDoList todoList) {
        try {
            resetToDos();
            todoList.add(new ToDo(toDoItem1)).add(new ToDo(toDoItem2)).add(new ToDo(toDoItem3)).add(new ToDo(toDoItem4))
                    .add(new ToDo(toDoItem5));
        } catch (IllegalValueException e) {
            assert false : "impossible";
        }

    }

    public ToDo[] getTypicalToDos() {
        return new ToDo[] { toDoItem2, toDoItem3,  toDoItem4, toDoItem5, toDoItem1 };
    }

    public ToDoList getTypicalToDoList() {
        ToDoList todoList = new ToDoList();
        loadToDoListWithSampleData(todoList);
        return todoList;
    }

    public ToDo[] getEmptyToDos() {
        return new ToDo[] {};
    }
}
```
###### \java\seedu\commando\commons\core\ConfigTest.java
``` java

public class ConfigTest {
    @Test
    public void getUserGuideAnchorForCommandWord_validCommandWord() {
        assertTrue(Config.getUserGuideAnchorForCommandWord("add").isPresent());
    }
    
    @Test
    public void getUserGuideAnchorForCommandWord_invalidCommandWord() {
        assertFalse(Config.getUserGuideAnchorForCommandWord("adds").isPresent());
        assertFalse(Config.getUserGuideAnchorForCommandWord("ad").isPresent());
    }
}
```
###### \java\seedu\commando\commons\util\CollectionUtilTest.java
``` java

public class CollectionUtilTest {
    @Test
    public void isAnyNull_NoNull() {
        assertFalse(CollectionUtil.isAnyNull(new Object(), new String(), new ToDo(new Title(new String()))));
    }

    @Test
    public void isAnyNull_someNull() {
        assertTrue(CollectionUtil.isAnyNull(null, new Object(), new Object()));
    }

    @Test
    public void elementsAreUnique_NotUnique() {
        ArrayList<Object> test = new ArrayList<Object>();
        test.add(new Integer(0));
        test.add(new Integer(1));
        test.add(new Integer(2));
        test.add(new Integer(2));
        test.add("test0");
        test.add("test0");
        assertFalse(CollectionUtil.elementsAreUnique(test));
    }

    @Test
    public void elementsAreUnique_AllUnique() {
        ArrayList<Object> test = new ArrayList<Object>();
        test.add(new Integer(0));
        test.add(new Integer(1));
        test.add(new Integer(2));
        test.add("test0");
        assertTrue(CollectionUtil.elementsAreUnique(test));
    }
    
    @Test
    public void assertNoNullElements_noNull() {
        Collection<Object> list = new ArrayList<>();
        list.add(new Object());
        list.add(new Object());
        CollectionUtil.assertNoNullElements(list);
    }
}
```
###### \java\seedu\commando\logic\parser\DateTimeParserTest.java
``` java

    @Test
    public void parseDateTime_relativeDayOfWeek_parsed() {
        LocalDateTime ldt = now.plusDays(1).with(TemporalAdjusters.nextOrSame(DayOfWeek.FRIDAY));

        assertEquals(
            LocalDateTime.of(ldt.getYear(), ldt.getMonthValue(), ldt.getDayOfMonth(),
                LocalTime.MIDNIGHT.getHour(),
                LocalTime.MIDNIGHT.getMinute()),
            dateTimeParser.parseDateTime("coming Friday").orElse(null)
        );

        assertEquals(
            LocalDateTime.of(ldt.getYear(), ldt.getMonthValue(), ldt.getDayOfMonth(),
                LocalTime.MIDNIGHT.getHour(),
                LocalTime.MIDNIGHT.getMinute()),
            dateTimeParser.parseDateTime("Friday").orElse(null)
        );

        LocalDateTime nextLdt = now.with(TemporalAdjusters.next(DayOfWeek.SUNDAY));
        assertEquals(
            LocalDateTime.of(nextLdt.getYear(), nextLdt.getMonthValue(), nextLdt.getDayOfMonth(),
                LocalTime.MIDNIGHT.getHour(),
                LocalTime.MIDNIGHT.getMinute()),
            dateTimeParser.parseDateTime("next sun").orElse(null)
        );

        // With time
        assertEquals(
            LocalDateTime.of(nextLdt.getYear(), nextLdt.getMonthValue(), nextLdt.getDayOfMonth(),
                13, 13),
            dateTimeParser.parseDateTime("next sun 1313h").orElse(null)
        );
    }

    @Test
    public void parseDateTime_relativeDaysLaterAgo_parsed() {
        LocalDateTime plus12Days = now.plusDays(12);
        assertEquals(
            LocalDateTime.of(plus12Days.getYear(), plus12Days.getMonthValue(), plus12Days.getDayOfMonth(),
                LocalTime.MIDNIGHT.getHour(),
                LocalTime.MIDNIGHT.getMinute()),
            dateTimeParser.parseDateTime("12 days later").orElse(null)
        );

        LocalDateTime minus8Days = now.minusDays(8);
        assertEquals(
            LocalDateTime.of(minus8Days.getYear(), minus8Days.getMonthValue(), minus8Days.getDayOfMonth(),
                LocalTime.MIDNIGHT.getHour(),
                LocalTime.MIDNIGHT.getMinute()),
            dateTimeParser.parseDateTime("8 days ago").orElse(null)
        );

        // 0 and 1 days invalid
        assertFalse(dateTimeParser.parseDateTime("1 day later").isPresent());
        assertFalse(dateTimeParser.parseDateTime("0 days later").isPresent());
        assertFalse(dateTimeParser.parseDateTime("0 days ago").isPresent());
    }

    @Test
    public void parseDateTime_relativeWeeksMonthsYearsLaterAgo_parsed() {
        LocalDateTime ldt = now.plusWeeks(2);
        assertEquals(
            LocalDateTime.of(ldt.getYear(), ldt.getMonthValue(), ldt.getDayOfMonth(),
                LocalTime.MIDNIGHT.getHour(),
                LocalTime.MIDNIGHT.getMinute()),
            dateTimeParser.parseDateTime("2 weeks later").orElse(null)
        );

        ldt = now.plusMonths(2);
        assertEquals(
            LocalDateTime.of(ldt.getYear(), ldt.getMonthValue(), ldt.getDayOfMonth(),
                LocalTime.MIDNIGHT.getHour(),
                LocalTime.MIDNIGHT.getMinute()),
            dateTimeParser.parseDateTime("2 months later").orElse(null)
        );

        ldt = now.minusYears(2);
        assertEquals(
            LocalDateTime.of(ldt.getYear(), ldt.getMonthValue(), ldt.getDayOfMonth(),
                LocalTime.MIDNIGHT.getHour(),
                LocalTime.MIDNIGHT.getMinute()),
            dateTimeParser.parseDateTime("2 years ago").orElse(null)
        );

        // 0 and 1 weeks invalid
        assertFalse(dateTimeParser.parseDateTime("1 week later").isPresent());
        assertFalse(dateTimeParser.parseDateTime("0 weeks later").isPresent());
        assertFalse(dateTimeParser.parseDateTime("0 weeks ago").isPresent());

        // With time
        ldt = now.plusWeeks(3);
        assertEquals(
            LocalDateTime.of(ldt.getYear(), ldt.getMonthValue(), ldt.getDayOfMonth(),
                10, 23),
            dateTimeParser.parseDateTime("3 weeks later 1023h").orElse(null)
        );
    }

    @Test
    public void parseDateTime_nextWeekMonthYear_parsed() {
        LocalDateTime ldt = now.plusWeeks(1);
        assertEquals(
            LocalDateTime.of(ldt.getYear(), ldt.getMonthValue(), ldt.getDayOfMonth(),
                LocalTime.MIDNIGHT.getHour(),
                LocalTime.MIDNIGHT.getMinute()),
            dateTimeParser.parseDateTime("next week").orElse(null)
        );

        ldt = now.plusMonths(1);
        assertEquals(
            LocalDateTime.of(ldt.getYear(), ldt.getMonthValue(), ldt.getDayOfMonth(),
                LocalTime.MIDNIGHT.getHour(),
                LocalTime.MIDNIGHT.getMinute()),
            dateTimeParser.parseDateTime("next month").orElse(null)
        );

        ldt = now.plusYears(1);
        assertEquals(
            LocalDateTime.of(ldt.getYear(), ldt.getMonthValue(), ldt.getDayOfMonth(),
                LocalTime.MIDNIGHT.getHour(),
                LocalTime.MIDNIGHT.getMinute()),
            dateTimeParser.parseDateTime("next year").orElse(null)
        );
    }

    @Test
    public void parseDateTime_timePresets_parsed() {
        assertEquals(
            LocalDateTime.of(now.getYear(), now.getMonthValue(), now.getDayOfMonth(),
                DateTimeParser.MorningLocalTime.getHour(),
                DateTimeParser.MorningLocalTime.getMinute()),
            dateTimeParser.parseDateTime("morning").orElse(null)
        );

        assertEquals(
            LocalDateTime.of(now.getYear(), now.getMonthValue(), now.getDayOfMonth(),
                DateTimeParser.AfternoonLocalTime.getHour(),
                DateTimeParser.AfternoonLocalTime.getMinute()),
            dateTimeParser.parseDateTime("this afternoon").orElse(null)
        );

        assertEquals(
            LocalDateTime.of(2016, 10, 10,
                DateTimeParser.EveningLocalTime.getHour(),
                DateTimeParser.EveningLocalTime.getMinute()),
            dateTimeParser.parseDateTime("10 Oct 2016 evening").orElse(null)
        );

        dateTimeParser.resetContext();

        assertEquals(
            LocalDateTime.of(now.getYear(), now.getMonthValue(), now.getDayOfMonth(),
                DateTimeParser.NightLocalTime.getHour(),
                DateTimeParser.NightLocalTime.getMinute()),
            dateTimeParser.parseDateTime("night").orElse(null)
        );

        assertEquals(
            LocalDateTime.of(now.getYear(), now.getMonthValue(), now.getDayOfMonth(),
                0, 0),
            dateTimeParser.parseDateTime("midnight").orElse(null)
        );
    }

    @Test
    public void parseDateTimePeriod_weeksMonthsYears_wholePeriodParsed() {
        assertEquals(
            new Pair<>(
                LocalDateTime.now().plusWeeks(1).with(DayOfWeek.MONDAY).with(LocalTime.of(0, 0)),
                LocalDateTime.now().plusWeeks(1).with(DayOfWeek.SUNDAY).with(LocalTime.of(23, 59))
            ),
            dateTimeParser.parseDateTimePeriod("next week").orElse(null)
        );

        assertEquals(
            new Pair<>(
                LocalDateTime.now().minusMonths(1).withDayOfMonth(1).with(LocalTime.of(0, 0)),
                LocalDateTime.now().withDayOfMonth(1).minusDays(1).with(LocalTime.of(23, 59))
            ),
            dateTimeParser.parseDateTimePeriod("last month").orElse(null)
        );

        assertEquals(
            new Pair<>(
                LocalDateTime.now().withDayOfYear(1).with(LocalTime.of(0, 0)),
                LocalDateTime.now().plusYears(1).withDayOfYear(1).minusDays(1).with(LocalTime.of(23, 59))
            ),
            dateTimeParser.parseDateTimePeriod("this year").orElse(null)
        );
    }
}
```
